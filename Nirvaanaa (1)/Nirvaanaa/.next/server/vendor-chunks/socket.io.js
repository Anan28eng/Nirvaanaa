/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/socket.io";
exports.ids = ["vendor-chunks/socket.io"];
exports.modules = {

/***/ "(rsc)/./node_modules/socket.io/node_modules/debug/src/browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/browser.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */ /**\n * This is the web browser implementation of `debug()`.\n */ exports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (()=>{\n    let warned = false;\n    return ()=>{\n        if (!warned) {\n            warned = true;\n            console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n        }\n    };\n})();\n/**\n * Colors.\n */ exports.colors = [\n    \"#0000CC\",\n    \"#0000FF\",\n    \"#0033CC\",\n    \"#0033FF\",\n    \"#0066CC\",\n    \"#0066FF\",\n    \"#0099CC\",\n    \"#0099FF\",\n    \"#00CC00\",\n    \"#00CC33\",\n    \"#00CC66\",\n    \"#00CC99\",\n    \"#00CCCC\",\n    \"#00CCFF\",\n    \"#3300CC\",\n    \"#3300FF\",\n    \"#3333CC\",\n    \"#3333FF\",\n    \"#3366CC\",\n    \"#3366FF\",\n    \"#3399CC\",\n    \"#3399FF\",\n    \"#33CC00\",\n    \"#33CC33\",\n    \"#33CC66\",\n    \"#33CC99\",\n    \"#33CCCC\",\n    \"#33CCFF\",\n    \"#6600CC\",\n    \"#6600FF\",\n    \"#6633CC\",\n    \"#6633FF\",\n    \"#66CC00\",\n    \"#66CC33\",\n    \"#9900CC\",\n    \"#9900FF\",\n    \"#9933CC\",\n    \"#9933FF\",\n    \"#99CC00\",\n    \"#99CC33\",\n    \"#CC0000\",\n    \"#CC0033\",\n    \"#CC0066\",\n    \"#CC0099\",\n    \"#CC00CC\",\n    \"#CC00FF\",\n    \"#CC3300\",\n    \"#CC3333\",\n    \"#CC3366\",\n    \"#CC3399\",\n    \"#CC33CC\",\n    \"#CC33FF\",\n    \"#CC6600\",\n    \"#CC6633\",\n    \"#CC9900\",\n    \"#CC9933\",\n    \"#CCCC00\",\n    \"#CCCC33\",\n    \"#FF0000\",\n    \"#FF0033\",\n    \"#FF0066\",\n    \"#FF0099\",\n    \"#FF00CC\",\n    \"#FF00FF\",\n    \"#FF3300\",\n    \"#FF3333\",\n    \"#FF3366\",\n    \"#FF3399\",\n    \"#FF33CC\",\n    \"#FF33FF\",\n    \"#FF6600\",\n    \"#FF6633\",\n    \"#FF9900\",\n    \"#FF9933\",\n    \"#FFCC00\",\n    \"#FFCC33\"\n];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */ // eslint-disable-next-line complexity\nfunction useColors() {\n    // NB: In an Electron preload script, document will be defined but not fully\n    // initialized. Since we know we're in Chrome, we'll just detect this case\n    // explicitly\n    if (false) {}\n    // Internet Explorer and Edge do not support colors.\n    if (typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n    }\n    let m;\n    // Is webkit? http://stackoverflow.com/a/16459606/376773\n    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n    return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n     false && (0) || // Is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    typeof navigator !== \"undefined\" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n    typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    args[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + args[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + module.exports.humanize(this.diff);\n    if (!this.useColors) {\n        return;\n    }\n    const c = \"color: \" + this.color;\n    args.splice(1, 0, c, \"color: inherit\");\n    // The final \"%c\" is somewhat tricky, because there could be other\n    // arguments passed either before or after the %c, so we need to\n    // figure out the correct index to insert the CSS into\n    let index = 0;\n    let lastC = 0;\n    args[0].replace(/%[a-zA-Z%]/g, (match)=>{\n        if (match === \"%%\") {\n            return;\n        }\n        index++;\n        if (match === \"%c\") {\n            // We only are interested in the *last* %c\n            // (the user may have provided their own)\n            lastC = index;\n        }\n    });\n    args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */ exports.log = console.debug || console.log || (()=>{});\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    try {\n        if (namespaces) {\n            exports.storage.setItem(\"debug\", namespaces);\n        } else {\n            exports.storage.removeItem(\"debug\");\n        }\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    let r;\n    try {\n        r = exports.storage.getItem(\"debug\");\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n    if (!r && typeof process !== \"undefined\" && \"env\" in process) {\n        r = process.env.DEBUG;\n    }\n    return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */ function localstorage() {\n    try {\n        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n        // The Browser also has localStorage in the global context.\n        return localStorage;\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */ formatters.j = function(v) {\n    try {\n        return JSON.stringify(v);\n    } catch (error) {\n        return \"[UnexpectedJSONParseError]: \" + error.message;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQkFBc0IsR0FFdEI7O0NBRUMsR0FFREEsa0JBQWtCLEdBQUdDO0FBQ3JCRCxZQUFZLEdBQUdFO0FBQ2ZGLFlBQVksR0FBR0c7QUFDZkgsaUJBQWlCLEdBQUdJO0FBQ3BCSixlQUFlLEdBQUdNO0FBQ2xCTixlQUFlLEdBQUcsQ0FBQztJQUNsQixJQUFJUSxTQUFTO0lBRWIsT0FBTztRQUNOLElBQUksQ0FBQ0EsUUFBUTtZQUNaQSxTQUFTO1lBQ1RDLFFBQVFDLElBQUksQ0FBQztRQUNkO0lBQ0Q7QUFDRDtBQUVBOztDQUVDLEdBRURWLGNBQWMsR0FBRztJQUNoQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNBO0FBRUQ7Ozs7OztDQU1DLEdBRUQsc0NBQXNDO0FBQ3RDLFNBQVNJO0lBQ1IsNEVBQTRFO0lBQzVFLDBFQUEwRTtJQUMxRSxhQUFhO0lBQ2IsSUFBSSxLQUFnSCxFQUFFLEVBRXJIO0lBRUQsb0RBQW9EO0lBQ3BELElBQUksT0FBT1ksY0FBYyxlQUFlQSxVQUFVQyxTQUFTLElB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RDtRQUMzRCxPQUFPNEM7SUFDUixFQUFFLE9BQU9MLE9BQU87SUFDZixVQUFVO0lBQ1YsMENBQTBDO0lBQzNDO0FBQ0Q7QUFFQWQsT0FBTy9CLE9BQU8sR0FBR21ELG1CQUFPQSxDQUFDLG1GQUFZbkQ7QUFFckMsTUFBTSxFQUFDb0QsVUFBVSxFQUFDLEdBQUdyQixPQUFPL0IsT0FBTztBQUVuQzs7Q0FFQyxHQUVEb0QsV0FBV0MsQ0FBQyxHQUFHLFNBQVVDLENBQUM7SUFDekIsSUFBSTtRQUNILE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ0Y7SUFDdkIsRUFBRSxPQUFPVCxPQUFPO1FBQ2YsT0FBTyxpQ0FBaUNBLE1BQU1ZLE9BQU87SUFDdEQ7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL25pcnZhYW5hYS1lY29tbWVyY2UvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcz84MDU2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRsZXQgbTtcblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiAobSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pKSAmJiBwYXJzZUludChtWzFdLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJmb3JtYXRBcmdzIiwic2F2ZSIsImxvYWQiLCJ1c2VDb2xvcnMiLCJzdG9yYWdlIiwibG9jYWxzdG9yYWdlIiwiZGVzdHJveSIsIndhcm5lZCIsImNvbnNvbGUiLCJ3YXJuIiwiY29sb3JzIiwid2luZG93IiwicHJvY2VzcyIsInR5cGUiLCJfX253anMiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0b0xvd2VyQ2FzZSIsIm1hdGNoIiwibSIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJXZWJraXRBcHBlYXJhbmNlIiwiZmlyZWJ1ZyIsImV4Y2VwdGlvbiIsInRhYmxlIiwicGFyc2VJbnQiLCJhcmdzIiwibmFtZXNwYWNlIiwibW9kdWxlIiwiaHVtYW5pemUiLCJkaWZmIiwiYyIsImNvbG9yIiwic3BsaWNlIiwiaW5kZXgiLCJsYXN0QyIsInJlcGxhY2UiLCJsb2ciLCJkZWJ1ZyIsIm5hbWVzcGFjZXMiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImVycm9yIiwiciIsImdldEl0ZW0iLCJlbnYiLCJERUJVRyIsImxvY2FsU3RvcmFnZSIsInJlcXVpcmUiLCJmb3JtYXR0ZXJzIiwiaiIsInYiLCJKU09OIiwic3RyaW5naWZ5IiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/node_modules/debug/src/common.js":
/*!*****************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/common.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */ function setup(env) {\n    createDebug.debug = createDebug;\n    createDebug.default = createDebug;\n    createDebug.coerce = coerce;\n    createDebug.disable = disable;\n    createDebug.enable = enable;\n    createDebug.enabled = enabled;\n    createDebug.humanize = __webpack_require__(/*! ms */ \"(rsc)/./node_modules/ms/index.js\");\n    createDebug.destroy = destroy;\n    Object.keys(env).forEach((key)=>{\n        createDebug[key] = env[key];\n    });\n    /**\n\t* The currently active debug mode names, and names to skip.\n\t*/ createDebug.names = [];\n    createDebug.skips = [];\n    /**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/ createDebug.formatters = {};\n    /**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/ function selectColor(namespace) {\n        let hash = 0;\n        for(let i = 0; i < namespace.length; i++){\n            hash = (hash << 5) - hash + namespace.charCodeAt(i);\n            hash |= 0; // Convert to 32bit integer\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n    }\n    createDebug.selectColor = selectColor;\n    /**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/ function createDebug(namespace) {\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug(...args) {\n            // Disabled?\n            if (!debug.enabled) {\n                return;\n            }\n            const self = debug;\n            // Set `diff` timestamp\n            const curr = Number(new Date());\n            const ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n            args[0] = createDebug.coerce(args[0]);\n            if (typeof args[0] !== \"string\") {\n                // Anything else let's inspect with %O\n                args.unshift(\"%O\");\n            }\n            // Apply any `formatters` transformations\n            let index = 0;\n            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{\n                // If we encounter an escaped % then don't increase the array index\n                if (match === \"%%\") {\n                    return \"%\";\n                }\n                index++;\n                const formatter = createDebug.formatters[format];\n                if (typeof formatter === \"function\") {\n                    const val = args[index];\n                    match = formatter.call(self, val);\n                    // Now we need to remove `args[index]` since it's inlined in the `format`\n                    args.splice(index, 1);\n                    index--;\n                }\n                return match;\n            });\n            // Apply env-specific formatting (colors, etc.)\n            createDebug.formatArgs.call(self, args);\n            const logFn = self.log || createDebug.log;\n            logFn.apply(self, args);\n        }\n        debug.namespace = namespace;\n        debug.useColors = createDebug.useColors();\n        debug.color = createDebug.selectColor(namespace);\n        debug.extend = extend;\n        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n        Object.defineProperty(debug, \"enabled\", {\n            enumerable: true,\n            configurable: false,\n            get: ()=>{\n                if (enableOverride !== null) {\n                    return enableOverride;\n                }\n                if (namespacesCache !== createDebug.namespaces) {\n                    namespacesCache = createDebug.namespaces;\n                    enabledCache = createDebug.enabled(namespace);\n                }\n                return enabledCache;\n            },\n            set: (v)=>{\n                enableOverride = v;\n            }\n        });\n        // Env-specific initialization logic for debug instances\n        if (typeof createDebug.init === \"function\") {\n            createDebug.init(debug);\n        }\n        return debug;\n    }\n    function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === \"undefined\" ? \":\" : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n    }\n    /**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/ function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        let i;\n        const split = (typeof namespaces === \"string\" ? namespaces : \"\").split(/[\\s,]+/);\n        const len = split.length;\n        for(i = 0; i < len; i++){\n            if (!split[i]) {\n                continue;\n            }\n            namespaces = split[i].replace(/\\*/g, \".*?\");\n            if (namespaces[0] === \"-\") {\n                createDebug.skips.push(new RegExp(\"^\" + namespaces.slice(1) + \"$\"));\n            } else {\n                createDebug.names.push(new RegExp(\"^\" + namespaces + \"$\"));\n            }\n        }\n    }\n    /**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/ function disable() {\n        const namespaces = [\n            ...createDebug.names.map(toNamespace),\n            ...createDebug.skips.map(toNamespace).map((namespace)=>\"-\" + namespace)\n        ].join(\",\");\n        createDebug.enable(\"\");\n        return namespaces;\n    }\n    /**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/ function enabled(name) {\n        if (name[name.length - 1] === \"*\") {\n            return true;\n        }\n        let i;\n        let len;\n        for(i = 0, len = createDebug.skips.length; i < len; i++){\n            if (createDebug.skips[i].test(name)) {\n                return false;\n            }\n        }\n        for(i = 0, len = createDebug.names.length; i < len; i++){\n            if (createDebug.names[i].test(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/ function toNamespace(regexp) {\n        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n    }\n    /**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/ function coerce(val) {\n        if (val instanceof Error) {\n            return val.stack || val.message;\n        }\n        return val;\n    }\n    /**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/ function destroy() {\n        console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n    }\n    createDebug.enable(createDebug.load());\n    return createDebug;\n}\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUNBOzs7Q0FHQyxHQUVELFNBQVNBLE1BQU1DLEdBQUc7SUFDakJDLFlBQVlDLEtBQUssR0FBR0Q7SUFDcEJBLFlBQVlFLE9BQU8sR0FBR0Y7SUFDdEJBLFlBQVlHLE1BQU0sR0FBR0E7SUFDckJILFlBQVlJLE9BQU8sR0FBR0E7SUFDdEJKLFlBQVlLLE1BQU0sR0FBR0E7SUFDckJMLFlBQVlNLE9BQU8sR0FBR0E7SUFDdEJOLFlBQVlPLFFBQVEsR0FBR0MsbUJBQU9BLENBQUM7SUFDL0JSLFlBQVlTLE9BQU8sR0FBR0E7SUFFdEJDLE9BQU9DLElBQUksQ0FBQ1osS0FBS2EsT0FBTyxDQUFDQyxDQUFBQTtRQUN4QmIsV0FBVyxDQUFDYSxJQUFJLEdBQUdkLEdBQUcsQ0FBQ2MsSUFBSTtJQUM1QjtJQUVBOztDQUVBLEdBRUFiLFlBQVljLEtBQUssR0FBRyxFQUFFO0lBQ3RCZCxZQUFZZSxLQUFLLEdBQUcsRUFBRTtJQUV0Qjs7OztDQUlBLEdBQ0FmLFlBQVlnQixVQUFVLEdBQUcsQ0FBQztJQUUxQjs7Ozs7Q0FLQSxHQUNBLFNBQVNDLFlBQVlDLFNBQVM7UUFDN0IsSUFBSUMsT0FBTztRQUVYLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixVQUFVRyxNQUFNLEVBQUVELElBQUs7WUFDMUNELE9BQU8sQ0FBRUEsUUFBUSxLQUFLQSxPQUFRRCxVQUFVSSxVQUFVLENBQUNGO1lBQ25ERCxRQUFRLEdBQUcsMkJBQTJCO1FBQ3ZDO1FBRUEsT0FBT25CLFlBQVl1QixNQUFNLENBQUNDLEtBQUtDLEdBQUcsQ0FBQ04sUUFBUW5CLFlBQVl1QixNQUFNLENBQUNGLE1BQU0sQ0FBQztJQUN0RTtJQUNBckIsWUFBWWlCLFdBQVcsR0FBR0E7SUFFMUI7Ozs7OztDQU1BLEdBQ0EsU0FBU2pCLFlBQVlrQixTQUFTO1FBQzdCLElBQUlRO1FB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QU1sRSxZQUFZZSxLQUFLLENBQUNNLE1BQU0sRUFBRUQsSUFBSThDLEtBQUs5QyxJQUFLO1lBQ3pELElBQUlwQixZQUFZZSxLQUFLLENBQUNLLEVBQUUsQ0FBQ3NELElBQUksQ0FBQ0QsT0FBTztnQkFDcEMsT0FBTztZQUNSO1FBQ0Q7UUFFQSxJQUFLckQsSUFBSSxHQUFHOEMsTUFBTWxFLFlBQVljLEtBQUssQ0FBQ08sTUFBTSxFQUFFRCxJQUFJOEMsS0FBSzlDLElBQUs7WUFDekQsSUFBSXBCLFlBQVljLEtBQUssQ0FBQ00sRUFBRSxDQUFDc0QsSUFBSSxDQUFDRCxPQUFPO2dCQUNwQyxPQUFPO1lBQ1I7UUFDRDtRQUVBLE9BQU87SUFDUjtJQUVBOzs7Ozs7Q0FNQSxHQUNBLFNBQVNGLFlBQVlJLE1BQU07UUFDMUIsT0FBT0EsT0FBT0MsUUFBUSxHQUNwQkMsU0FBUyxDQUFDLEdBQUdGLE9BQU9DLFFBQVEsR0FBR3ZELE1BQU0sR0FBRyxHQUN4Q21CLE9BQU8sQ0FBQyxXQUFXO0lBQ3RCO0lBRUE7Ozs7OztDQU1BLEdBQ0EsU0FBU3JDLE9BQU95QyxHQUFHO1FBQ2xCLElBQUlBLGVBQWVrQyxPQUFPO1lBQ3pCLE9BQU9sQyxJQUFJbUMsS0FBSyxJQUFJbkMsSUFBSW9DLE9BQU87UUFDaEM7UUFDQSxPQUFPcEM7SUFDUjtJQUVBOzs7Q0FHQSxHQUNBLFNBQVNuQztRQUNSd0UsUUFBUUMsSUFBSSxDQUFDO0lBQ2Q7SUFFQWxGLFlBQVlLLE1BQU0sQ0FBQ0wsWUFBWW1GLElBQUk7SUFFbkMsT0FBT25GO0FBQ1I7QUFFQW9GLE9BQU9DLE9BQU8sR0FBR3ZGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmlydmFhbmFhLWVjb21tZXJjZS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanM/NmNmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblx0XHRsZXQgbmFtZXNwYWNlc0NhY2hlO1xuXHRcdGxldCBlbmFibGVkQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5hYmxlT3ZlcnJpZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcykge1xuXHRcdFx0XHRcdG5hbWVzcGFjZXNDYWNoZSA9IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXM7XG5cdFx0XHRcdFx0ZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVuYWJsZWRDYWNoZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cdFx0Y3JlYXRlRGVidWcubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zbGljZSgxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIl0sIm5hbWVzIjpbInNldHVwIiwiZW52IiwiY3JlYXRlRGVidWciLCJkZWJ1ZyIsImRlZmF1bHQiLCJjb2VyY2UiLCJkaXNhYmxlIiwiZW5hYmxlIiwiZW5hYmxlZCIsImh1bWFuaXplIiwicmVxdWlyZSIsImRlc3Ryb3kiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsIm5hbWVzIiwic2tpcHMiLCJmb3JtYXR0ZXJzIiwic2VsZWN0Q29sb3IiLCJuYW1lc3BhY2UiLCJoYXNoIiwiaSIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJjb2xvcnMiLCJNYXRoIiwiYWJzIiwicHJldlRpbWUiLCJlbmFibGVPdmVycmlkZSIsIm5hbWVzcGFjZXNDYWNoZSIsImVuYWJsZWRDYWNoZSIsImFyZ3MiLCJzZWxmIiwiY3VyciIsIk51bWJlciIsIkRhdGUiLCJtcyIsImRpZmYiLCJwcmV2IiwidW5zaGlmdCIsImluZGV4IiwicmVwbGFjZSIsIm1hdGNoIiwiZm9ybWF0IiwiZm9ybWF0dGVyIiwidmFsIiwiY2FsbCIsInNwbGljZSIsImZvcm1hdEFyZ3MiLCJsb2dGbiIsImxvZyIsImFwcGx5IiwidXNlQ29sb3JzIiwiY29sb3IiLCJleHRlbmQiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJnZXQiLCJuYW1lc3BhY2VzIiwic2V0IiwidiIsImluaXQiLCJkZWxpbWl0ZXIiLCJuZXdEZWJ1ZyIsInNhdmUiLCJzcGxpdCIsImxlbiIsInB1c2giLCJSZWdFeHAiLCJzbGljZSIsIm1hcCIsInRvTmFtZXNwYWNlIiwiam9pbiIsIm5hbWUiLCJ0ZXN0IiwicmVnZXhwIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJFcnJvciIsInN0YWNrIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwibG9hZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */ if (typeof process === \"undefined\" || process.type === \"renderer\" || false === true || process.__nwjs) {\n    module.exports = __webpack_require__(/*! ./browser.js */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/browser.js\");\n} else {\n    module.exports = __webpack_require__(/*! ./node.js */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDLEdBRUQsSUFBSSxPQUFPQSxZQUFZLGVBQWVBLFFBQVFDLElBQUksS0FBSyxjQUFjRCxLQUFlLEtBQUssUUFBUUEsUUFBUUcsTUFBTSxFQUFFO0lBQ2hIQyw0SEFBeUI7QUFDMUIsT0FBTztJQUNOQSxzSEFBeUI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uaXJ2YWFuYWEtZWNvbW1lcmNlLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzP2IwMDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEZXRlY3QgRWxlY3Ryb24gcmVuZGVyZXIgLyBud2pzIHByb2Nlc3MsIHdoaWNoIGlzIG5vZGUsIGJ1dCB3ZSBzaG91bGRcbiAqIHRyZWF0IGFzIGEgYnJvd3Nlci5cbiAqL1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8IHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCBwcm9jZXNzLmJyb3dzZXIgPT09IHRydWUgfHwgcHJvY2Vzcy5fX253anMpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jyb3dzZXIuanMnKTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9ub2RlLmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsInR5cGUiLCJicm93c2VyIiwiX19ud2pzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/node_modules/debug/src/node.js":
/*!***************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/node.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */ const tty = __webpack_require__(/*! tty */ \"tty\");\nconst util = __webpack_require__(/*! util */ \"util\");\n/**\n * This is the Node.js implementation of `debug()`.\n */ exports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(()=>{}, \"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n/**\n * Colors.\n */ exports.colors = [\n    6,\n    2,\n    3,\n    4,\n    5,\n    1\n];\ntry {\n    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n    // eslint-disable-next-line import/no-extraneous-dependencies\n    const supportsColor = __webpack_require__(/*! supports-color */ \"(rsc)/./node_modules/supports-color/index.js\");\n    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n        exports.colors = [\n            20,\n            21,\n            26,\n            27,\n            32,\n            33,\n            38,\n            39,\n            40,\n            41,\n            42,\n            43,\n            44,\n            45,\n            56,\n            57,\n            62,\n            63,\n            68,\n            69,\n            74,\n            75,\n            76,\n            77,\n            78,\n            79,\n            80,\n            81,\n            92,\n            93,\n            98,\n            99,\n            112,\n            113,\n            128,\n            129,\n            134,\n            135,\n            148,\n            149,\n            160,\n            161,\n            162,\n            163,\n            164,\n            165,\n            166,\n            167,\n            168,\n            169,\n            170,\n            171,\n            172,\n            173,\n            178,\n            179,\n            184,\n            185,\n            196,\n            197,\n            198,\n            199,\n            200,\n            201,\n            202,\n            203,\n            204,\n            205,\n            206,\n            207,\n            208,\n            209,\n            214,\n            215,\n            220,\n            221\n        ];\n    }\n} catch (error) {\n// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{\n    return /^debug_/i.test(key);\n}).reduce((obj, key)=>{\n    // Camel-case\n    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{\n        return k.toUpperCase();\n    });\n    // Coerce string value into JS value\n    let val = process.env[key];\n    if (/^(yes|on|true|enabled)$/i.test(val)) {\n        val = true;\n    } else if (/^(no|off|false|disabled)$/i.test(val)) {\n        val = false;\n    } else if (val === \"null\") {\n        val = null;\n    } else {\n        val = Number(val);\n    }\n    obj[prop] = val;\n    return obj;\n}, {});\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */ function useColors() {\n    return \"colors\" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n}\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    const { namespace: name, useColors } = this;\n    if (useColors) {\n        const c = this.color;\n        const colorCode = \"\\x1b[3\" + (c < 8 ? c : \"8;5;\" + c);\n        const prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n        args[0] = prefix + args[0].split(\"\\n\").join(\"\\n\" + prefix);\n        args.push(colorCode + \"m+\" + module.exports.humanize(this.diff) + \"\\x1b[0m\");\n    } else {\n        args[0] = getDate() + name + \" \" + args[0];\n    }\n}\nfunction getDate() {\n    if (exports.inspectOpts.hideDate) {\n        return \"\";\n    }\n    return new Date().toISOString() + \" \";\n}\n/**\n * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.\n */ function log(...args) {\n    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + \"\\n\");\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    if (namespaces) {\n        process.env.DEBUG = namespaces;\n    } else {\n        // If you set a process.env field to null or undefined, it gets cast to the\n        // string 'null' or 'undefined'. Just delete instead.\n        delete process.env.DEBUG;\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    return process.env.DEBUG;\n}\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */ function init(debug) {\n    debug.inspectOpts = {};\n    const keys = Object.keys(exports.inspectOpts);\n    for(let i = 0; i < keys.length; i++){\n        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */ formatters.o = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts).split(\"\\n\").map((str)=>str.trim()).join(\" \");\n};\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */ formatters.O = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVELE1BQU1BLE1BQU1DLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBRXJCOztDQUVDLEdBRURFLFlBQVksR0FBR0M7QUFDZkQsV0FBVyxHQUFHRTtBQUNkRixrQkFBa0IsR0FBR0c7QUFDckJILFlBQVksR0FBR0k7QUFDZkosWUFBWSxHQUFHSztBQUNmTCxpQkFBaUIsR0FBR007QUFDcEJOLGVBQWUsR0FBR0QsS0FBS1MsU0FBUyxDQUMvQixLQUFPLEdBQ1A7QUFHRDs7Q0FFQyxHQUVEUixjQUFjLEdBQUc7SUFBQztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7Q0FBRTtBQUVuQyxJQUFJO0lBQ0gsMkdBQTJHO0lBQzNHLDZEQUE2RDtJQUM3RCxNQUFNVSxnQkFBZ0JaLG1CQUFPQSxDQUFDO0lBRTlCLElBQUlZLGlCQUFpQixDQUFDQSxjQUFjQyxNQUFNLElBQUlELGFBQVksRUFBR0UsS0FBSyxJQUFJLEdBQUc7UUFDeEVaLGNBQWMsR0FBRztZQUNoQjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNB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QUFXLEdBQUcsQ0FBQztJQUVyQixNQUFNRSxPQUFPRCxPQUFPQyxJQUFJLENBQUNoQixRQUFRYyxXQUFXO0lBQzVDLElBQUssSUFBSTRDLElBQUksR0FBR0EsSUFBSTFDLEtBQUsyQyxNQUFNLEVBQUVELElBQUs7UUFDckNELE1BQU0zQyxXQUFXLENBQUNFLElBQUksQ0FBQzBDLEVBQUUsQ0FBQyxHQUFHMUQsUUFBUWMsV0FBVyxDQUFDRSxJQUFJLENBQUMwQyxFQUFFLENBQUM7SUFDMUQ7QUFDRDtBQUVBWixPQUFPOUMsT0FBTyxHQUFHRixtQkFBT0EsQ0FBQyxtRkFBWUU7QUFFckMsTUFBTSxFQUFDNEQsVUFBVSxFQUFDLEdBQUdkLE9BQU85QyxPQUFPO0FBRW5DOztDQUVDLEdBRUQ0RCxXQUFXQyxDQUFDLEdBQUcsU0FBVUMsQ0FBQztJQUN6QixJQUFJLENBQUNoRCxXQUFXLENBQUNMLE1BQU0sR0FBRyxJQUFJLENBQUNILFNBQVM7SUFDeEMsT0FBT1AsS0FBS2dFLE9BQU8sQ0FBQ0QsR0FBRyxJQUFJLENBQUNoRCxXQUFXLEVBQ3JDNkIsS0FBSyxDQUFDLE1BQ05xQixHQUFHLENBQUNDLENBQUFBLE1BQU9BLElBQUlDLElBQUksSUFDbkJ0QixJQUFJLENBQUM7QUFDUjtBQUVBOztDQUVDLEdBRURnQixXQUFXTyxDQUFDLEdBQUcsU0FBVUwsQ0FBQztJQUN6QixJQUFJLENBQUNoRCxXQUFXLENBQUNMLE1BQU0sR0FBRyxJQUFJLENBQUNILFNBQVM7SUFDeEMsT0FBT1AsS0FBS2dFLE9BQU8sQ0FBQ0QsR0FBRyxJQUFJLENBQUNoRCxXQUFXO0FBQ3hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmlydmFhbmFhLWVjb21tZXJjZS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzPzE1MjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBOb2RlLmpzIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuZGVzdHJveSA9IHV0aWwuZGVwcmVjYXRlKFxuXHQoKSA9PiB7fSxcblx0J0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nXG4pO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFs2LCAyLCAzLCA0LCA1LCAxXTtcblxudHJ5IHtcblx0Ly8gT3B0aW9uYWwgZGVwZW5kZW5jeSAoYXMgaW4sIGRvZXNuJ3QgbmVlZCB0byBiZSBpbnN0YWxsZWQsIE5PVCBsaWtlIG9wdGlvbmFsRGVwZW5kZW5jaWVzIGluIHBhY2thZ2UuanNvbilcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuXHRjb25zdCBzdXBwb3J0c0NvbG9yID0gcmVxdWlyZSgnc3VwcG9ydHMtY29sb3InKTtcblxuXHRpZiAoc3VwcG9ydHNDb2xvciAmJiAoc3VwcG9ydHNDb2xvci5zdGRlcnIgfHwgc3VwcG9ydHNDb2xvcikubGV2ZWwgPj0gMikge1xuXHRcdGV4cG9ydHMuY29sb3JzID0gW1xuXHRcdFx0MjAsXG5cdFx0XHQyMSxcblx0XHRcdDI2LFxuXHRcdFx0MjcsXG5cdFx0XHQzMixcblx0XHRcdDMzLFxuXHRcdFx0MzgsXG5cdFx0XHQzOSxcblx0XHRcdDQwLFxuXHRcdFx0NDEsXG5cdFx0XHQ0Mixcblx0XHRcdDQzLFxuXHRcdFx0NDQsXG5cdFx0XHQ0NSxcblx0XHRcdDU2LFxuXHRcdFx0NTcsXG5cdFx0XHQ2Mixcblx0XHRcdDYzLFxuXHRcdFx0NjgsXG5cdFx0XHQ2OSxcblx0XHRcdDc0LFxuXHRcdFx0NzUsXG5cdFx0XHQ3Nixcblx0XHRcdDc3LFxuXHRcdFx0NzgsXG5cdFx0XHQ3OSxcblx0XHRcdDgwLFxuXHRcdFx0ODEsXG5cdFx0XHQ5Mixcblx0XHRcdDkzLFxuXHRcdFx0OTgsXG5cdFx0XHQ5OSxcblx0XHRcdDExMixcblx0XHRcdDExMyxcblx0XHRcdDEyOCxcblx0XHRcdDEyOSxcblx0XHRcdDEzNCxcblx0XHRcdDEzNSxcblx0XHRcdDE0OCxcblx0XHRcdDE0OSxcblx0XHRcdDE2MCxcblx0XHRcdDE2MSxcblx0XHRcdDE2Mixcblx0XHRcdDE2Myxcblx0XHRcdDE2NCxcblx0XHRcdDE2NSxcblx0XHRcdDE2Nixcblx0XHRcdDE2Nyxcblx0XHRcdDE2OCxcblx0XHRcdDE2OSxcblx0XHRcdDE3MCxcblx0XHRcdDE3MSxcblx0XHRcdDE3Mixcblx0XHRcdDE3Myxcblx0XHRcdDE3OCxcblx0XHRcdDE3OSxcblx0XHRcdDE4NCxcblx0XHRcdDE4NSxcblx0XHRcdDE5Nixcblx0XHRcdDE5Nyxcblx0XHRcdDE5OCxcblx0XHRcdDE5OSxcblx0XHRcdDIwMCxcblx0XHRcdDIwMSxcblx0XHRcdDIwMixcblx0XHRcdDIwMyxcblx0XHRcdDIwNCxcblx0XHRcdDIwNSxcblx0XHRcdDIwNixcblx0XHRcdDIwNyxcblx0XHRcdDIwOCxcblx0XHRcdDIwOSxcblx0XHRcdDIxNCxcblx0XHRcdDIxNSxcblx0XHRcdDIyMCxcblx0XHRcdDIyMVxuXHRcdF07XG5cdH1cbn0gY2F0Y2ggKGVycm9yKSB7XG5cdC8vIFN3YWxsb3cgLSB3ZSBvbmx5IGNhcmUgaWYgYHN1cHBvcnRzLWNvbG9yYCBpcyBhdmFpbGFibGU7IGl0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbn1cblxuLyoqXG4gKiBCdWlsZCB1cCB0aGUgZGVmYXVsdCBgaW5zcGVjdE9wdHNgIG9iamVjdCBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogICAkIERFQlVHX0NPTE9SUz1ubyBERUJVR19ERVBUSD0xMCBERUJVR19TSE9XX0hJRERFTj1lbmFibGVkIG5vZGUgc2NyaXB0LmpzXG4gKi9cblxuZXhwb3J0cy5pbnNwZWN0T3B0cyA9IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5maWx0ZXIoa2V5ID0+IHtcblx0cmV0dXJuIC9eZGVidWdfL2kudGVzdChrZXkpO1xufSkucmVkdWNlKChvYmosIGtleSkgPT4ge1xuXHQvLyBDYW1lbC1jYXNlXG5cdGNvbnN0IHByb3AgPSBrZXlcblx0XHQuc3Vic3RyaW5nKDYpXG5cdFx0LnRvTG93ZXJDYXNlKClcblx0XHQucmVwbGFjZSgvXyhbYS16XSkvZywgKF8sIGspID0+IHtcblx0XHRcdHJldHVybiBrLnRvVXBwZXJDYXNlKCk7XG5cdFx0fSk7XG5cblx0Ly8gQ29lcmNlIHN0cmluZyB2YWx1ZSBpbnRvIEpTIHZhbHVlXG5cdGxldCB2YWwgPSBwcm9jZXNzLmVudltrZXldO1xuXHRpZiAoL14oeWVzfG9ufHRydWV8ZW5hYmxlZCkkL2kudGVzdCh2YWwpKSB7XG5cdFx0dmFsID0gdHJ1ZTtcblx0fSBlbHNlIGlmICgvXihub3xvZmZ8ZmFsc2V8ZGlzYWJsZWQpJC9pLnRlc3QodmFsKSkge1xuXHRcdHZhbCA9IGZhbHNlO1xuXHR9IGVsc2UgaWYgKHZhbCA9PT0gJ251bGwnKSB7XG5cdFx0dmFsID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHR2YWwgPSBOdW1iZXIodmFsKTtcblx0fVxuXG5cdG9ialtwcm9wXSA9IHZhbDtcblx0cmV0dXJuIG9iajtcbn0sIHt9KTtcblxuLyoqXG4gKiBJcyBzdGRvdXQgYSBUVFk/IENvbG9yZWQgb3V0cHV0IGlzIGVuYWJsZWQgd2hlbiBgdHJ1ZWAuXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHRyZXR1cm4gJ2NvbG9ycycgaW4gZXhwb3J0cy5pbnNwZWN0T3B0cyA/XG5cdFx0Qm9vbGVhbihleHBvcnRzLmluc3BlY3RPcHRzLmNvbG9ycykgOlxuXHRcdHR0eS5pc2F0dHkocHJvY2Vzcy5zdGRlcnIuZmQpO1xufVxuXG4vKipcbiAqIEFkZHMgQU5TSSBjb2xvciBlc2NhcGUgY29kZXMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRjb25zdCB7bmFtZXNwYWNlOiBuYW1lLCB1c2VDb2xvcnN9ID0gdGhpcztcblxuXHRpZiAodXNlQ29sb3JzKSB7XG5cdFx0Y29uc3QgYyA9IHRoaXMuY29sb3I7XG5cdFx0Y29uc3QgY29sb3JDb2RlID0gJ1xcdTAwMUJbMycgKyAoYyA8IDggPyBjIDogJzg7NTsnICsgYyk7XG5cdFx0Y29uc3QgcHJlZml4ID0gYCAgJHtjb2xvckNvZGV9OzFtJHtuYW1lfSBcXHUwMDFCWzBtYDtcblxuXHRcdGFyZ3NbMF0gPSBwcmVmaXggKyBhcmdzWzBdLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgcHJlZml4KTtcblx0XHRhcmdzLnB1c2goY29sb3JDb2RlICsgJ20rJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZikgKyAnXFx1MDAxQlswbScpO1xuXHR9IGVsc2Uge1xuXHRcdGFyZ3NbMF0gPSBnZXREYXRlKCkgKyBuYW1lICsgJyAnICsgYXJnc1swXTtcblx0fVxufVxuXG5mdW5jdGlvbiBnZXREYXRlKCkge1xuXHRpZiAoZXhwb3J0cy5pbnNwZWN0T3B0cy5oaWRlRGF0ZSkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXHRyZXR1cm4gbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgJyAnO1xufVxuXG4vKipcbiAqIEludm9rZXMgYHV0aWwuZm9ybWF0V2l0aE9wdGlvbnMoKWAgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cyBhbmQgd3JpdGVzIHRvIHN0ZGVyci5cbiAqL1xuXG5mdW5jdGlvbiBsb2coLi4uYXJncykge1xuXHRyZXR1cm4gcHJvY2Vzcy5zdGRlcnIud3JpdGUodXRpbC5mb3JtYXRXaXRoT3B0aW9ucyhleHBvcnRzLmluc3BlY3RPcHRzLCAuLi5hcmdzKSArICdcXG4nKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHRpZiAobmFtZXNwYWNlcykge1xuXHRcdHByb2Nlc3MuZW52LkRFQlVHID0gbmFtZXNwYWNlcztcblx0fSBlbHNlIHtcblx0XHQvLyBJZiB5b3Ugc2V0IGEgcHJvY2Vzcy5lbnYgZmllbGQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGl0IGdldHMgY2FzdCB0byB0aGVcblx0XHQvLyBzdHJpbmcgJ251bGwnIG9yICd1bmRlZmluZWQnLiBKdXN0IGRlbGV0ZSBpbnN0ZWFkLlxuXHRcdGRlbGV0ZSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdHJldHVybiBwcm9jZXNzLmVudi5ERUJVRztcbn1cblxuLyoqXG4gKiBJbml0IGxvZ2ljIGZvciBgZGVidWdgIGluc3RhbmNlcy5cbiAqXG4gKiBDcmVhdGUgYSBuZXcgYGluc3BlY3RPcHRzYCBvYmplY3QgaW4gY2FzZSBgdXNlQ29sb3JzYCBpcyBzZXRcbiAqIGRpZmZlcmVudGx5IGZvciBhIHBhcnRpY3VsYXIgYGRlYnVnYCBpbnN0YW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBpbml0KGRlYnVnKSB7XG5cdGRlYnVnLmluc3BlY3RPcHRzID0ge307XG5cblx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuaW5zcGVjdE9wdHMpO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRkZWJ1Zy5pbnNwZWN0T3B0c1trZXlzW2ldXSA9IGV4cG9ydHMuaW5zcGVjdE9wdHNba2V5c1tpXV07XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJW8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsIG9uIGEgc2luZ2xlIGxpbmUuXG4gKi9cblxuZm9ybWF0dGVycy5vID0gZnVuY3Rpb24gKHYpIHtcblx0dGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblx0cmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKVxuXHRcdC5zcGxpdCgnXFxuJylcblx0XHQubWFwKHN0ciA9PiBzdHIudHJpbSgpKVxuXHRcdC5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIE1hcCAlTyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGxvd2luZyBtdWx0aXBsZSBsaW5lcyBpZiBuZWVkZWQuXG4gKi9cblxuZm9ybWF0dGVycy5PID0gZnVuY3Rpb24gKHYpIHtcblx0dGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblx0cmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKTtcbn07XG4iXSwibmFtZXMiOlsidHR5IiwicmVxdWlyZSIsInV0aWwiLCJleHBvcnRzIiwiaW5pdCIsImxvZyIsImZvcm1hdEFyZ3MiLCJzYXZlIiwibG9hZCIsInVzZUNvbG9ycyIsImRlc3Ryb3kiLCJkZXByZWNhdGUiLCJjb2xvcnMiLCJzdXBwb3J0c0NvbG9yIiwic3RkZXJyIiwibGV2ZWwiLCJlcnJvciIsImluc3BlY3RPcHRzIiwiT2JqZWN0Iiwia2V5cyIsInByb2Nlc3MiLCJlbnYiLCJmaWx0ZXIiLCJrZXkiLCJ0ZXN0IiwicmVkdWNlIiwib2JqIiwicHJvcCIsInN1YnN0cmluZyIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsIl8iLCJrIiwidG9VcHBlckNhc2UiLCJ2YWwiLCJOdW1iZXIiLCJCb29sZWFuIiwiaXNhdHR5IiwiZmQiLCJhcmdzIiwibmFtZXNwYWNlIiwibmFtZSIsImMiLCJjb2xvciIsImNvbG9yQ29kZSIsInByZWZpeCIsInNwbGl0Iiwiam9pbiIsInB1c2giLCJtb2R1bGUiLCJodW1hbml6ZSIsImRpZmYiLCJnZXREYXRlIiwiaGlkZURhdGUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ3cml0ZSIsImZvcm1hdFdpdGhPcHRpb25zIiwibmFtZXNwYWNlcyIsIkRFQlVHIiwiZGVidWciLCJpIiwibGVuZ3RoIiwiZm9ybWF0dGVycyIsIm8iLCJ2IiwiaW5zcGVjdCIsIm1hcCIsInN0ciIsInRyaW0iLCJPIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/node_modules/debug/src/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/broadcast-operator.js":
/*!***********************************************************!*\
  !*** ./node_modules/socket.io/dist/broadcast-operator.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RemoteSocket = exports.BroadcastOperator = void 0;\nconst socket_types_1 = __webpack_require__(/*! ./socket-types */ \"(rsc)/./node_modules/socket.io/dist/socket-types.js\");\nconst socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ \"(rsc)/./node_modules/socket.io-parser/build/cjs/index.js\");\nclass BroadcastOperator {\n    constructor(adapter, rooms = new Set(), exceptRooms = new Set(), flags = {}){\n        this.adapter = adapter;\n        this.rooms = rooms;\n        this.exceptRooms = exceptRooms;\n        this.flags = flags;\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @example\n     * // the foo event will be broadcast to all connected clients in the room-101 room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms (a client will be notified at most once)\n     * io.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ to(room) {\n        const rooms = new Set(this.rooms);\n        if (Array.isArray(room)) {\n            room.forEach((r)=>rooms.add(r));\n        } else {\n            rooms.add(room);\n        }\n        return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);\n    }\n    /**\n     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * // disconnect all clients in the \"room-101\" room\n     * io.in(\"room-101\").disconnectSockets();\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ in(room) {\n        return this.to(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @example\n     * // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     * io.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms\n     * io.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ except(room) {\n        const exceptRooms = new Set(this.exceptRooms);\n        if (Array.isArray(room)) {\n            room.forEach((r)=>exceptRooms.add(r));\n        } else {\n            exceptRooms.add(room);\n        }\n        return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return a new BroadcastOperator instance\n     */ compress(compress) {\n        const flags = Object.assign({}, this.flags, {\n            compress\n        });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because theyre connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.volatile.emit(\"hello\"); // the clients may or may not receive it\n     *\n     * @return a new BroadcastOperator instance\n     */ get volatile() {\n        const flags = Object.assign({}, this.flags, {\n            volatile: true\n        });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * // the foo event will be broadcast to all connected clients on this node\n     * io.local.emit(\"foo\", \"bar\");\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ get local() {\n        const flags = Object.assign({}, this.flags, {\n            local: true\n        });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation\n     *\n     * @example\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @param timeout\n     */ timeout(timeout) {\n        const flags = Object.assign({}, this.flags, {\n            timeout\n        });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Emits to all clients.\n     *\n     * @example\n     * // the foo event will be broadcast to all connected clients\n     * io.emit(\"foo\", \"bar\");\n     *\n     * // the foo event will be broadcast to all connected clients in the room-101 room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an acknowledgement expected from all connected clients\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @return Always true\n     */ emit(ev, ...args) {\n        if (socket_types_1.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${String(ev)}\" is a reserved event name`);\n        }\n        // set up packet object\n        const data = [\n            ev,\n            ...args\n        ];\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: data\n        };\n        const withAck = typeof data[data.length - 1] === \"function\";\n        if (!withAck) {\n            this.adapter.broadcast(packet, {\n                rooms: this.rooms,\n                except: this.exceptRooms,\n                flags: this.flags\n            });\n            return true;\n        }\n        const ack = data.pop();\n        let timedOut = false;\n        let responses = [];\n        const timer = setTimeout(()=>{\n            timedOut = true;\n            ack.apply(this, [\n                new Error(\"operation has timed out\"),\n                this.flags.expectSingleResponse ? null : responses\n            ]);\n        }, this.flags.timeout);\n        let expectedServerCount = -1;\n        let actualServerCount = 0;\n        let expectedClientCount = 0;\n        const checkCompleteness = ()=>{\n            if (!timedOut && expectedServerCount === actualServerCount && responses.length === expectedClientCount) {\n                clearTimeout(timer);\n                ack.apply(this, [\n                    null,\n                    this.flags.expectSingleResponse ? responses[0] : responses\n                ]);\n            }\n        };\n        this.adapter.broadcastWithAck(packet, {\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags\n        }, (clientCount)=>{\n            // each Socket.IO server in the cluster sends the number of clients that were notified\n            expectedClientCount += clientCount;\n            actualServerCount++;\n            checkCompleteness();\n        }, (clientResponse)=>{\n            // each client sends an acknowledgement\n            responses.push(clientResponse);\n            checkCompleteness();\n        });\n        this.adapter.serverCount().then((serverCount)=>{\n            expectedServerCount = serverCount;\n            checkCompleteness();\n        });\n        return true;\n    }\n    /**\n     * Emits an event and waits for an acknowledgement from all clients.\n     *\n     * @example\n     * try {\n     *   const responses = await io.timeout(1000).emitWithAck(\"some-event\");\n     *   console.log(responses); // one response per client\n     * } catch (e) {\n     *   // some clients did not acknowledge the event in the given delay\n     * }\n     *\n     * @return a Promise that will be fulfilled when all clients have acknowledged the event\n     */ emitWithAck(ev, ...args) {\n        return new Promise((resolve, reject)=>{\n            args.push((err, responses)=>{\n                if (err) {\n                    err.responses = responses;\n                    return reject(err);\n                } else {\n                    return resolve(responses);\n                }\n            });\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or\n     * {@link fetchSockets} instead.\n     */ allSockets() {\n        if (!this.adapter) {\n            throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n        }\n        return this.adapter.sockets(this.rooms);\n    }\n    /**\n     * Returns the matching socket instances. This method works across a cluster of several Socket.IO servers.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // return all Socket instances\n     * const sockets = await io.fetchSockets();\n     *\n     * // return all Socket instances in the \"room1\" room\n     * const sockets = await io.in(\"room1\").fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   console.log(socket.id);\n     *   console.log(socket.handshake);\n     *   console.log(socket.rooms);\n     *   console.log(socket.data);\n     *\n     *   socket.emit(\"hello\");\n     *   socket.join(\"room1\");\n     *   socket.leave(\"room2\");\n     *   socket.disconnect();\n     * }\n     */ fetchSockets() {\n        return this.adapter.fetchSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags\n        }).then((sockets)=>{\n            return sockets.map((socket)=>{\n                if (socket.server) {\n                    return socket; // local instance\n                } else {\n                    return new RemoteSocket(this.adapter, socket);\n                }\n            });\n        });\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     *\n     * // make all socket instances join the \"room1\" room\n     * io.socketsJoin(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room join the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsJoin([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */ socketsJoin(room) {\n        this.adapter.addSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags\n        }, Array.isArray(room) ? room : [\n            room\n        ]);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances leave the \"room1\" room\n     * io.socketsLeave(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room leave the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsLeave([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */ socketsLeave(room) {\n        this.adapter.delSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags\n        }, Array.isArray(room) ? room : [\n            room\n        ]);\n    }\n    /**\n     * Makes the matching socket instances disconnect.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)\n     * io.disconnectSockets();\n     *\n     * // make all socket instances in the \"room1\" room disconnect and close the underlying connections\n     * io.in(\"room1\").disconnectSockets(true);\n     *\n     * @param close - whether to close the underlying connection\n     */ disconnectSockets(close = false) {\n        this.adapter.disconnectSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags\n        }, close);\n    }\n}\nexports.BroadcastOperator = BroadcastOperator;\n/**\n * Expose of subset of the attributes and methods of the Socket class\n */ class RemoteSocket {\n    constructor(adapter, details){\n        this.id = details.id;\n        this.handshake = details.handshake;\n        this.rooms = new Set(details.rooms);\n        this.data = details.data;\n        this.operator = new BroadcastOperator(adapter, new Set([\n            this.id\n        ]), new Set(), {\n            expectSingleResponse: true\n        });\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation.\n     *\n     * @example\n     * const sockets = await io.fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   if (someCondition) {\n     *     socket.timeout(1000).emit(\"some-event\", (err) => {\n     *       if (err) {\n     *         // the client did not acknowledge the event in the given delay\n     *       }\n     *     });\n     *   }\n     * }\n     *\n     * // note: if possible, using a room instead of looping over all sockets is preferable\n     * io.timeout(1000).to(someConditionRoom).emit(\"some-event\", (err, responses) => {\n     *   // ...\n     * });\n     *\n     * @param timeout\n     */ timeout(timeout) {\n        return this.operator.timeout(timeout);\n    }\n    emit(ev, ...args) {\n        return this.operator.emit(ev, ...args);\n    }\n    /**\n     * Joins a room.\n     *\n     * @param {String|Array} room - room or array of rooms\n     */ join(room) {\n        return this.operator.socketsJoin(room);\n    }\n    /**\n     * Leaves a room.\n     *\n     * @param {String} room\n     */ leave(room) {\n        return this.operator.socketsLeave(room);\n    }\n    /**\n     * Disconnects this client.\n     *\n     * @param {Boolean} close - if `true`, closes the underlying connection\n     * @return {Socket} self\n     */ disconnect(close = false) {\n        this.operator.disconnectSockets(close);\n        return this;\n    }\n}\nexports.RemoteSocket = RemoteSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvYnJvYWRjYXN0LW9wZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBR0EseUJBQXlCLEdBQUcsS0FBSztBQUN4RCxNQUFNSSxpQkFBaUJDLG1CQUFPQSxDQUFDLDJFQUFnQjtBQUMvQyxNQUFNQyxxQkFBcUJELG1CQUFPQSxDQUFDLGtGQUFrQjtBQUNyRCxNQUFNRjtJQUNGSSxZQUFZQyxPQUFPLEVBQUVDLFFBQVEsSUFBSUMsS0FBSyxFQUFFQyxjQUFjLElBQUlELEtBQUssRUFBRUUsUUFBUSxDQUFDLENBQUMsQ0FBRTtRQUN6RSxJQUFJLENBQUNKLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNFLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO0lBQ2pCO0lBQ0E7Ozs7Ozs7Ozs7Ozs7OztLQWVDLEdBQ0RDLEdBQUdDLElBQUksRUFBRTtRQUNMLE1BQU1MLFFBQVEsSUFBSUMsSUFBSSxJQUFJLENBQUNELEtBQUs7UUFDaEMsSUFBSU0sTUFBTUMsT0FBTyxDQUFDRixPQUFPO1lBQ3JCQSxLQUFLRyxPQUFPLENBQUMsQ0FBQ0MsSUFBTVQsTUFBTVUsR0FBRyxDQUFDRDtRQUNsQyxPQUNLO1lBQ0RULE1BQU1VLEdBQUcsQ0FBQ0w7UUFDZDtRQUNBLE9BQU8sSUFBSVgsa0JBQWtCLElBQUksQ0FBQ0ssT0FBTyxFQUFFQyxPQUFPLElBQUksQ0FBQ0UsV0FBVyxFQUFFLElBQUksQ0FBQ0MsS0FBSztJQUNsRjtJQUNBOzs7Ozs7Ozs7S0FTQyxHQUNEUSxHQUFHTixJQUFJLEVBQUU7UUFDTCxPQUFPLElBQUksQ0FBQ0QsRUFBRSxDQUFDQztJQUNuQjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7S0FlQyxHQUNETyxPQUFPUCxJQUFJLEVBQUU7UUFD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UUFDZCxPQUFPLElBQUksQ0FBQ29ELFFBQVEsQ0FBQ3RELElBQUksQ0FBQ0MsT0FBT0M7SUFDckM7SUFDQTs7OztLQUlDLEdBQ0RxRCxLQUFLcEUsSUFBSSxFQUFFO1FBQ1AsT0FBTyxJQUFJLENBQUNtRSxRQUFRLENBQUNULFdBQVcsQ0FBQzFEO0lBQ3JDO0lBQ0E7Ozs7S0FJQyxHQUNEcUUsTUFBTXJFLElBQUksRUFBRTtRQUNSLE9BQU8sSUFBSSxDQUFDbUUsUUFBUSxDQUFDUCxZQUFZLENBQUM1RDtJQUN0QztJQUNBOzs7OztLQUtDLEdBQ0RzRSxXQUFXUCxRQUFRLEtBQUssRUFBRTtRQUN0QixJQUFJLENBQUNJLFFBQVEsQ0FBQ0wsaUJBQWlCLENBQUNDO1FBQ2hDLE9BQU8sSUFBSTtJQUNmO0FBQ0o7QUFDQTdFLG9CQUFvQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL25pcnZhYW5hYS1lY29tbWVyY2UvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvYnJvYWRjYXN0LW9wZXJhdG9yLmpzP2JhOTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlbW90ZVNvY2tldCA9IGV4cG9ydHMuQnJvYWRjYXN0T3BlcmF0b3IgPSB2b2lkIDA7XG5jb25zdCBzb2NrZXRfdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3NvY2tldC10eXBlc1wiKTtcbmNvbnN0IHNvY2tldF9pb19wYXJzZXJfMSA9IHJlcXVpcmUoXCJzb2NrZXQuaW8tcGFyc2VyXCIpO1xuY2xhc3MgQnJvYWRjYXN0T3BlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGFkYXB0ZXIsIHJvb21zID0gbmV3IFNldCgpLCBleGNlcHRSb29tcyA9IG5ldyBTZXQoKSwgZmxhZ3MgPSB7fSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXIgPSBhZGFwdGVyO1xuICAgICAgICB0aGlzLnJvb21zID0gcm9vbXM7XG4gICAgICAgIHRoaXMuZXhjZXB0Um9vbXMgPSBleGNlcHRSb29tcztcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYXJnZXRzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cyBpbiB0aGUg4oCccm9vbS0xMDHigJ0gcm9vbVxuICAgICAqIGlvLnRvKFwicm9vbS0xMDFcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYW4gYXJyYXkgb2Ygcm9vbXMgKGEgY2xpZW50IHdpbGwgYmUgbm90aWZpZWQgYXQgbW9zdCBvbmNlKVxuICAgICAqIGlvLnRvKFtcInJvb20tMTAxXCIsIFwicm9vbS0xMDJcIl0pLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIG11bHRpcGxlIGNoYWluZWQgY2FsbHNcbiAgICAgKiBpby50byhcInJvb20tMTAxXCIpLnRvKFwicm9vbS0xMDJcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICB0byhyb29tKSB7XG4gICAgICAgIGNvbnN0IHJvb21zID0gbmV3IFNldCh0aGlzLnJvb21zKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocm9vbSkpIHtcbiAgICAgICAgICAgIHJvb20uZm9yRWFjaCgocikgPT4gcm9vbXMuYWRkKHIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJvb21zLmFkZChyb29tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlciwgcm9vbXMsIHRoaXMuZXhjZXB0Um9vbXMsIHRoaXMuZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYXJnZXRzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLiBTaW1pbGFyIHRvIGB0bygpYCwgYnV0IG1pZ2h0IGZlZWwgY2xlYXJlciBpbiBzb21lIGNhc2VzOlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBkaXNjb25uZWN0IGFsbCBjbGllbnRzIGluIHRoZSBcInJvb20tMTAxXCIgcm9vbVxuICAgICAqIGlvLmluKFwicm9vbS0xMDFcIikuZGlzY29ubmVjdFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBpbihyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGNsdWRlcyBhIHJvb20gd2hlbiBlbWl0dGluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gdGhlIFwiZm9vXCIgZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzLCBleGNlcHQgdGhlIG9uZXMgdGhhdCBhcmUgaW4gdGhlIFwicm9vbS0xMDFcIiByb29tXG4gICAgICogaW8uZXhjZXB0KFwicm9vbS0xMDFcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBpby5leGNlcHQoW1wicm9vbS0xMDFcIiwgXCJyb29tLTEwMlwiXSkuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggbXVsdGlwbGUgY2hhaW5lZCBjYWxsc1xuICAgICAqIGlvLmV4Y2VwdChcInJvb20tMTAxXCIpLmV4Y2VwdChcInJvb20tMTAyXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZXhjZXB0KHJvb20pIHtcbiAgICAgICAgY29uc3QgZXhjZXB0Um9vbXMgPSBuZXcgU2V0KHRoaXMuZXhjZXB0Um9vbXMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyb29tKSkge1xuICAgICAgICAgICAgcm9vbS5mb3JFYWNoKChyKSA9PiBleGNlcHRSb29tcy5hZGQocikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXhjZXB0Um9vbXMuYWRkKHJvb20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyLCB0aGlzLnJvb21zLCBleGNlcHRSb29tcywgdGhpcy5mbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLmNvbXByZXNzKGZhbHNlKS5lbWl0KFwiaGVsbG9cIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tcHJlc3MgLSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICAgICAqIEByZXR1cm4gYSBuZXcgQnJvYWRjYXN0T3BlcmF0b3IgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb21wcmVzcyhjb21wcmVzcykge1xuICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZmxhZ3MsIHsgY29tcHJlc3MgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyLCB0aGlzLnJvb21zLCB0aGlzLmV4Y2VwdFJvb21zLCBmbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IGRhdGEgbWF5IGJlIGxvc3QgaWYgdGhlIGNsaWVudCBpcyBub3QgcmVhZHkgdG9cbiAgICAgKiByZWNlaXZlIG1lc3NhZ2VzIChiZWNhdXNlIG9mIG5ldHdvcmsgc2xvd25lc3Mgb3Igb3RoZXIgaXNzdWVzLCBvciBiZWNhdXNlIHRoZXnigJlyZSBjb25uZWN0ZWQgdGhyb3VnaCBsb25nIHBvbGxpbmdcbiAgICAgKiBhbmQgaXMgaW4gdGhlIG1pZGRsZSBvZiBhIHJlcXVlc3QtcmVzcG9uc2UgY3ljbGUpLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby52b2xhdGlsZS5lbWl0KFwiaGVsbG9cIik7IC8vIHRoZSBjbGllbnRzIG1heSBvciBtYXkgbm90IHJlY2VpdmUgaXRcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBuZXcgQnJvYWRjYXN0T3BlcmF0b3IgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXQgdm9sYXRpbGUoKSB7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5mbGFncywgeyB2b2xhdGlsZTogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCcm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIsIHRoaXMucm9vbXMsIHRoaXMuZXhjZXB0Um9vbXMsIGZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSB3aWxsIG9ubHkgYmUgYnJvYWRjYXN0IHRvIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHRoZSDigJxmb2/igJ0gZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzIG9uIHRoaXMgbm9kZVxuICAgICAqIGlvLmxvY2FsLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZ2V0IGxvY2FsKCkge1xuICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZmxhZ3MsIHsgbG9jYWw6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyLCB0aGlzLnJvb21zLCB0aGlzLmV4Y2VwdFJvb21zLCBmbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIG5leHQgb3BlcmF0aW9uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLnRpbWVvdXQoMTAwMCkuZW1pdChcInNvbWUtZXZlbnRcIiwgKGVyciwgcmVzcG9uc2VzKSA9PiB7XG4gICAgICogICBpZiAoZXJyKSB7XG4gICAgICogICAgIC8vIHNvbWUgY2xpZW50cyBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiAgIH0gZWxzZSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlcyk7IC8vIG9uZSByZXNwb25zZSBwZXIgY2xpZW50XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGltZW91dFxuICAgICAqL1xuICAgIHRpbWVvdXQodGltZW91dCkge1xuICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZmxhZ3MsIHsgdGltZW91dCB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCcm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIsIHRoaXMucm9vbXMsIHRoaXMuZXhjZXB0Um9vbXMsIGZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgdG8gYWxsIGNsaWVudHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHRoZSDigJxmb2/igJ0gZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzXG4gICAgICogaW8uZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHRoZSDigJxmb2/igJ0gZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzIGluIHRoZSDigJxyb29tLTEwMeKAnSByb29tXG4gICAgICogaW8udG8oXCJyb29tLTEwMVwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBhbiBhY2tub3dsZWRnZW1lbnQgZXhwZWN0ZWQgZnJvbSBhbGwgY29ubmVjdGVkIGNsaWVudHNcbiAgICAgKiBpby50aW1lb3V0KDEwMDApLmVtaXQoXCJzb21lLWV2ZW50XCIsIChlcnIsIHJlc3BvbnNlcykgPT4ge1xuICAgICAqICAgaWYgKGVycikge1xuICAgICAqICAgICAvLyBzb21lIGNsaWVudHMgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogICB9IGVsc2Uge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXNwb25zZXMpOyAvLyBvbmUgcmVzcG9uc2UgcGVyIGNsaWVudFxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHJldHVybiBBbHdheXMgdHJ1ZVxuICAgICAqL1xuICAgIGVtaXQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHNvY2tldF90eXBlc18xLlJFU0VSVkVEX0VWRU5UUy5oYXMoZXYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtTdHJpbmcoZXYpfVwiIGlzIGEgcmVzZXJ2ZWQgZXZlbnQgbmFtZWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCB1cCBwYWNrZXQgb2JqZWN0XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbZXYsIC4uLmFyZ3NdO1xuICAgICAgICBjb25zdCBwYWNrZXQgPSB7XG4gICAgICAgICAgICB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5FVkVOVCxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHdpdGhBY2sgPSB0eXBlb2YgZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIGlmICghd2l0aEFjaykge1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLmJyb2FkY2FzdChwYWNrZXQsIHtcbiAgICAgICAgICAgICAgICByb29tczogdGhpcy5yb29tcyxcbiAgICAgICAgICAgICAgICBleGNlcHQ6IHRoaXMuZXhjZXB0Um9vbXMsXG4gICAgICAgICAgICAgICAgZmxhZ3M6IHRoaXMuZmxhZ3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjayA9IGRhdGEucG9wKCk7XG4gICAgICAgIGxldCB0aW1lZE91dCA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVzcG9uc2VzID0gW107XG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aW1lZE91dCA9IHRydWU7XG4gICAgICAgICAgICBhY2suYXBwbHkodGhpcywgW1xuICAgICAgICAgICAgICAgIG5ldyBFcnJvcihcIm9wZXJhdGlvbiBoYXMgdGltZWQgb3V0XCIpLFxuICAgICAgICAgICAgICAgIHRoaXMuZmxhZ3MuZXhwZWN0U2luZ2xlUmVzcG9uc2UgPyBudWxsIDogcmVzcG9uc2VzLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0sIHRoaXMuZmxhZ3MudGltZW91dCk7XG4gICAgICAgIGxldCBleHBlY3RlZFNlcnZlckNvdW50ID0gLTE7XG4gICAgICAgIGxldCBhY3R1YWxTZXJ2ZXJDb3VudCA9IDA7XG4gICAgICAgIGxldCBleHBlY3RlZENsaWVudENvdW50ID0gMDtcbiAgICAgICAgY29uc3QgY2hlY2tDb21wbGV0ZW5lc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRpbWVkT3V0ICYmXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRTZXJ2ZXJDb3VudCA9PT0gYWN0dWFsU2VydmVyQ291bnQgJiZcbiAgICAgICAgICAgICAgICByZXNwb25zZXMubGVuZ3RoID09PSBleHBlY3RlZENsaWVudENvdW50KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICBhY2suYXBwbHkodGhpcywgW1xuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsYWdzLmV4cGVjdFNpbmdsZVJlc3BvbnNlID8gcmVzcG9uc2VzWzBdIDogcmVzcG9uc2VzLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkYXB0ZXIuYnJvYWRjYXN0V2l0aEFjayhwYWNrZXQsIHtcbiAgICAgICAgICAgIHJvb21zOiB0aGlzLnJvb21zLFxuICAgICAgICAgICAgZXhjZXB0OiB0aGlzLmV4Y2VwdFJvb21zLFxuICAgICAgICAgICAgZmxhZ3M6IHRoaXMuZmxhZ3MsXG4gICAgICAgIH0sIChjbGllbnRDb3VudCkgPT4ge1xuICAgICAgICAgICAgLy8gZWFjaCBTb2NrZXQuSU8gc2VydmVyIGluIHRoZSBjbHVzdGVyIHNlbmRzIHRoZSBudW1iZXIgb2YgY2xpZW50cyB0aGF0IHdlcmUgbm90aWZpZWRcbiAgICAgICAgICAgIGV4cGVjdGVkQ2xpZW50Q291bnQgKz0gY2xpZW50Q291bnQ7XG4gICAgICAgICAgICBhY3R1YWxTZXJ2ZXJDb3VudCsrO1xuICAgICAgICAgICAgY2hlY2tDb21wbGV0ZW5lc3MoKTtcbiAgICAgICAgfSwgKGNsaWVudFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAvLyBlYWNoIGNsaWVudCBzZW5kcyBhbiBhY2tub3dsZWRnZW1lbnRcbiAgICAgICAgICAgIHJlc3BvbnNlcy5wdXNoKGNsaWVudFJlc3BvbnNlKTtcbiAgICAgICAgICAgIGNoZWNrQ29tcGxldGVuZXNzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkYXB0ZXIuc2VydmVyQ291bnQoKS50aGVuKChzZXJ2ZXJDb3VudCkgPT4ge1xuICAgICAgICAgICAgZXhwZWN0ZWRTZXJ2ZXJDb3VudCA9IHNlcnZlckNvdW50O1xuICAgICAgICAgICAgY2hlY2tDb21wbGV0ZW5lc3MoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBhbmQgd2FpdHMgZm9yIGFuIGFja25vd2xlZGdlbWVudCBmcm9tIGFsbCBjbGllbnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB0cnkge1xuICAgICAqICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgaW8udGltZW91dCgxMDAwKS5lbWl0V2l0aEFjayhcInNvbWUtZXZlbnRcIik7XG4gICAgICogICBjb25zb2xlLmxvZyhyZXNwb25zZXMpOyAvLyBvbmUgcmVzcG9uc2UgcGVyIGNsaWVudFxuICAgICAqIH0gY2F0Y2ggKGUpIHtcbiAgICAgKiAgIC8vIHNvbWUgY2xpZW50cyBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gYWxsIGNsaWVudHMgaGF2ZSBhY2tub3dsZWRnZWQgdGhlIGV2ZW50XG4gICAgICovXG4gICAgZW1pdFdpdGhBY2soZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGFyZ3MucHVzaCgoZXJyLCByZXNwb25zZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyci5yZXNwb25zZXMgPSByZXNwb25zZXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3BvbnNlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2YgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIHRoaXMgbWV0aG9kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLCBwbGVhc2UgdXNlIHtAbGluayBTZXJ2ZXIjc2VydmVyU2lkZUVtaXR9IG9yXG4gICAgICoge0BsaW5rIGZldGNoU29ja2V0c30gaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhbGxTb2NrZXRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWRhcHRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYWRhcHRlciBmb3IgdGhpcyBuYW1lc3BhY2UsIGFyZSB5b3UgdHJ5aW5nIHRvIGdldCB0aGUgbGlzdCBvZiBjbGllbnRzIG9mIGEgZHluYW1pYyBuYW1lc3BhY2U/XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFkYXB0ZXIuc29ja2V0cyh0aGlzLnJvb21zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcy4gVGhpcyBtZXRob2Qgd29ya3MgYWNyb3NzIGEgY2x1c3RlciBvZiBzZXZlcmFsIFNvY2tldC5JTyBzZXJ2ZXJzLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHJldHVybiBhbGwgU29ja2V0IGluc3RhbmNlc1xuICAgICAqIGNvbnN0IHNvY2tldHMgPSBhd2FpdCBpby5mZXRjaFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIC8vIHJldHVybiBhbGwgU29ja2V0IGluc3RhbmNlcyBpbiB0aGUgXCJyb29tMVwiIHJvb21cbiAgICAgKiBjb25zdCBzb2NrZXRzID0gYXdhaXQgaW8uaW4oXCJyb29tMVwiKS5mZXRjaFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIGZvciAoY29uc3Qgc29ja2V0IG9mIHNvY2tldHMpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5pZCk7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuaGFuZHNoYWtlKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5yb29tcyk7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuZGF0YSk7XG4gICAgICpcbiAgICAgKiAgIHNvY2tldC5lbWl0KFwiaGVsbG9cIik7XG4gICAgICogICBzb2NrZXQuam9pbihcInJvb20xXCIpO1xuICAgICAqICAgc29ja2V0LmxlYXZlKFwicm9vbTJcIik7XG4gICAgICogICBzb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICBmZXRjaFNvY2tldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkYXB0ZXJcbiAgICAgICAgICAgIC5mZXRjaFNvY2tldHMoe1xuICAgICAgICAgICAgcm9vbXM6IHRoaXMucm9vbXMsXG4gICAgICAgICAgICBleGNlcHQ6IHRoaXMuZXhjZXB0Um9vbXMsXG4gICAgICAgICAgICBmbGFnczogdGhpcy5mbGFncyxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChzb2NrZXRzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc29ja2V0cy5tYXAoKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzb2NrZXQuc2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQ7IC8vIGxvY2FsIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlbW90ZVNvY2tldCh0aGlzLmFkYXB0ZXIsIHNvY2tldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBqb2luIHRoZSBzcGVjaWZpZWQgcm9vbXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIHdpdGhpbiBhIGNsdXN0ZXIgb2YgbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBBZGFwdGVyfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGpvaW4gdGhlIFwicm9vbTFcIiByb29tXG4gICAgICogaW8uc29ja2V0c0pvaW4oXCJyb29tMVwiKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tIGpvaW4gdGhlIFwicm9vbTJcIiBhbmQgXCJyb29tM1wiIHJvb21zXG4gICAgICogaW8uaW4oXCJyb29tMVwiKS5zb2NrZXRzSm9pbihbXCJyb29tMlwiLCBcInJvb20zXCJdKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqL1xuICAgIHNvY2tldHNKb2luKHJvb20pIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyLmFkZFNvY2tldHMoe1xuICAgICAgICAgICAgcm9vbXM6IHRoaXMucm9vbXMsXG4gICAgICAgICAgICBleGNlcHQ6IHRoaXMuZXhjZXB0Um9vbXMsXG4gICAgICAgICAgICBmbGFnczogdGhpcy5mbGFncyxcbiAgICAgICAgfSwgQXJyYXkuaXNBcnJheShyb29tKSA/IHJvb20gOiBbcm9vbV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBsZWF2ZSB0aGUgc3BlY2lmaWVkIHJvb21zLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgbGVhdmUgdGhlIFwicm9vbTFcIiByb29tXG4gICAgICogaW8uc29ja2V0c0xlYXZlKFwicm9vbTFcIik7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbSBsZWF2ZSB0aGUgXCJyb29tMlwiIGFuZCBcInJvb20zXCIgcm9vbXNcbiAgICAgKiBpby5pbihcInJvb20xXCIpLnNvY2tldHNMZWF2ZShbXCJyb29tMlwiLCBcInJvb20zXCJdKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqL1xuICAgIHNvY2tldHNMZWF2ZShyb29tKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlci5kZWxTb2NrZXRzKHtcbiAgICAgICAgICAgIHJvb21zOiB0aGlzLnJvb21zLFxuICAgICAgICAgICAgZXhjZXB0OiB0aGlzLmV4Y2VwdFJvb21zLFxuICAgICAgICAgICAgZmxhZ3M6IHRoaXMuZmxhZ3MsXG4gICAgICAgIH0sIEFycmF5LmlzQXJyYXkocm9vbSkgPyByb29tIDogW3Jvb21dKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgZGlzY29ubmVjdC5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGRpc2Nvbm5lY3QgKHRoZSBjb25uZWN0aW9ucyBtaWdodCBiZSBrZXB0IGFsaXZlIGZvciBvdGhlciBuYW1lc3BhY2VzKVxuICAgICAqIGlvLmRpc2Nvbm5lY3RTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbSBkaXNjb25uZWN0IGFuZCBjbG9zZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uc1xuICAgICAqIGlvLmluKFwicm9vbTFcIikuZGlzY29ubmVjdFNvY2tldHModHJ1ZSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xvc2UgLSB3aGV0aGVyIHRvIGNsb3NlIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0U29ja2V0cyhjbG9zZSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlci5kaXNjb25uZWN0U29ja2V0cyh7XG4gICAgICAgICAgICByb29tczogdGhpcy5yb29tcyxcbiAgICAgICAgICAgIGV4Y2VwdDogdGhpcy5leGNlcHRSb29tcyxcbiAgICAgICAgICAgIGZsYWdzOiB0aGlzLmZsYWdzLFxuICAgICAgICB9LCBjbG9zZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm9hZGNhc3RPcGVyYXRvciA9IEJyb2FkY2FzdE9wZXJhdG9yO1xuLyoqXG4gKiBFeHBvc2Ugb2Ygc3Vic2V0IG9mIHRoZSBhdHRyaWJ1dGVzIGFuZCBtZXRob2RzIG9mIHRoZSBTb2NrZXQgY2xhc3NcbiAqL1xuY2xhc3MgUmVtb3RlU29ja2V0IHtcbiAgICBjb25zdHJ1Y3RvcihhZGFwdGVyLCBkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuaWQgPSBkZXRhaWxzLmlkO1xuICAgICAgICB0aGlzLmhhbmRzaGFrZSA9IGRldGFpbHMuaGFuZHNoYWtlO1xuICAgICAgICB0aGlzLnJvb21zID0gbmV3IFNldChkZXRhaWxzLnJvb21zKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGV0YWlscy5kYXRhO1xuICAgICAgICB0aGlzLm9wZXJhdG9yID0gbmV3IEJyb2FkY2FzdE9wZXJhdG9yKGFkYXB0ZXIsIG5ldyBTZXQoW3RoaXMuaWRdKSwgbmV3IFNldCgpLCB7XG4gICAgICAgICAgICBleHBlY3RTaW5nbGVSZXNwb25zZTogdHJ1ZSwgLy8gc28gdGhhdCByZW1vdGVTb2NrZXQuZW1pdCgpIHdpdGggYWNrbm93bGVkZ2VtZW50IGJlaGF2ZXMgbGlrZSBzb2NrZXQuZW1pdCgpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSBuZXh0IG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3Qgc29ja2V0cyA9IGF3YWl0IGlvLmZldGNoU29ja2V0cygpO1xuICAgICAqXG4gICAgICogZm9yIChjb25zdCBzb2NrZXQgb2Ygc29ja2V0cykge1xuICAgICAqICAgaWYgKHNvbWVDb25kaXRpb24pIHtcbiAgICAgKiAgICAgc29ja2V0LnRpbWVvdXQoMTAwMCkuZW1pdChcInNvbWUtZXZlbnRcIiwgKGVycikgPT4ge1xuICAgICAqICAgICAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgICAgIC8vIHRoZSBjbGllbnQgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9KTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiAvLyBub3RlOiBpZiBwb3NzaWJsZSwgdXNpbmcgYSByb29tIGluc3RlYWQgb2YgbG9vcGluZyBvdmVyIGFsbCBzb2NrZXRzIGlzIHByZWZlcmFibGVcbiAgICAgKiBpby50aW1lb3V0KDEwMDApLnRvKHNvbWVDb25kaXRpb25Sb29tKS5lbWl0KFwic29tZS1ldmVudFwiLCAoZXJyLCByZXNwb25zZXMpID0+IHtcbiAgICAgKiAgIC8vIC4uLlxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHRpbWVvdXRcbiAgICAgKi9cbiAgICB0aW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3IudGltZW91dCh0aW1lb3V0KTtcbiAgICB9XG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvci5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSm9pbnMgYSByb29tLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHJvb20gLSByb29tIG9yIGFycmF5IG9mIHJvb21zXG4gICAgICovXG4gICAgam9pbihyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdG9yLnNvY2tldHNKb2luKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZWF2ZXMgYSByb29tLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJvb21cbiAgICAgKi9cbiAgICBsZWF2ZShyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdG9yLnNvY2tldHNMZWF2ZShyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgdGhpcyBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsb3NlIC0gaWYgYHRydWVgLCBjbG9zZXMgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoY2xvc2UgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLm9wZXJhdG9yLmRpc2Nvbm5lY3RTb2NrZXRzKGNsb3NlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5SZW1vdGVTb2NrZXQgPSBSZW1vdGVTb2NrZXQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSZW1vdGVTb2NrZXQiLCJCcm9hZGNhc3RPcGVyYXRvciIsInNvY2tldF90eXBlc18xIiwicmVxdWlyZSIsInNvY2tldF9pb19wYXJzZXJfMSIsImNvbnN0cnVjdG9yIiwiYWRhcHRlciIsInJvb21zIiwiU2V0IiwiZXhjZXB0Um9vbXMiLCJmbGFncyIsInRvIiwicm9vbSIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJyIiwiYWRkIiwiaW4iLCJleGNlcHQiLCJjb21wcmVzcyIsImFzc2lnbiIsInZvbGF0aWxlIiwibG9jYWwiLCJ0aW1lb3V0IiwiZW1pdCIsImV2IiwiYXJncyIsIlJFU0VSVkVEX0VWRU5UUyIsImhhcyIsIkVycm9yIiwiU3RyaW5nIiwiZGF0YSIsInBhY2tldCIsInR5cGUiLCJQYWNrZXRUeXBlIiwiRVZFTlQiLCJ3aXRoQWNrIiwibGVuZ3RoIiwiYnJvYWRjYXN0IiwiYWNrIiwicG9wIiwidGltZWRPdXQiLCJyZXNwb25zZXMiLCJ0aW1lciIsInNldFRpbWVvdXQiLCJhcHBseSIsImV4cGVjdFNpbmdsZVJlc3BvbnNlIiwiZXhwZWN0ZWRTZXJ2ZXJDb3VudCIsImFjdHVhbFNlcnZlckNvdW50IiwiZXhwZWN0ZWRDbGllbnRDb3VudCIsImNoZWNrQ29tcGxldGVuZXNzIiwiY2xlYXJUaW1lb3V0IiwiYnJvYWRjYXN0V2l0aEFjayIsImNsaWVudENvdW50IiwiY2xpZW50UmVzcG9uc2UiLCJwdXNoIiwic2VydmVyQ291bnQiLCJ0aGVuIiwiZW1pdFdpdGhBY2siLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImVyciIsImFsbFNvY2tldHMiLCJzb2NrZXRzIiwiZmV0Y2hTb2NrZXRzIiwibWFwIiwic29ja2V0Iiwic2VydmVyIiwic29ja2V0c0pvaW4iLCJhZGRTb2NrZXRzIiwic29ja2V0c0xlYXZlIiwiZGVsU29ja2V0cyIsImRpc2Nvbm5lY3RTb2NrZXRzIiwiY2xvc2UiLCJkZXRhaWxzIiwiaWQiLCJoYW5kc2hha2UiLCJvcGVyYXRvciIsImpvaW4iLCJsZWF2ZSIsImRpc2Nvbm5lY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/broadcast-operator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/client.js":
/*!***********************************************!*\
  !*** ./node_modules/socket.io/dist/client.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Client = void 0;\nconst socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ \"(rsc)/./node_modules/socket.io-parser/build/cjs/index.js\");\nconst debugModule = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst debug = debugModule(\"socket.io:client\");\nclass Client {\n    /**\n     * Client constructor.\n     *\n     * @param server instance\n     * @param conn\n     * @package\n     */ constructor(server, conn){\n        this.sockets = new Map();\n        this.nsps = new Map();\n        this.server = server;\n        this.conn = conn;\n        this.encoder = server.encoder;\n        this.decoder = new server._parser.Decoder();\n        this.id = conn.id;\n        this.setup();\n    }\n    /**\n     * @return the reference to the request that originated the Engine.IO connection\n     *\n     * @public\n     */ get request() {\n        return this.conn.request;\n    }\n    /**\n     * Sets up event listeners.\n     *\n     * @private\n     */ setup() {\n        this.onclose = this.onclose.bind(this);\n        this.ondata = this.ondata.bind(this);\n        this.onerror = this.onerror.bind(this);\n        this.ondecoded = this.ondecoded.bind(this);\n        // @ts-ignore\n        this.decoder.on(\"decoded\", this.ondecoded);\n        this.conn.on(\"data\", this.ondata);\n        this.conn.on(\"error\", this.onerror);\n        this.conn.on(\"close\", this.onclose);\n        this.connectTimeout = setTimeout(()=>{\n            if (this.nsps.size === 0) {\n                debug(\"no namespace joined yet, close the client\");\n                this.close();\n            } else {\n                debug(\"the client has already joined a namespace, nothing to do\");\n            }\n        }, this.server._connectTimeout);\n    }\n    /**\n     * Connects a client to a namespace.\n     *\n     * @param {String} name - the namespace\n     * @param {Object} auth - the auth parameters\n     * @private\n     */ connect(name, auth = {}) {\n        if (this.server._nsps.has(name)) {\n            debug(\"connecting to namespace %s\", name);\n            return this.doConnect(name, auth);\n        }\n        this.server._checkNamespace(name, auth, (dynamicNspName)=>{\n            if (dynamicNspName) {\n                this.doConnect(name, auth);\n            } else {\n                debug(\"creation of namespace %s was denied\", name);\n                this._packet({\n                    type: socket_io_parser_1.PacketType.CONNECT_ERROR,\n                    nsp: name,\n                    data: {\n                        message: \"Invalid namespace\"\n                    }\n                });\n            }\n        });\n    }\n    /**\n     * Connects a client to a namespace.\n     *\n     * @param name - the namespace\n     * @param {Object} auth - the auth parameters\n     *\n     * @private\n     */ doConnect(name, auth) {\n        const nsp = this.server.of(name);\n        nsp._add(this, auth, (socket)=>{\n            this.sockets.set(socket.id, socket);\n            this.nsps.set(nsp.name, socket);\n            if (this.connectTimeout) {\n                clearTimeout(this.connectTimeout);\n                this.connectTimeout = undefined;\n            }\n        });\n    }\n    /**\n     * Disconnects from all namespaces and closes transport.\n     *\n     * @private\n     */ _disconnect() {\n        for (const socket of this.sockets.values()){\n            socket.disconnect();\n        }\n        this.sockets.clear();\n        this.close();\n    }\n    /**\n     * Removes a socket. Called by each `Socket`.\n     *\n     * @private\n     */ _remove(socket) {\n        if (this.sockets.has(socket.id)) {\n            const nsp = this.sockets.get(socket.id).nsp.name;\n            this.sockets.delete(socket.id);\n            this.nsps.delete(nsp);\n        } else {\n            debug(\"ignoring remove for %s\", socket.id);\n        }\n    }\n    /**\n     * Closes the underlying connection.\n     *\n     * @private\n     */ close() {\n        if (\"open\" === this.conn.readyState) {\n            debug(\"forcing transport close\");\n            this.conn.close();\n            this.onclose(\"forced server close\");\n        }\n    }\n    /**\n     * Writes a packet to the transport.\n     *\n     * @param {Object} packet object\n     * @param {Object} opts\n     * @private\n     */ _packet(packet, opts = {}) {\n        if (this.conn.readyState !== \"open\") {\n            debug(\"ignoring packet write %j\", packet);\n            return;\n        }\n        const encodedPackets = opts.preEncoded ? packet // previous versions of the adapter incorrectly used socket.packet() instead of writeToEngine()\n         : this.encoder.encode(packet);\n        this.writeToEngine(encodedPackets, opts);\n    }\n    writeToEngine(encodedPackets, opts) {\n        if (opts.volatile && !this.conn.transport.writable) {\n            debug(\"volatile packet is discarded since the transport is not currently writable\");\n            return;\n        }\n        const packets = Array.isArray(encodedPackets) ? encodedPackets : [\n            encodedPackets\n        ];\n        for (const encodedPacket of packets){\n            this.conn.write(encodedPacket, opts);\n        }\n    }\n    /**\n     * Called with incoming transport data.\n     *\n     * @private\n     */ ondata(data) {\n        // try/catch is needed for protocol violations (GH-1880)\n        try {\n            this.decoder.add(data);\n        } catch (e) {\n            debug(\"invalid packet format\");\n            this.onerror(e);\n        }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */ ondecoded(packet) {\n        let namespace;\n        let authPayload;\n        if (this.conn.protocol === 3) {\n            const parsed = url.parse(packet.nsp, true);\n            namespace = parsed.pathname;\n            authPayload = parsed.query;\n        } else {\n            namespace = packet.nsp;\n            authPayload = packet.data;\n        }\n        const socket = this.nsps.get(namespace);\n        if (!socket && packet.type === socket_io_parser_1.PacketType.CONNECT) {\n            this.connect(namespace, authPayload);\n        } else if (socket && packet.type !== socket_io_parser_1.PacketType.CONNECT && packet.type !== socket_io_parser_1.PacketType.CONNECT_ERROR) {\n            process.nextTick(function() {\n                socket._onpacket(packet);\n            });\n        } else {\n            debug(\"invalid state (packet type: %s)\", packet.type);\n            this.close();\n        }\n    }\n    /**\n     * Handles an error.\n     *\n     * @param {Object} err object\n     * @private\n     */ onerror(err) {\n        for (const socket of this.sockets.values()){\n            socket._onerror(err);\n        }\n        this.conn.close();\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @param reason\n     * @param description\n     * @private\n     */ onclose(reason, description) {\n        debug(\"client close with reason %s\", reason);\n        // ignore a potential subsequent `close` event\n        this.destroy();\n        // `nsps` and `sockets` are cleaned up seamlessly\n        for (const socket of this.sockets.values()){\n            socket._onclose(reason, description);\n        }\n        this.sockets.clear();\n        this.decoder.destroy(); // clean up decoder\n    }\n    /**\n     * Cleans up event listeners.\n     * @private\n     */ destroy() {\n        this.conn.removeListener(\"data\", this.ondata);\n        this.conn.removeListener(\"error\", this.onerror);\n        this.conn.removeListener(\"close\", this.onclose);\n        // @ts-ignore\n        this.decoder.removeListener(\"decoded\", this.ondecoded);\n        if (this.connectTimeout) {\n            clearTimeout(this.connectTimeout);\n            this.connectTimeout = undefined;\n        }\n    }\n}\nexports.Client = Client;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixNQUFNRyxxQkFBcUJDLG1CQUFPQSxDQUFDLGtGQUFrQjtBQUNyRCxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw2RUFBTztBQUNuQyxNQUFNRSxNQUFNRixtQkFBT0EsQ0FBQyxnQkFBSztBQUN6QixNQUFNRyxRQUFRRixZQUFZO0FBQzFCLE1BQU1IO0lBQ0Y7Ozs7OztLQU1DLEdBQ0RNLFlBQVlDLE1BQU0sRUFBRUMsSUFBSSxDQUFFO1FBQ3RCLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUlDO1FBQ25CLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUlEO1FBQ2hCLElBQUksQ0FBQ0gsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0ksT0FBTyxHQUFHTCxPQUFPSyxPQUFPO1FBQzdCLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUlOLE9BQU9PLE9BQU8sQ0FBQ0MsT0FBTztRQUN6QyxJQUFJLENBQUNDLEVBQUUsR0FBR1IsS0FBS1EsRUFBRTtRQUNqQixJQUFJLENBQUNDLEtBQUs7SUFDZDtJQUNBOzs7O0tBSUMsR0FDRCxJQUFJQyxVQUFVO1FBQ1YsT0FBTyxJQUFJLENBQUNWLElBQUksQ0FBQ1UsT0FBTztJQUM1QjtJQUNBOzs7O0tBSUMsR0FDREQsUUFBUTtRQUNKLElBQUksQ0FBQ0UsT0FBTyxHQUFHLElBQUksQ0FBQ0EsT0FBTyxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUNyQyxJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU0sQ0FBQ0QsSUFBSSxDQUFDLElBQUk7UUFDbkMsSUFBSSxDQUFDRSxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLENBQUNGLElBQUksQ0FB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bkI7SUFDQTs7Ozs7O0tBTUMsR0FDRFQsUUFBUXFFLE1BQU0sRUFBRUMsV0FBVyxFQUFFO1FBQ3pCcEYsTUFBTSwrQkFBK0JtRjtRQUNyQyw4Q0FBOEM7UUFDOUMsSUFBSSxDQUFDRSxPQUFPO1FBQ1osaURBQWlEO1FBQ2pELEtBQUssTUFBTTNDLFVBQVUsSUFBSSxDQUFDdEMsT0FBTyxDQUFDMkMsTUFBTSxHQUFJO1lBQ3hDTCxPQUFPNEMsUUFBUSxDQUFDSCxRQUFRQztRQUM1QjtRQUNBLElBQUksQ0FBQ2hGLE9BQU8sQ0FBQzZDLEtBQUs7UUFDbEIsSUFBSSxDQUFDekMsT0FBTyxDQUFDNkUsT0FBTyxJQUFJLG1CQUFtQjtJQUMvQztJQUNBOzs7S0FHQyxHQUNEQSxVQUFVO1FBQ04sSUFBSSxDQUFDbEYsSUFBSSxDQUFDb0YsY0FBYyxDQUFDLFFBQVEsSUFBSSxDQUFDdkUsTUFBTTtRQUM1QyxJQUFJLENBQUNiLElBQUksQ0FBQ29GLGNBQWMsQ0FBQyxTQUFTLElBQUksQ0FBQ3RFLE9BQU87UUFDOUMsSUFBSSxDQUFDZCxJQUFJLENBQUNvRixjQUFjLENBQUMsU0FBUyxJQUFJLENBQUN6RSxPQUFPO1FBQzlDLGFBQWE7UUFDYixJQUFJLENBQUNOLE9BQU8sQ0FBQytFLGNBQWMsQ0FBQyxXQUFXLElBQUksQ0FBQ3JFLFNBQVM7UUFDckQsSUFBSSxJQUFJLENBQUNFLGNBQWMsRUFBRTtZQUNyQndCLGFBQWEsSUFBSSxDQUFDeEIsY0FBYztZQUNoQyxJQUFJLENBQUNBLGNBQWMsR0FBR3lCO1FBQzFCO0lBQ0o7QUFDSjtBQUNBcEQsY0FBYyxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL25pcnZhYW5hYS1lY29tbWVyY2UvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvY2xpZW50LmpzPzYxNzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsaWVudCA9IHZvaWQgMDtcbmNvbnN0IHNvY2tldF9pb19wYXJzZXJfMSA9IHJlcXVpcmUoXCJzb2NrZXQuaW8tcGFyc2VyXCIpO1xuY29uc3QgZGVidWdNb2R1bGUgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCB1cmwgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcInNvY2tldC5pbzpjbGllbnRcIik7XG5jbGFzcyBDbGllbnQge1xuICAgIC8qKlxuICAgICAqIENsaWVudCBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXJ2ZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gY29ublxuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2VydmVyLCBjb25uKSB7XG4gICAgICAgIHRoaXMuc29ja2V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5uc3BzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgdGhpcy5jb25uID0gY29ubjtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gc2VydmVyLmVuY29kZXI7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBzZXJ2ZXIuX3BhcnNlci5EZWNvZGVyKCk7XG4gICAgICAgIHRoaXMuaWQgPSBjb25uLmlkO1xuICAgICAgICB0aGlzLnNldHVwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gdGhlIHJlZmVyZW5jZSB0byB0aGUgcmVxdWVzdCB0aGF0IG9yaWdpbmF0ZWQgdGhlIEVuZ2luZS5JTyBjb25uZWN0aW9uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0IHJlcXVlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm4ucmVxdWVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNldHVwKCkge1xuICAgICAgICB0aGlzLm9uY2xvc2UgPSB0aGlzLm9uY2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSB0aGlzLm9uZGF0YS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbmRlY29kZWQgPSB0aGlzLm9uZGVjb2RlZC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuZGVjb2Rlci5vbihcImRlY29kZWRcIiwgdGhpcy5vbmRlY29kZWQpO1xuICAgICAgICB0aGlzLmNvbm4ub24oXCJkYXRhXCIsIHRoaXMub25kYXRhKTtcbiAgICAgICAgdGhpcy5jb25uLm9uKFwiZXJyb3JcIiwgdGhpcy5vbmVycm9yKTtcbiAgICAgICAgdGhpcy5jb25uLm9uKFwiY2xvc2VcIiwgdGhpcy5vbmNsb3NlKTtcbiAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMubnNwcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJubyBuYW1lc3BhY2Ugam9pbmVkIHlldCwgY2xvc2UgdGhlIGNsaWVudFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInRoZSBjbGllbnQgaGFzIGFscmVhZHkgam9pbmVkIGEgbmFtZXNwYWNlLCBub3RoaW5nIHRvIGRvXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLnNlcnZlci5fY29ubmVjdFRpbWVvdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0cyBhIGNsaWVudCB0byBhIG5hbWVzcGFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gdGhlIG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdXRoIC0gdGhlIGF1dGggcGFyYW1ldGVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29ubmVjdChuYW1lLCBhdXRoID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyLl9uc3BzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgZGVidWcoXCJjb25uZWN0aW5nIHRvIG5hbWVzcGFjZSAlc1wiLCBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvQ29ubmVjdChuYW1lLCBhdXRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcnZlci5fY2hlY2tOYW1lc3BhY2UobmFtZSwgYXV0aCwgKGR5bmFtaWNOc3BOYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoZHluYW1pY05zcE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ29ubmVjdChuYW1lLCBhdXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiY3JlYXRpb24gb2YgbmFtZXNwYWNlICVzIHdhcyBkZW5pZWRcIiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFja2V0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQ09OTkVDVF9FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgbnNwOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgbmFtZXNwYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0cyBhIGNsaWVudCB0byBhIG5hbWVzcGFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdXRoIC0gdGhlIGF1dGggcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkb0Nvbm5lY3QobmFtZSwgYXV0aCkge1xuICAgICAgICBjb25zdCBuc3AgPSB0aGlzLnNlcnZlci5vZihuYW1lKTtcbiAgICAgICAgbnNwLl9hZGQodGhpcywgYXV0aCwgKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXRzLnNldChzb2NrZXQuaWQsIHNvY2tldCk7XG4gICAgICAgICAgICB0aGlzLm5zcHMuc2V0KG5zcC5uYW1lLCBzb2NrZXQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIGZyb20gYWxsIG5hbWVzcGFjZXMgYW5kIGNsb3NlcyB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kaXNjb25uZWN0KCkge1xuICAgICAgICBmb3IgKGNvbnN0IHNvY2tldCBvZiB0aGlzLnNvY2tldHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb2NrZXRzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHNvY2tldC4gQ2FsbGVkIGJ5IGVhY2ggYFNvY2tldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmUoc29ja2V0KSB7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldHMuaGFzKHNvY2tldC5pZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5zcCA9IHRoaXMuc29ja2V0cy5nZXQoc29ja2V0LmlkKS5uc3AubmFtZTtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0cy5kZWxldGUoc29ja2V0LmlkKTtcbiAgICAgICAgICAgIHRoaXMubnNwcy5kZWxldGUobnNwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKFwiaWdub3JpbmcgcmVtb3ZlIGZvciAlc1wiLCBzb2NrZXQuaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKFwib3BlblwiID09PSB0aGlzLmNvbm4ucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgZGVidWcoXCJmb3JjaW5nIHRyYW5zcG9ydCBjbG9zZVwiKTtcbiAgICAgICAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5vbmNsb3NlKFwiZm9yY2VkIHNlcnZlciBjbG9zZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBwYWNrZXQgdG8gdGhlIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wYWNrZXQocGFja2V0LCBvcHRzID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubi5yZWFkeVN0YXRlICE9PSBcIm9wZW5cIikge1xuICAgICAgICAgICAgZGVidWcoXCJpZ25vcmluZyBwYWNrZXQgd3JpdGUgJWpcIiwgcGFja2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmNvZGVkUGFja2V0cyA9IG9wdHMucHJlRW5jb2RlZFxuICAgICAgICAgICAgPyBwYWNrZXQgLy8gcHJldmlvdXMgdmVyc2lvbnMgb2YgdGhlIGFkYXB0ZXIgaW5jb3JyZWN0bHkgdXNlZCBzb2NrZXQucGFja2V0KCkgaW5zdGVhZCBvZiB3cml0ZVRvRW5naW5lKClcbiAgICAgICAgICAgIDogdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQpO1xuICAgICAgICB0aGlzLndyaXRlVG9FbmdpbmUoZW5jb2RlZFBhY2tldHMsIG9wdHMpO1xuICAgIH1cbiAgICB3cml0ZVRvRW5naW5lKGVuY29kZWRQYWNrZXRzLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzLnZvbGF0aWxlICYmICF0aGlzLmNvbm4udHJhbnNwb3J0LndyaXRhYmxlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInZvbGF0aWxlIHBhY2tldCBpcyBkaXNjYXJkZWQgc2luY2UgdGhlIHRyYW5zcG9ydCBpcyBub3QgY3VycmVudGx5IHdyaXRhYmxlXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhY2tldHMgPSBBcnJheS5pc0FycmF5KGVuY29kZWRQYWNrZXRzKVxuICAgICAgICAgICAgPyBlbmNvZGVkUGFja2V0c1xuICAgICAgICAgICAgOiBbZW5jb2RlZFBhY2tldHNdO1xuICAgICAgICBmb3IgKGNvbnN0IGVuY29kZWRQYWNrZXQgb2YgcGFja2V0cykge1xuICAgICAgICAgICAgdGhpcy5jb25uLndyaXRlKGVuY29kZWRQYWNrZXQsIG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIGluY29taW5nIHRyYW5zcG9ydCBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmRhdGEoZGF0YSkge1xuICAgICAgICAvLyB0cnkvY2F0Y2ggaXMgbmVlZGVkIGZvciBwcm90b2NvbCB2aW9sYXRpb25zIChHSC0xODgwKVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVyLmFkZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZGVidWcoXCJpbnZhbGlkIHBhY2tldCBmb3JtYXRcIik7XG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gcGFyc2VyIGZ1bGx5IGRlY29kZXMgYSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZGVjb2RlZChwYWNrZXQpIHtcbiAgICAgICAgbGV0IG5hbWVzcGFjZTtcbiAgICAgICAgbGV0IGF1dGhQYXlsb2FkO1xuICAgICAgICBpZiAodGhpcy5jb25uLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSB1cmwucGFyc2UocGFja2V0Lm5zcCwgdHJ1ZSk7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICBhdXRoUGF5bG9hZCA9IHBhcnNlZC5xdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IHBhY2tldC5uc3A7XG4gICAgICAgICAgICBhdXRoUGF5bG9hZCA9IHBhY2tldC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubnNwcy5nZXQobmFtZXNwYWNlKTtcbiAgICAgICAgaWYgKCFzb2NrZXQgJiYgcGFja2V0LnR5cGUgPT09IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkNPTk5FQ1QpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdChuYW1lc3BhY2UsIGF1dGhQYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzb2NrZXQgJiZcbiAgICAgICAgICAgIHBhY2tldC50eXBlICE9PSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNUICYmXG4gICAgICAgICAgICBwYWNrZXQudHlwZSAhPT0gc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQ09OTkVDVF9FUlJPUikge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0Ll9vbnBhY2tldChwYWNrZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImludmFsaWQgc3RhdGUgKHBhY2tldCB0eXBlOiAlcylcIiwgcGFja2V0LnR5cGUpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXJyIG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25lcnJvcihlcnIpIHtcbiAgICAgICAgZm9yIChjb25zdCBzb2NrZXQgb2YgdGhpcy5zb2NrZXRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBzb2NrZXQuX29uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm4uY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlYXNvblxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25jbG9zZShyZWFzb24sIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGRlYnVnKFwiY2xpZW50IGNsb3NlIHdpdGggcmVhc29uICVzXCIsIHJlYXNvbik7XG4gICAgICAgIC8vIGlnbm9yZSBhIHBvdGVudGlhbCBzdWJzZXF1ZW50IGBjbG9zZWAgZXZlbnRcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIC8vIGBuc3BzYCBhbmQgYHNvY2tldHNgIGFyZSBjbGVhbmVkIHVwIHNlYW1sZXNzbHlcbiAgICAgICAgZm9yIChjb25zdCBzb2NrZXQgb2YgdGhpcy5zb2NrZXRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBzb2NrZXQuX29uY2xvc2UocmVhc29uLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb2NrZXRzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7IC8vIGNsZWFuIHVwIGRlY29kZXJcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY29ubi5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIiwgdGhpcy5vbmRhdGEpO1xuICAgICAgICB0aGlzLmNvbm4ucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLm9uZXJyb3IpO1xuICAgICAgICB0aGlzLmNvbm4ucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCB0aGlzLm9uY2xvc2UpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuZGVjb2Rlci5yZW1vdmVMaXN0ZW5lcihcImRlY29kZWRcIiwgdGhpcy5vbmRlY29kZWQpO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0VGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50ID0gQ2xpZW50O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2xpZW50Iiwic29ja2V0X2lvX3BhcnNlcl8xIiwicmVxdWlyZSIsImRlYnVnTW9kdWxlIiwidXJsIiwiZGVidWciLCJjb25zdHJ1Y3RvciIsInNlcnZlciIsImNvbm4iLCJzb2NrZXRzIiwiTWFwIiwibnNwcyIsImVuY29kZXIiLCJkZWNvZGVyIiwiX3BhcnNlciIsIkRlY29kZXIiLCJpZCIsInNldHVwIiwicmVxdWVzdCIsIm9uY2xvc2UiLCJiaW5kIiwib25kYXRhIiwib25lcnJvciIsIm9uZGVjb2RlZCIsIm9uIiwiY29ubmVjdFRpbWVvdXQiLCJzZXRUaW1lb3V0Iiwic2l6ZSIsImNsb3NlIiwiX2Nvbm5lY3RUaW1lb3V0IiwiY29ubmVjdCIsIm5hbWUiLCJhdXRoIiwiX25zcHMiLCJoYXMiLCJkb0Nvbm5lY3QiLCJfY2hlY2tOYW1lc3BhY2UiLCJkeW5hbWljTnNwTmFtZSIsIl9wYWNrZXQiLCJ0eXBlIiwiUGFja2V0VHlwZSIsIkNPTk5FQ1RfRVJST1IiLCJuc3AiLCJkYXRhIiwibWVzc2FnZSIsIm9mIiwiX2FkZCIsInNvY2tldCIsInNldCIsImNsZWFyVGltZW91dCIsInVuZGVmaW5lZCIsIl9kaXNjb25uZWN0IiwidmFsdWVzIiwiZGlzY29ubmVjdCIsImNsZWFyIiwiX3JlbW92ZSIsImdldCIsImRlbGV0ZSIsInJlYWR5U3RhdGUiLCJwYWNrZXQiLCJvcHRzIiwiZW5jb2RlZFBhY2tldHMiLCJwcmVFbmNvZGVkIiwiZW5jb2RlIiwid3JpdGVUb0VuZ2luZSIsInZvbGF0aWxlIiwidHJhbnNwb3J0Iiwid3JpdGFibGUiLCJwYWNrZXRzIiwiQXJyYXkiLCJpc0FycmF5IiwiZW5jb2RlZFBhY2tldCIsIndyaXRlIiwiYWRkIiwiZSIsIm5hbWVzcGFjZSIsImF1dGhQYXlsb2FkIiwicHJvdG9jb2wiLCJwYXJzZWQiLCJwYXJzZSIsInBhdGhuYW1lIiwicXVlcnkiLCJDT05ORUNUIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiX29ucGFja2V0IiwiZXJyIiwiX29uZXJyb3IiLCJyZWFzb24iLCJkZXNjcmlwdGlvbiIsImRlc3Ryb3kiLCJfb25jbG9zZSIsInJlbW92ZUxpc3RlbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/socket.io/dist/index.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Namespace = exports.Socket = exports.Server = void 0;\nconst http = __webpack_require__(/*! http */ \"http\");\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst zlib_1 = __webpack_require__(/*! zlib */ \"zlib\");\nconst accepts = __webpack_require__(/*! accepts */ \"(rsc)/./node_modules/accepts/index.js\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst engine_io_1 = __webpack_require__(/*! engine.io */ \"(rsc)/./node_modules/engine.io/build/engine.io.js\");\nconst client_1 = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/socket.io/dist/client.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst namespace_1 = __webpack_require__(/*! ./namespace */ \"(rsc)/./node_modules/socket.io/dist/namespace.js\");\nObject.defineProperty(exports, \"Namespace\", ({\n    enumerable: true,\n    get: function() {\n        return namespace_1.Namespace;\n    }\n}));\nconst parent_namespace_1 = __webpack_require__(/*! ./parent-namespace */ \"(rsc)/./node_modules/socket.io/dist/parent-namespace.js\");\nconst socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/index.js\");\nconst parser = __importStar(__webpack_require__(/*! socket.io-parser */ \"(rsc)/./node_modules/socket.io-parser/build/cjs/index.js\"));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst socket_1 = __webpack_require__(/*! ./socket */ \"(rsc)/./node_modules/socket.io/dist/socket.js\");\nObject.defineProperty(exports, \"Socket\", ({\n    enumerable: true,\n    get: function() {\n        return socket_1.Socket;\n    }\n}));\nconst typed_events_1 = __webpack_require__(/*! ./typed-events */ \"(rsc)/./node_modules/socket.io/dist/typed-events.js\");\nconst uws_1 = __webpack_require__(/*! ./uws */ \"(rsc)/./node_modules/socket.io/dist/uws.js\");\nconst cors_1 = __importDefault(__webpack_require__(/*! cors */ \"(rsc)/./node_modules/cors/lib/index.js\"));\nconst debug = (0, debug_1.default)(\"socket.io:server\");\nconst clientVersion = (__webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/socket.io/package.json\").version);\nconst dotMapRegex = /\\.map/;\n/**\n * Represents a Socket.IO server.\n *\n * @example\n * import { Server } from \"socket.io\";\n *\n * const io = new Server();\n *\n * io.on(\"connection\", (socket) => {\n *   console.log(`socket ${socket.id} connected`);\n *\n *   // send an event to the client\n *   socket.emit(\"foo\", \"bar\");\n *\n *   socket.on(\"foobar\", () => {\n *     // an event was received from the client\n *   });\n *\n *   // upon disconnection\n *   socket.on(\"disconnect\", (reason) => {\n *     console.log(`socket ${socket.id} disconnected due to ${reason}`);\n *   });\n * });\n *\n * io.listen(3000);\n */ class Server extends typed_events_1.StrictEventEmitter {\n    constructor(srv, opts = {}){\n        super();\n        /**\n         * @private\n         */ this._nsps = new Map();\n        this.parentNsps = new Map();\n        /**\n         * A subset of the {@link parentNsps} map, only containing {@link ParentNamespace} which are based on a regular\n         * expression.\n         *\n         * @private\n         */ this.parentNamespacesFromRegExp = new Map();\n        if (\"object\" === typeof srv && srv instanceof Object && !srv.listen) {\n            opts = srv;\n            srv = undefined;\n        }\n        this.path(opts.path || \"/socket.io\");\n        this.connectTimeout(opts.connectTimeout || 45000);\n        this.serveClient(false !== opts.serveClient);\n        this._parser = opts.parser || parser;\n        this.encoder = new this._parser.Encoder();\n        this.opts = opts;\n        if (opts.connectionStateRecovery) {\n            opts.connectionStateRecovery = Object.assign({\n                maxDisconnectionDuration: 2 * 60 * 1000,\n                skipMiddlewares: true\n            }, opts.connectionStateRecovery);\n            this.adapter(opts.adapter || socket_io_adapter_1.SessionAwareAdapter);\n        } else {\n            this.adapter(opts.adapter || socket_io_adapter_1.Adapter);\n        }\n        opts.cleanupEmptyChildNamespaces = !!opts.cleanupEmptyChildNamespaces;\n        this.sockets = this.of(\"/\");\n        if (srv || typeof srv == \"number\") this.attach(srv);\n        if (this.opts.cors) {\n            this._corsMiddleware = (0, cors_1.default)(this.opts.cors);\n        }\n    }\n    get _opts() {\n        return this.opts;\n    }\n    serveClient(v) {\n        if (!arguments.length) return this._serveClient;\n        this._serveClient = v;\n        return this;\n    }\n    /**\n     * Executes the middleware for an incoming namespace not already created on the server.\n     *\n     * @param name - name of incoming namespace\n     * @param auth - the auth parameters\n     * @param fn - callback\n     *\n     * @private\n     */ _checkNamespace(name, auth, fn) {\n        if (this.parentNsps.size === 0) return fn(false);\n        const keysIterator = this.parentNsps.keys();\n        const run = ()=>{\n            const nextFn = keysIterator.next();\n            if (nextFn.done) {\n                return fn(false);\n            }\n            nextFn.value(name, auth, (err, allow)=>{\n                if (err || !allow) {\n                    return run();\n                }\n                if (this._nsps.has(name)) {\n                    // the namespace was created in the meantime\n                    debug(\"dynamic namespace %s already exists\", name);\n                    return fn(this._nsps.get(name));\n                }\n                const namespace = this.parentNsps.get(nextFn.value).createChild(name);\n                debug(\"dynamic namespace %s was created\", name);\n                fn(namespace);\n            });\n        };\n        run();\n    }\n    path(v) {\n        if (!arguments.length) return this._path;\n        this._path = v.replace(/\\/$/, \"\");\n        const escapedPath = this._path.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n        this.clientPathRegex = new RegExp(\"^\" + escapedPath + \"/socket\\\\.io(\\\\.msgpack|\\\\.esm)?(\\\\.min)?\\\\.js(\\\\.map)?(?:\\\\?|$)\");\n        return this;\n    }\n    connectTimeout(v) {\n        if (v === undefined) return this._connectTimeout;\n        this._connectTimeout = v;\n        return this;\n    }\n    adapter(v) {\n        if (!arguments.length) return this._adapter;\n        this._adapter = v;\n        for (const nsp of this._nsps.values()){\n            nsp._initAdapter();\n        }\n        return this;\n    }\n    /**\n     * Attaches socket.io to a server or port.\n     *\n     * @param srv - server or port\n     * @param opts - options passed to engine.io\n     * @return self\n     */ listen(srv, opts = {}) {\n        return this.attach(srv, opts);\n    }\n    /**\n     * Attaches socket.io to a server or port.\n     *\n     * @param srv - server or port\n     * @param opts - options passed to engine.io\n     * @return self\n     */ attach(srv, opts = {}) {\n        if (\"function\" == typeof srv) {\n            const msg = \"You are trying to attach socket.io to an express \" + \"request handler function. Please pass a http.Server instance.\";\n            throw new Error(msg);\n        }\n        // handle a port as a string\n        if (Number(srv) == srv) {\n            srv = Number(srv);\n        }\n        if (\"number\" == typeof srv) {\n            debug(\"creating http server and binding to %d\", srv);\n            const port = srv;\n            srv = http.createServer((req, res)=>{\n                res.writeHead(404);\n                res.end();\n            });\n            srv.listen(port);\n        }\n        // merge the options passed to the Socket.IO server\n        Object.assign(opts, this.opts);\n        // set engine.io path to `/socket.io`\n        opts.path = opts.path || this._path;\n        this.initEngine(srv, opts);\n        return this;\n    }\n    attachApp(app /*: TemplatedApp */ , opts = {}) {\n        // merge the options passed to the Socket.IO server\n        Object.assign(opts, this.opts);\n        // set engine.io path to `/socket.io`\n        opts.path = opts.path || this._path;\n        // initialize engine\n        debug(\"creating uWebSockets.js-based engine with opts %j\", opts);\n        const engine = new engine_io_1.uServer(opts);\n        engine.attach(app, opts);\n        // bind to engine events\n        this.bind(engine);\n        if (this._serveClient) {\n            // attach static file serving\n            app.get(`${this._path}/*`, (res, req)=>{\n                if (!this.clientPathRegex.test(req.getUrl())) {\n                    req.setYield(true);\n                    return;\n                }\n                const filename = req.getUrl().replace(this._path, \"\").replace(/\\?.*$/, \"\").replace(/^\\//, \"\");\n                const isMap = dotMapRegex.test(filename);\n                const type = isMap ? \"map\" : \"source\";\n                // Per the standard, ETags must be quoted:\n                // https://tools.ietf.org/html/rfc7232#section-2.3\n                const expectedEtag = '\"' + clientVersion + '\"';\n                const weakEtag = \"W/\" + expectedEtag;\n                const etag = req.getHeader(\"if-none-match\");\n                if (etag) {\n                    if (expectedEtag === etag || weakEtag === etag) {\n                        debug(\"serve client %s 304\", type);\n                        res.writeStatus(\"304 Not Modified\");\n                        res.end();\n                        return;\n                    }\n                }\n                debug(\"serve client %s\", type);\n                res.writeHeader(\"cache-control\", \"public, max-age=0\");\n                res.writeHeader(\"content-type\", \"application/\" + (isMap ? \"json\" : \"javascript\") + \"; charset=utf-8\");\n                res.writeHeader(\"etag\", expectedEtag);\n                const filepath = path.join(__dirname, \"../client-dist/\", filename);\n                (0, uws_1.serveFile)(res, filepath);\n            });\n        }\n        (0, uws_1.patchAdapter)(app);\n    }\n    /**\n     * Initialize engine\n     *\n     * @param srv - the server to attach to\n     * @param opts - options passed to engine.io\n     * @private\n     */ initEngine(srv, opts) {\n        // initialize engine\n        debug(\"creating engine.io instance with opts %j\", opts);\n        this.eio = (0, engine_io_1.attach)(srv, opts);\n        // attach static file serving\n        if (this._serveClient) this.attachServe(srv);\n        // Export http server\n        this.httpServer = srv;\n        // bind to engine events\n        this.bind(this.eio);\n    }\n    /**\n     * Attaches the static file serving.\n     *\n     * @param srv http server\n     * @private\n     */ attachServe(srv) {\n        debug(\"attaching client serving req handler\");\n        const evs = srv.listeners(\"request\").slice(0);\n        srv.removeAllListeners(\"request\");\n        srv.on(\"request\", (req, res)=>{\n            if (this.clientPathRegex.test(req.url)) {\n                if (this._corsMiddleware) {\n                    this._corsMiddleware(req, res, ()=>{\n                        this.serve(req, res);\n                    });\n                } else {\n                    this.serve(req, res);\n                }\n            } else {\n                for(let i = 0; i < evs.length; i++){\n                    evs[i].call(srv, req, res);\n                }\n            }\n        });\n    }\n    /**\n     * Handles a request serving of client source and map\n     *\n     * @param req\n     * @param res\n     * @private\n     */ serve(req, res) {\n        const filename = req.url.replace(this._path, \"\").replace(/\\?.*$/, \"\");\n        const isMap = dotMapRegex.test(filename);\n        const type = isMap ? \"map\" : \"source\";\n        // Per the standard, ETags must be quoted:\n        // https://tools.ietf.org/html/rfc7232#section-2.3\n        const expectedEtag = '\"' + clientVersion + '\"';\n        const weakEtag = \"W/\" + expectedEtag;\n        const etag = req.headers[\"if-none-match\"];\n        if (etag) {\n            if (expectedEtag === etag || weakEtag === etag) {\n                debug(\"serve client %s 304\", type);\n                res.writeHead(304);\n                res.end();\n                return;\n            }\n        }\n        debug(\"serve client %s\", type);\n        res.setHeader(\"Cache-Control\", \"public, max-age=0\");\n        res.setHeader(\"Content-Type\", \"application/\" + (isMap ? \"json\" : \"javascript\") + \"; charset=utf-8\");\n        res.setHeader(\"ETag\", expectedEtag);\n        Server.sendFile(filename, req, res);\n    }\n    /**\n     * @param filename\n     * @param req\n     * @param res\n     * @private\n     */ static sendFile(filename, req, res) {\n        const readStream = (0, fs_1.createReadStream)(path.join(__dirname, \"../client-dist/\", filename));\n        const encoding = accepts(req).encodings([\n            \"br\",\n            \"gzip\",\n            \"deflate\"\n        ]);\n        const onError = (err)=>{\n            if (err) {\n                res.end();\n            }\n        };\n        switch(encoding){\n            case \"br\":\n                res.writeHead(200, {\n                    \"content-encoding\": \"br\"\n                });\n                (0, stream_1.pipeline)(readStream, (0, zlib_1.createBrotliCompress)(), res, onError);\n                break;\n            case \"gzip\":\n                res.writeHead(200, {\n                    \"content-encoding\": \"gzip\"\n                });\n                (0, stream_1.pipeline)(readStream, (0, zlib_1.createGzip)(), res, onError);\n                break;\n            case \"deflate\":\n                res.writeHead(200, {\n                    \"content-encoding\": \"deflate\"\n                });\n                (0, stream_1.pipeline)(readStream, (0, zlib_1.createDeflate)(), res, onError);\n                break;\n            default:\n                res.writeHead(200);\n                (0, stream_1.pipeline)(readStream, res, onError);\n        }\n    }\n    /**\n     * Binds socket.io to an engine.io instance.\n     *\n     * @param engine engine.io (or compatible) server\n     * @return self\n     */ bind(engine) {\n        // TODO apply strict types to the engine: \"connection\" event, `close()` and a method to serve static content\n        //  this would allow to provide any custom engine, like one based on Deno or Bun built-in HTTP server\n        this.engine = engine;\n        this.engine.on(\"connection\", this.onconnection.bind(this));\n        return this;\n    }\n    /**\n     * Called with each incoming transport connection.\n     *\n     * @param {engine.Socket} conn\n     * @return self\n     * @private\n     */ onconnection(conn) {\n        debug(\"incoming connection with id %s\", conn.id);\n        const client = new client_1.Client(this, conn);\n        if (conn.protocol === 3) {\n            // @ts-ignore\n            client.connect(\"/\");\n        }\n        return this;\n    }\n    /**\n     * Looks up a namespace.\n     *\n     * @example\n     * // with a simple string\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // with a regex\n     * const dynamicNsp = io.of(/^\\/dynamic-\\d+$/).on(\"connection\", (socket) => {\n     *   const namespace = socket.nsp; // newNamespace.name === \"/dynamic-101\"\n     *\n     *   // broadcast to all clients in the given sub-namespace\n     *   namespace.emit(\"hello\");\n     * });\n     *\n     * @param name - nsp name\n     * @param fn optional, nsp `connection` ev handler\n     */ of(name, fn) {\n        if (typeof name === \"function\" || name instanceof RegExp) {\n            const parentNsp = new parent_namespace_1.ParentNamespace(this);\n            debug(\"initializing parent namespace %s\", parentNsp.name);\n            if (typeof name === \"function\") {\n                this.parentNsps.set(name, parentNsp);\n            } else {\n                this.parentNsps.set((nsp, conn, next)=>next(null, name.test(nsp)), parentNsp);\n                this.parentNamespacesFromRegExp.set(name, parentNsp);\n            }\n            if (fn) {\n                // @ts-ignore\n                parentNsp.on(\"connect\", fn);\n            }\n            return parentNsp;\n        }\n        if (String(name)[0] !== \"/\") name = \"/\" + name;\n        let nsp = this._nsps.get(name);\n        if (!nsp) {\n            for (const [regex, parentNamespace] of this.parentNamespacesFromRegExp){\n                if (regex.test(name)) {\n                    debug(\"attaching namespace %s to parent namespace %s\", name, regex);\n                    return parentNamespace.createChild(name);\n                }\n            }\n            debug(\"initializing namespace %s\", name);\n            nsp = new namespace_1.Namespace(this, name);\n            this._nsps.set(name, nsp);\n            if (name !== \"/\") {\n                // @ts-ignore\n                this.sockets.emitReserved(\"new_namespace\", nsp);\n            }\n        }\n        if (fn) nsp.on(\"connect\", fn);\n        return nsp;\n    }\n    /**\n     * Closes server connection\n     *\n     * @param [fn] optional, called as `fn([err])` on error OR all conns closed\n     */ async close(fn) {\n        await Promise.allSettled([\n            ...this._nsps.values()\n        ].map(async (nsp)=>{\n            nsp.sockets.forEach((socket)=>{\n                socket._onclose(\"server shutting down\");\n            });\n            await nsp.adapter.close();\n        }));\n        this.engine.close();\n        // restore the Adapter prototype, when the Socket.IO server was attached to a uWebSockets.js server\n        (0, uws_1.restoreAdapter)();\n        if (this.httpServer) {\n            this.httpServer.close(fn);\n        } else {\n            fn && fn();\n        }\n    }\n    /**\n     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.\n     *\n     * @example\n     * io.use((socket, next) => {\n     *   // ...\n     *   next();\n     * });\n     *\n     * @param fn - the middleware function\n     */ use(fn) {\n        this.sockets.use(fn);\n        return this;\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @example\n     * // the foo event will be broadcast to all connected clients in the room-101 room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms (a client will be notified at most once)\n     * io.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ to(room) {\n        return this.sockets.to(room);\n    }\n    /**\n     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * // disconnect all clients in the \"room-101\" room\n     * io.in(\"room-101\").disconnectSockets();\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ in(room) {\n        return this.sockets.in(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @example\n     * // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     * io.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms\n     * io.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ except(room) {\n        return this.sockets.except(room);\n    }\n    /**\n     * Sends a `message` event to all clients.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * io.send(\"hello\");\n     *\n     * // this is equivalent to\n     * io.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */ send(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.sockets.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a `message` event to all clients. Alias of {@link send}.\n     *\n     * @return self\n     */ write(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.sockets.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a message to the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * io.serverSideEmit(\"hello\", \"world\");\n     *\n     * io.on(\"hello\", (arg1) => {\n     *   console.log(arg1); // prints \"world\"\n     * });\n     *\n     * // acknowledgements (without binary content) are supported too:\n     * io.serverSideEmit(\"ping\", (err, responses) => {\n     *  if (err) {\n     *     // some servers did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per server (except the current one)\n     *   }\n     * });\n     *\n     * io.on(\"ping\", (cb) => {\n     *   cb(\"pong\");\n     * });\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments, which may include an acknowledgement callback at the end\n     */ serverSideEmit(ev, ...args) {\n        return this.sockets.serverSideEmit(ev, ...args);\n    }\n    /**\n     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * try {\n     *   const responses = await io.serverSideEmitWithAck(\"ping\");\n     *   console.log(responses); // one response per server (except the current one)\n     * } catch (e) {\n     *   // some servers did not acknowledge the event in the given delay\n     * }\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments\n     *\n     * @return a Promise that will be fulfilled when all servers have acknowledged the event\n     */ serverSideEmitWithAck(ev, ...args) {\n        return this.sockets.serverSideEmitWithAck(ev, ...args);\n    }\n    /**\n     * Gets a list of socket ids.\n     *\n     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or\n     * {@link Server#fetchSockets} instead.\n     */ allSockets() {\n        return this.sockets.allSockets();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ compress(compress) {\n        return this.sockets.compress(compress);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because theyre connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.volatile.emit(\"hello\"); // the clients may or may not receive it\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ get volatile() {\n        return this.sockets.volatile;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * // the foo event will be broadcast to all connected clients on this node\n     * io.local.emit(\"foo\", \"bar\");\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ get local() {\n        return this.sockets.local;\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation.\n     *\n     * @example\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @param timeout\n     */ timeout(timeout) {\n        return this.sockets.timeout(timeout);\n    }\n    /**\n     * Returns the matching socket instances.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // return all Socket instances\n     * const sockets = await io.fetchSockets();\n     *\n     * // return all Socket instances in the \"room1\" room\n     * const sockets = await io.in(\"room1\").fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   console.log(socket.id);\n     *   console.log(socket.handshake);\n     *   console.log(socket.rooms);\n     *   console.log(socket.data);\n     *\n     *   socket.emit(\"hello\");\n     *   socket.join(\"room1\");\n     *   socket.leave(\"room2\");\n     *   socket.disconnect();\n     * }\n     */ fetchSockets() {\n        return this.sockets.fetchSockets();\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     *\n     * // make all socket instances join the \"room1\" room\n     * io.socketsJoin(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room join the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsJoin([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */ socketsJoin(room) {\n        return this.sockets.socketsJoin(room);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances leave the \"room1\" room\n     * io.socketsLeave(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room leave the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsLeave([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */ socketsLeave(room) {\n        return this.sockets.socketsLeave(room);\n    }\n    /**\n     * Makes the matching socket instances disconnect.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)\n     * io.disconnectSockets();\n     *\n     * // make all socket instances in the \"room1\" room disconnect and close the underlying connections\n     * io.in(\"room1\").disconnectSockets(true);\n     *\n     * @param close - whether to close the underlying connection\n     */ disconnectSockets(close = false) {\n        return this.sockets.disconnectSockets(close);\n    }\n}\nexports.Server = Server;\n/**\n * Expose main namespace (/).\n */ const emitterMethods = Object.keys(events_1.EventEmitter.prototype).filter(function(key) {\n    return typeof events_1.EventEmitter.prototype[key] === \"function\";\n});\nemitterMethods.forEach(function(fn) {\n    Server.prototype[fn] = function() {\n        return this.sockets[fn].apply(this.sockets, arguments);\n    };\n});\nmodule.exports = (srv, opts)=>new Server(srv, opts);\nmodule.exports.Server = Server;\nmodule.exports.Namespace = namespace_1.Namespace;\nmodule.exports.Socket = socket_1.Socket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcscUJBQXFCLElBQUssSUFBSSxJQUFJLENBQUNBLGtCQUFrQixJQUFNZixDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFYyxDQUFDO0lBQ3pGaEIsT0FBT2MsY0FBYyxDQUFDWixHQUFHLFdBQVc7UUFBRVUsWUFBWTtRQUFNSyxPQUFPRDtJQUFFO0FBQ3JFLElBQUssU0FBU2QsQ0FBQyxFQUFFYyxDQUFDO0lBQ2RkLENBQUMsQ0FBQyxVQUFVLEdBQUdjO0FBQ25CO0FBQ0EsSUFBSUUsZUFBZSxJQUFLLElBQUksSUFBSSxDQUFDQSxZQUFZLElBQUssU0FBVUMsR0FBRztJ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WUFBWWhCLElBQUksRUFBRTtRQUNkLE9BQU8sSUFBSSxDQUFDbEgsT0FBTyxDQUFDa0ksV0FBVyxDQUFDaEI7SUFDcEM7SUFDQTs7Ozs7Ozs7Ozs7OztLQWFDLEdBQ0RpQixhQUFhakIsSUFBSSxFQUFFO1FBQ2YsT0FBTyxJQUFJLENBQUNsSCxPQUFPLENBQUNtSSxZQUFZLENBQUNqQjtJQUNyQztJQUNBOzs7Ozs7Ozs7Ozs7O0tBYUMsR0FDRGtCLGtCQUFrQjVCLFFBQVEsS0FBSyxFQUFFO1FBQzdCLE9BQU8sSUFBSSxDQUFDeEcsT0FBTyxDQUFDb0ksaUJBQWlCLENBQUM1QjtJQUMxQztBQUNKO0FBQ0ExSixjQUFjLEdBQUdHO0FBQ2pCOztDQUVDLEdBQ0QsTUFBTW9MLGlCQUFpQmhOLE9BQU8wRixJQUFJLENBQUNwRCxTQUFTMkssWUFBWSxDQUFDNUwsU0FBUyxFQUFFNkwsTUFBTSxDQUFDLFNBQVVDLEdBQUc7SUFDcEYsT0FBTyxPQUFPN0ssU0FBUzJLLFlBQVksQ0FBQzVMLFNBQVMsQ0FBQzhMLElBQUksS0FBSztBQUMzRDtBQUNBSCxlQUFlekIsT0FBTyxDQUFDLFNBQVVoRyxFQUFFO0lBQy9CM0QsT0FBT1AsU0FBUyxDQUFDa0UsR0FBRyxHQUFHO1FBQ25CLE9BQU8sSUFBSSxDQUFDWixPQUFPLENBQUNZLEdBQUcsQ0FBQzZILEtBQUssQ0FBQyxJQUFJLENBQUN6SSxPQUFPLEVBQUVNO0lBQ2hEO0FBQ0o7QUFDQW9JLE9BQU81TCxPQUFPLEdBQUcsQ0FBQzhCLEtBQUtDLE9BQVMsSUFBSTVCLE9BQU8yQixLQUFLQztBQUNoRDZKLHFCQUFxQixHQUFHekw7QUFDeEJ5TCx3QkFBd0IsR0FBRzlLLFlBQVliLFNBQVM7QUFDaEQyTCxxQkFBcUIsR0FBR3pLLFNBQVNqQixNQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmlydmFhbmFhLWVjb21tZXJjZS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9pbmRleC5qcz8zNWFjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5hbWVzcGFjZSA9IGV4cG9ydHMuU29ja2V0ID0gZXhwb3J0cy5TZXJ2ZXIgPSB2b2lkIDA7XG5jb25zdCBodHRwID0gcmVxdWlyZShcImh0dHBcIik7XG5jb25zdCBmc18xID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgemxpYl8xID0gcmVxdWlyZShcInpsaWJcIik7XG5jb25zdCBhY2NlcHRzID0gcmVxdWlyZShcImFjY2VwdHNcIik7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBlbmdpbmVfaW9fMSA9IHJlcXVpcmUoXCJlbmdpbmUuaW9cIik7XG5jb25zdCBjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IG5hbWVzcGFjZV8xID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZXNwYWNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuYW1lc3BhY2VfMS5OYW1lc3BhY2U7IH0gfSk7XG5jb25zdCBwYXJlbnRfbmFtZXNwYWNlXzEgPSByZXF1aXJlKFwiLi9wYXJlbnQtbmFtZXNwYWNlXCIpO1xuY29uc3Qgc29ja2V0X2lvX2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCJzb2NrZXQuaW8tYWRhcHRlclwiKTtcbmNvbnN0IHBhcnNlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwic29ja2V0LmlvLXBhcnNlclwiKSk7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBzb2NrZXRfMSA9IHJlcXVpcmUoXCIuL3NvY2tldFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc29ja2V0XzEuU29ja2V0OyB9IH0pO1xuY29uc3QgdHlwZWRfZXZlbnRzXzEgPSByZXF1aXJlKFwiLi90eXBlZC1ldmVudHNcIik7XG5jb25zdCB1d3NfMSA9IHJlcXVpcmUoXCIuL3V3c1wiKTtcbmNvbnN0IGNvcnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY29yc1wiKSk7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwic29ja2V0LmlvOnNlcnZlclwiKTtcbmNvbnN0IGNsaWVudFZlcnNpb24gPSByZXF1aXJlKFwiLi4vcGFja2FnZS5qc29uXCIpLnZlcnNpb247XG5jb25zdCBkb3RNYXBSZWdleCA9IC9cXC5tYXAvO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgU29ja2V0LklPIHNlcnZlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgU2VydmVyIH0gZnJvbSBcInNvY2tldC5pb1wiO1xuICpcbiAqIGNvbnN0IGlvID0gbmV3IFNlcnZlcigpO1xuICpcbiAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKGBzb2NrZXQgJHtzb2NrZXQuaWR9IGNvbm5lY3RlZGApO1xuICpcbiAqICAgLy8gc2VuZCBhbiBldmVudCB0byB0aGUgY2xpZW50XG4gKiAgIHNvY2tldC5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICpcbiAqICAgc29ja2V0Lm9uKFwiZm9vYmFyXCIsICgpID0+IHtcbiAqICAgICAvLyBhbiBldmVudCB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgY2xpZW50XG4gKiAgIH0pO1xuICpcbiAqICAgLy8gdXBvbiBkaXNjb25uZWN0aW9uXG4gKiAgIHNvY2tldC5vbihcImRpc2Nvbm5lY3RcIiwgKHJlYXNvbikgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGBzb2NrZXQgJHtzb2NrZXQuaWR9IGRpc2Nvbm5lY3RlZCBkdWUgdG8gJHtyZWFzb259YCk7XG4gKiAgIH0pO1xuICogfSk7XG4gKlxuICogaW8ubGlzdGVuKDMwMDApO1xuICovXG5jbGFzcyBTZXJ2ZXIgZXh0ZW5kcyB0eXBlZF9ldmVudHNfMS5TdHJpY3RFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHNydiwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbnNwcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wYXJlbnROc3BzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdWJzZXQgb2YgdGhlIHtAbGluayBwYXJlbnROc3BzfSBtYXAsIG9ubHkgY29udGFpbmluZyB7QGxpbmsgUGFyZW50TmFtZXNwYWNlfSB3aGljaCBhcmUgYmFzZWQgb24gYSByZWd1bGFyXG4gICAgICAgICAqIGV4cHJlc3Npb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcmVudE5hbWVzcGFjZXNGcm9tUmVnRXhwID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHNydiAmJlxuICAgICAgICAgICAgc3J2IGluc3RhbmNlb2YgT2JqZWN0ICYmXG4gICAgICAgICAgICAhc3J2Lmxpc3Rlbikge1xuICAgICAgICAgICAgb3B0cyA9IHNydjtcbiAgICAgICAgICAgIHNydiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdGgob3B0cy5wYXRoIHx8IFwiL3NvY2tldC5pb1wiKTtcbiAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dChvcHRzLmNvbm5lY3RUaW1lb3V0IHx8IDQ1MDAwKTtcbiAgICAgICAgdGhpcy5zZXJ2ZUNsaWVudChmYWxzZSAhPT0gb3B0cy5zZXJ2ZUNsaWVudCk7XG4gICAgICAgIHRoaXMuX3BhcnNlciA9IG9wdHMucGFyc2VyIHx8IHBhcnNlcjtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gbmV3IHRoaXMuX3BhcnNlci5FbmNvZGVyKCk7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIGlmIChvcHRzLmNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5KSB7XG4gICAgICAgICAgICBvcHRzLmNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgbWF4RGlzY29ubmVjdGlvbkR1cmF0aW9uOiAyICogNjAgKiAxMDAwLFxuICAgICAgICAgICAgICAgIHNraXBNaWRkbGV3YXJlczogdHJ1ZSxcbiAgICAgICAgICAgIH0sIG9wdHMuY29ubmVjdGlvblN0YXRlUmVjb3ZlcnkpO1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyKG9wdHMuYWRhcHRlciB8fCBzb2NrZXRfaW9fYWRhcHRlcl8xLlNlc3Npb25Bd2FyZUFkYXB0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyKG9wdHMuYWRhcHRlciB8fCBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMuY2xlYW51cEVtcHR5Q2hpbGROYW1lc3BhY2VzID0gISFvcHRzLmNsZWFudXBFbXB0eUNoaWxkTmFtZXNwYWNlcztcbiAgICAgICAgdGhpcy5zb2NrZXRzID0gdGhpcy5vZihcIi9cIik7XG4gICAgICAgIGlmIChzcnYgfHwgdHlwZW9mIHNydiA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhpcy5hdHRhY2goc3J2KTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5jb3JzKSB7XG4gICAgICAgICAgICB0aGlzLl9jb3JzTWlkZGxld2FyZSA9ICgwLCBjb3JzXzEuZGVmYXVsdCkodGhpcy5vcHRzLmNvcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBfb3B0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0cztcbiAgICB9XG4gICAgc2VydmVDbGllbnQodikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VydmVDbGllbnQ7XG4gICAgICAgIHRoaXMuX3NlcnZlQ2xpZW50ID0gdjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBtaWRkbGV3YXJlIGZvciBhbiBpbmNvbWluZyBuYW1lc3BhY2Ugbm90IGFscmVhZHkgY3JlYXRlZCBvbiB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgLSBuYW1lIG9mIGluY29taW5nIG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSBhdXRoIC0gdGhlIGF1dGggcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBmbiAtIGNhbGxiYWNrXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGVja05hbWVzcGFjZShuYW1lLCBhdXRoLCBmbikge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnROc3BzLnNpemUgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZm4oZmFsc2UpO1xuICAgICAgICBjb25zdCBrZXlzSXRlcmF0b3IgPSB0aGlzLnBhcmVudE5zcHMua2V5cygpO1xuICAgICAgICBjb25zdCBydW4gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXh0Rm4gPSBrZXlzSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKG5leHRGbi5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRGbi52YWx1ZShuYW1lLCBhdXRoLCAoZXJyLCBhbGxvdykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgfHwgIWFsbG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX25zcHMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuYW1lc3BhY2Ugd2FzIGNyZWF0ZWQgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiZHluYW1pYyBuYW1lc3BhY2UgJXMgYWxyZWFkeSBleGlzdHNcIiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbih0aGlzLl9uc3BzLmdldChuYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IHRoaXMucGFyZW50TnNwcy5nZXQobmV4dEZuLnZhbHVlKS5jcmVhdGVDaGlsZChuYW1lKTtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImR5bmFtaWMgbmFtZXNwYWNlICVzIHdhcyBjcmVhdGVkXCIsIG5hbWUpO1xuICAgICAgICAgICAgICAgIGZuKG5hbWVzcGFjZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcnVuKCk7XG4gICAgfVxuICAgIHBhdGgodikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGF0aDtcbiAgICAgICAgdGhpcy5fcGF0aCA9IHYucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICAgICAgICBjb25zdCBlc2NhcGVkUGF0aCA9IHRoaXMuX3BhdGgucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCBcIlxcXFwkJlwiKTtcbiAgICAgICAgdGhpcy5jbGllbnRQYXRoUmVnZXggPSBuZXcgUmVnRXhwKFwiXlwiICtcbiAgICAgICAgICAgIGVzY2FwZWRQYXRoICtcbiAgICAgICAgICAgIFwiL3NvY2tldFxcXFwuaW8oXFxcXC5tc2dwYWNrfFxcXFwuZXNtKT8oXFxcXC5taW4pP1xcXFwuanMoXFxcXC5tYXApPyg/OlxcXFw/fCQpXCIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29ubmVjdFRpbWVvdXQodikge1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RUaW1lb3V0O1xuICAgICAgICB0aGlzLl9jb25uZWN0VGltZW91dCA9IHY7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGFwdGVyKHYpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkYXB0ZXI7XG4gICAgICAgIHRoaXMuX2FkYXB0ZXIgPSB2O1xuICAgICAgICBmb3IgKGNvbnN0IG5zcCBvZiB0aGlzLl9uc3BzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBuc3AuX2luaXRBZGFwdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHNvY2tldC5pbyB0byBhIHNlcnZlciBvciBwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNydiAtIHNlcnZlciBvciBwb3J0XG4gICAgICogQHBhcmFtIG9wdHMgLSBvcHRpb25zIHBhc3NlZCB0byBlbmdpbmUuaW9cbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBsaXN0ZW4oc3J2LCBvcHRzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoKHNydiwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHNvY2tldC5pbyB0byBhIHNlcnZlciBvciBwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNydiAtIHNlcnZlciBvciBwb3J0XG4gICAgICogQHBhcmFtIG9wdHMgLSBvcHRpb25zIHBhc3NlZCB0byBlbmdpbmUuaW9cbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBhdHRhY2goc3J2LCBvcHRzID0ge30pIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygc3J2KSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBcIllvdSBhcmUgdHJ5aW5nIHRvIGF0dGFjaCBzb2NrZXQuaW8gdG8gYW4gZXhwcmVzcyBcIiArXG4gICAgICAgICAgICAgICAgXCJyZXF1ZXN0IGhhbmRsZXIgZnVuY3Rpb24uIFBsZWFzZSBwYXNzIGEgaHR0cC5TZXJ2ZXIgaW5zdGFuY2UuXCI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgYSBwb3J0IGFzIGEgc3RyaW5nXG4gICAgICAgIGlmIChOdW1iZXIoc3J2KSA9PSBzcnYpIHtcbiAgICAgICAgICAgIHNydiA9IE51bWJlcihzcnYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiBzcnYpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiY3JlYXRpbmcgaHR0cCBzZXJ2ZXIgYW5kIGJpbmRpbmcgdG8gJWRcIiwgc3J2KTtcbiAgICAgICAgICAgIGNvbnN0IHBvcnQgPSBzcnY7XG4gICAgICAgICAgICBzcnYgPSBodHRwLmNyZWF0ZVNlcnZlcigocmVxLCByZXMpID0+IHtcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkKDQwNCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzcnYubGlzdGVuKHBvcnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIHRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgU29ja2V0LklPIHNlcnZlclxuICAgICAgICBPYmplY3QuYXNzaWduKG9wdHMsIHRoaXMub3B0cyk7XG4gICAgICAgIC8vIHNldCBlbmdpbmUuaW8gcGF0aCB0byBgL3NvY2tldC5pb2BcbiAgICAgICAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8IHRoaXMuX3BhdGg7XG4gICAgICAgIHRoaXMuaW5pdEVuZ2luZShzcnYsIG9wdHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXR0YWNoQXBwKGFwcCAvKjogVGVtcGxhdGVkQXBwICovLCBvcHRzID0ge30pIHtcbiAgICAgICAgLy8gbWVyZ2UgdGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBTb2NrZXQuSU8gc2VydmVyXG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3B0cywgdGhpcy5vcHRzKTtcbiAgICAgICAgLy8gc2V0IGVuZ2luZS5pbyBwYXRoIHRvIGAvc29ja2V0LmlvYFxuICAgICAgICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgdGhpcy5fcGF0aDtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBlbmdpbmVcbiAgICAgICAgZGVidWcoXCJjcmVhdGluZyB1V2ViU29ja2V0cy5qcy1iYXNlZCBlbmdpbmUgd2l0aCBvcHRzICVqXCIsIG9wdHMpO1xuICAgICAgICBjb25zdCBlbmdpbmUgPSBuZXcgZW5naW5lX2lvXzEudVNlcnZlcihvcHRzKTtcbiAgICAgICAgZW5naW5lLmF0dGFjaChhcHAsIG9wdHMpO1xuICAgICAgICAvLyBiaW5kIHRvIGVuZ2luZSBldmVudHNcbiAgICAgICAgdGhpcy5iaW5kKGVuZ2luZSk7XG4gICAgICAgIGlmICh0aGlzLl9zZXJ2ZUNsaWVudCkge1xuICAgICAgICAgICAgLy8gYXR0YWNoIHN0YXRpYyBmaWxlIHNlcnZpbmdcbiAgICAgICAgICAgIGFwcC5nZXQoYCR7dGhpcy5fcGF0aH0vKmAsIChyZXMsIHJlcSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jbGllbnRQYXRoUmVnZXgudGVzdChyZXEuZ2V0VXJsKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5zZXRZaWVsZCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHJlcVxuICAgICAgICAgICAgICAgICAgICAuZ2V0VXJsKClcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UodGhpcy5fcGF0aCwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eXFwvLywgXCJcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNNYXAgPSBkb3RNYXBSZWdleC50ZXN0KGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gaXNNYXAgPyBcIm1hcFwiIDogXCJzb3VyY2VcIjtcbiAgICAgICAgICAgICAgICAvLyBQZXIgdGhlIHN0YW5kYXJkLCBFVGFncyBtdXN0IGJlIHF1b3RlZDpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMiNzZWN0aW9uLTIuM1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkRXRhZyA9ICdcIicgKyBjbGllbnRWZXJzaW9uICsgJ1wiJztcbiAgICAgICAgICAgICAgICBjb25zdCB3ZWFrRXRhZyA9IFwiVy9cIiArIGV4cGVjdGVkRXRhZztcbiAgICAgICAgICAgICAgICBjb25zdCBldGFnID0gcmVxLmdldEhlYWRlcihcImlmLW5vbmUtbWF0Y2hcIik7XG4gICAgICAgICAgICAgICAgaWYgKGV0YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkRXRhZyA9PT0gZXRhZyB8fCB3ZWFrRXRhZyA9PT0gZXRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJzZXJ2ZSBjbGllbnQgJXMgMzA0XCIsIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLndyaXRlU3RhdHVzKFwiMzA0IE5vdCBNb2RpZmllZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInNlcnZlIGNsaWVudCAlc1wiLCB0eXBlKTtcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkZXIoXCJjYWNoZS1jb250cm9sXCIsIFwicHVibGljLCBtYXgtYWdlPTBcIik7XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZGVyKFwiY29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24vXCIgKyAoaXNNYXAgPyBcImpzb25cIiA6IFwiamF2YXNjcmlwdFwiKSArIFwiOyBjaGFyc2V0PXV0Zi04XCIpO1xuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWRlcihcImV0YWdcIiwgZXhwZWN0ZWRFdGFnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlcGF0aCA9IHBhdGguam9pbihfX2Rpcm5hbWUsIFwiLi4vY2xpZW50LWRpc3QvXCIsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAoMCwgdXdzXzEuc2VydmVGaWxlKShyZXMsIGZpbGVwYXRoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgICgwLCB1d3NfMS5wYXRjaEFkYXB0ZXIpKGFwcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZW5naW5lXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3J2IC0gdGhlIHNlcnZlciB0byBhdHRhY2ggdG9cbiAgICAgKiBAcGFyYW0gb3B0cyAtIG9wdGlvbnMgcGFzc2VkIHRvIGVuZ2luZS5pb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW5pdEVuZ2luZShzcnYsIG9wdHMpIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBlbmdpbmVcbiAgICAgICAgZGVidWcoXCJjcmVhdGluZyBlbmdpbmUuaW8gaW5zdGFuY2Ugd2l0aCBvcHRzICVqXCIsIG9wdHMpO1xuICAgICAgICB0aGlzLmVpbyA9ICgwLCBlbmdpbmVfaW9fMS5hdHRhY2gpKHNydiwgb3B0cyk7XG4gICAgICAgIC8vIGF0dGFjaCBzdGF0aWMgZmlsZSBzZXJ2aW5nXG4gICAgICAgIGlmICh0aGlzLl9zZXJ2ZUNsaWVudClcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoU2VydmUoc3J2KTtcbiAgICAgICAgLy8gRXhwb3J0IGh0dHAgc2VydmVyXG4gICAgICAgIHRoaXMuaHR0cFNlcnZlciA9IHNydjtcbiAgICAgICAgLy8gYmluZCB0byBlbmdpbmUgZXZlbnRzXG4gICAgICAgIHRoaXMuYmluZCh0aGlzLmVpbyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHRoZSBzdGF0aWMgZmlsZSBzZXJ2aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNydiBodHRwIHNlcnZlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXR0YWNoU2VydmUoc3J2KSB7XG4gICAgICAgIGRlYnVnKFwiYXR0YWNoaW5nIGNsaWVudCBzZXJ2aW5nIHJlcSBoYW5kbGVyXCIpO1xuICAgICAgICBjb25zdCBldnMgPSBzcnYubGlzdGVuZXJzKFwicmVxdWVzdFwiKS5zbGljZSgwKTtcbiAgICAgICAgc3J2LnJlbW92ZUFsbExpc3RlbmVycyhcInJlcXVlc3RcIik7XG4gICAgICAgIHNydi5vbihcInJlcXVlc3RcIiwgKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGllbnRQYXRoUmVnZXgudGVzdChyZXEudXJsKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb3JzTWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb3JzTWlkZGxld2FyZShyZXEsIHJlcywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZShyZXEsIHJlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZShyZXEsIHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZXZzW2ldLmNhbGwoc3J2LCByZXEsIHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhIHJlcXVlc3Qgc2VydmluZyBvZiBjbGllbnQgc291cmNlIGFuZCBtYXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXFcbiAgICAgKiBAcGFyYW0gcmVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZXJ2ZShyZXEsIHJlcykge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHJlcS51cmwucmVwbGFjZSh0aGlzLl9wYXRoLCBcIlwiKS5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKTtcbiAgICAgICAgY29uc3QgaXNNYXAgPSBkb3RNYXBSZWdleC50ZXN0KGZpbGVuYW1lKTtcbiAgICAgICAgY29uc3QgdHlwZSA9IGlzTWFwID8gXCJtYXBcIiA6IFwic291cmNlXCI7XG4gICAgICAgIC8vIFBlciB0aGUgc3RhbmRhcmQsIEVUYWdzIG11c3QgYmUgcXVvdGVkOlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMiNzZWN0aW9uLTIuM1xuICAgICAgICBjb25zdCBleHBlY3RlZEV0YWcgPSAnXCInICsgY2xpZW50VmVyc2lvbiArICdcIic7XG4gICAgICAgIGNvbnN0IHdlYWtFdGFnID0gXCJXL1wiICsgZXhwZWN0ZWRFdGFnO1xuICAgICAgICBjb25zdCBldGFnID0gcmVxLmhlYWRlcnNbXCJpZi1ub25lLW1hdGNoXCJdO1xuICAgICAgICBpZiAoZXRhZykge1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkRXRhZyA9PT0gZXRhZyB8fCB3ZWFrRXRhZyA9PT0gZXRhZykge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwic2VydmUgY2xpZW50ICVzIDMwNFwiLCB0eXBlKTtcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkKDMwNCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcInNlcnZlIGNsaWVudCAlc1wiLCB0eXBlKTtcbiAgICAgICAgcmVzLnNldEhlYWRlcihcIkNhY2hlLUNvbnRyb2xcIiwgXCJwdWJsaWMsIG1heC1hZ2U9MFwiKTtcbiAgICAgICAgcmVzLnNldEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL1wiICsgKGlzTWFwID8gXCJqc29uXCIgOiBcImphdmFzY3JpcHRcIikgKyBcIjsgY2hhcnNldD11dGYtOFwiKTtcbiAgICAgICAgcmVzLnNldEhlYWRlcihcIkVUYWdcIiwgZXhwZWN0ZWRFdGFnKTtcbiAgICAgICAgU2VydmVyLnNlbmRGaWxlKGZpbGVuYW1lLCByZXEsIHJlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmaWxlbmFtZVxuICAgICAqIEBwYXJhbSByZXFcbiAgICAgKiBAcGFyYW0gcmVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgc2VuZEZpbGUoZmlsZW5hbWUsIHJlcSwgcmVzKSB7XG4gICAgICAgIGNvbnN0IHJlYWRTdHJlYW0gPSAoMCwgZnNfMS5jcmVhdGVSZWFkU3RyZWFtKShwYXRoLmpvaW4oX19kaXJuYW1lLCBcIi4uL2NsaWVudC1kaXN0L1wiLCBmaWxlbmFtZSkpO1xuICAgICAgICBjb25zdCBlbmNvZGluZyA9IGFjY2VwdHMocmVxKS5lbmNvZGluZ3MoW1wiYnJcIiwgXCJnemlwXCIsIFwiZGVmbGF0ZVwiXSk7XG4gICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICAgICAgICBjYXNlIFwiYnJcIjpcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkKDIwMCwgeyBcImNvbnRlbnQtZW5jb2RpbmdcIjogXCJiclwiIH0pO1xuICAgICAgICAgICAgICAgICgwLCBzdHJlYW1fMS5waXBlbGluZSkocmVhZFN0cmVhbSwgKDAsIHpsaWJfMS5jcmVhdGVCcm90bGlDb21wcmVzcykoKSwgcmVzLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJnemlwXCI6XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZCgyMDAsIHsgXCJjb250ZW50LWVuY29kaW5nXCI6IFwiZ3ppcFwiIH0pO1xuICAgICAgICAgICAgICAgICgwLCBzdHJlYW1fMS5waXBlbGluZSkocmVhZFN0cmVhbSwgKDAsIHpsaWJfMS5jcmVhdGVHemlwKSgpLCByZXMsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRlZmxhdGVcIjpcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkKDIwMCwgeyBcImNvbnRlbnQtZW5jb2RpbmdcIjogXCJkZWZsYXRlXCIgfSk7XG4gICAgICAgICAgICAgICAgKDAsIHN0cmVhbV8xLnBpcGVsaW5lKShyZWFkU3RyZWFtLCAoMCwgemxpYl8xLmNyZWF0ZURlZmxhdGUpKCksIHJlcywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoMjAwKTtcbiAgICAgICAgICAgICAgICAoMCwgc3RyZWFtXzEucGlwZWxpbmUpKHJlYWRTdHJlYW0sIHJlcywgb25FcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZHMgc29ja2V0LmlvIHRvIGFuIGVuZ2luZS5pbyBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbmdpbmUgZW5naW5lLmlvIChvciBjb21wYXRpYmxlKSBzZXJ2ZXJcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBiaW5kKGVuZ2luZSkge1xuICAgICAgICAvLyBUT0RPIGFwcGx5IHN0cmljdCB0eXBlcyB0byB0aGUgZW5naW5lOiBcImNvbm5lY3Rpb25cIiBldmVudCwgYGNsb3NlKClgIGFuZCBhIG1ldGhvZCB0byBzZXJ2ZSBzdGF0aWMgY29udGVudFxuICAgICAgICAvLyAgdGhpcyB3b3VsZCBhbGxvdyB0byBwcm92aWRlIGFueSBjdXN0b20gZW5naW5lLCBsaWtlIG9uZSBiYXNlZCBvbiBEZW5vIG9yIEJ1biBidWlsdC1pbiBIVFRQIHNlcnZlclxuICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgdGhpcy5lbmdpbmUub24oXCJjb25uZWN0aW9uXCIsIHRoaXMub25jb25uZWN0aW9uLmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggZWFjaCBpbmNvbWluZyB0cmFuc3BvcnQgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZW5naW5lLlNvY2tldH0gY29ublxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25jb25uZWN0aW9uKGNvbm4pIHtcbiAgICAgICAgZGVidWcoXCJpbmNvbWluZyBjb25uZWN0aW9uIHdpdGggaWQgJXNcIiwgY29ubi5pZCk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBjbGllbnRfMS5DbGllbnQodGhpcywgY29ubik7XG4gICAgICAgIGlmIChjb25uLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjbGllbnQuY29ubmVjdChcIi9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2tzIHVwIGEgbmFtZXNwYWNlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB3aXRoIGEgc2ltcGxlIHN0cmluZ1xuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBhIHJlZ2V4XG4gICAgICogY29uc3QgZHluYW1pY05zcCA9IGlvLm9mKC9eXFwvZHluYW1pYy1cXGQrJC8pLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBjb25zdCBuYW1lc3BhY2UgPSBzb2NrZXQubnNwOyAvLyBuZXdOYW1lc3BhY2UubmFtZSA9PT0gXCIvZHluYW1pYy0xMDFcIlxuICAgICAqXG4gICAgICogICAvLyBicm9hZGNhc3QgdG8gYWxsIGNsaWVudHMgaW4gdGhlIGdpdmVuIHN1Yi1uYW1lc3BhY2VcbiAgICAgKiAgIG5hbWVzcGFjZS5lbWl0KFwiaGVsbG9cIik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAtIG5zcCBuYW1lXG4gICAgICogQHBhcmFtIGZuIG9wdGlvbmFsLCBuc3AgYGNvbm5lY3Rpb25gIGV2IGhhbmRsZXJcbiAgICAgKi9cbiAgICBvZihuYW1lLCBmbikge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiB8fCBuYW1lIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnROc3AgPSBuZXcgcGFyZW50X25hbWVzcGFjZV8xLlBhcmVudE5hbWVzcGFjZSh0aGlzKTtcbiAgICAgICAgICAgIGRlYnVnKFwiaW5pdGlhbGl6aW5nIHBhcmVudCBuYW1lc3BhY2UgJXNcIiwgcGFyZW50TnNwLm5hbWUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5zcHMuc2V0KG5hbWUsIHBhcmVudE5zcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5zcHMuc2V0KChuc3AsIGNvbm4sIG5leHQpID0+IG5leHQobnVsbCwgbmFtZS50ZXN0KG5zcCkpLCBwYXJlbnROc3ApO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50TmFtZXNwYWNlc0Zyb21SZWdFeHAuc2V0KG5hbWUsIHBhcmVudE5zcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgcGFyZW50TnNwLm9uKFwiY29ubmVjdFwiLCBmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50TnNwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChTdHJpbmcobmFtZSlbMF0gIT09IFwiL1wiKVxuICAgICAgICAgICAgbmFtZSA9IFwiL1wiICsgbmFtZTtcbiAgICAgICAgbGV0IG5zcCA9IHRoaXMuX25zcHMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIW5zcCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbcmVnZXgsIHBhcmVudE5hbWVzcGFjZV0gb2YgdGhpcy5wYXJlbnROYW1lc3BhY2VzRnJvbVJlZ0V4cCkge1xuICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiYXR0YWNoaW5nIG5hbWVzcGFjZSAlcyB0byBwYXJlbnQgbmFtZXNwYWNlICVzXCIsIG5hbWUsIHJlZ2V4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudE5hbWVzcGFjZS5jcmVhdGVDaGlsZChuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJ1ZyhcImluaXRpYWxpemluZyBuYW1lc3BhY2UgJXNcIiwgbmFtZSk7XG4gICAgICAgICAgICBuc3AgPSBuZXcgbmFtZXNwYWNlXzEuTmFtZXNwYWNlKHRoaXMsIG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5fbnNwcy5zZXQobmFtZSwgbnNwKTtcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldHMuZW1pdFJlc2VydmVkKFwibmV3X25hbWVzcGFjZVwiLCBuc3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmbilcbiAgICAgICAgICAgIG5zcC5vbihcImNvbm5lY3RcIiwgZm4pO1xuICAgICAgICByZXR1cm4gbnNwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgc2VydmVyIGNvbm5lY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBbZm5dIG9wdGlvbmFsLCBjYWxsZWQgYXMgYGZuKFtlcnJdKWAgb24gZXJyb3IgT1IgYWxsIGNvbm5zIGNsb3NlZFxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlKGZuKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChbLi4udGhpcy5fbnNwcy52YWx1ZXMoKV0ubWFwKGFzeW5jIChuc3ApID0+IHtcbiAgICAgICAgICAgIG5zcC5zb2NrZXRzLmZvckVhY2goKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgIHNvY2tldC5fb25jbG9zZShcInNlcnZlciBzaHV0dGluZyBkb3duXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBuc3AuYWRhcHRlci5jbG9zZSgpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuZW5naW5lLmNsb3NlKCk7XG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIEFkYXB0ZXIgcHJvdG90eXBlLCB3aGVuIHRoZSBTb2NrZXQuSU8gc2VydmVyIHdhcyBhdHRhY2hlZCB0byBhIHVXZWJTb2NrZXRzLmpzIHNlcnZlclxuICAgICAgICAoMCwgdXdzXzEucmVzdG9yZUFkYXB0ZXIpKCk7XG4gICAgICAgIGlmICh0aGlzLmh0dHBTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaHR0cFNlcnZlci5jbG9zZShmbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmbiAmJiBmbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIG1pZGRsZXdhcmUsIHdoaWNoIGlzIGEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIGZvciBldmVyeSBpbmNvbWluZyB7QGxpbmsgU29ja2V0fS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8udXNlKChzb2NrZXQsIG5leHQpID0+IHtcbiAgICAgKiAgIC8vIC4uLlxuICAgICAqICAgbmV4dCgpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGZuIC0gdGhlIG1pZGRsZXdhcmUgZnVuY3Rpb25cbiAgICAgKi9cbiAgICB1c2UoZm4pIHtcbiAgICAgICAgdGhpcy5zb2NrZXRzLnVzZShmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYXJnZXRzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cyBpbiB0aGUg4oCccm9vbS0xMDHigJ0gcm9vbVxuICAgICAqIGlvLnRvKFwicm9vbS0xMDFcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYW4gYXJyYXkgb2Ygcm9vbXMgKGEgY2xpZW50IHdpbGwgYmUgbm90aWZpZWQgYXQgbW9zdCBvbmNlKVxuICAgICAqIGlvLnRvKFtcInJvb20tMTAxXCIsIFwicm9vbS0xMDJcIl0pLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIG11bHRpcGxlIGNoYWluZWQgY2FsbHNcbiAgICAgKiBpby50byhcInJvb20tMTAxXCIpLnRvKFwicm9vbS0xMDJcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICB0byhyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMudG8ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gZW1pdHRpbmcuIFNpbWlsYXIgdG8gYHRvKClgLCBidXQgbWlnaHQgZmVlbCBjbGVhcmVyIGluIHNvbWUgY2FzZXM6XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGRpc2Nvbm5lY3QgYWxsIGNsaWVudHMgaW4gdGhlIFwicm9vbS0xMDFcIiByb29tXG4gICAgICogaW8uaW4oXCJyb29tLTEwMVwiKS5kaXNjb25uZWN0U29ja2V0cygpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGluKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5pbihyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhjbHVkZXMgYSByb29tIHdoZW4gZW1pdHRpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHRoZSBcImZvb1wiIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cywgZXhjZXB0IHRoZSBvbmVzIHRoYXQgYXJlIGluIHRoZSBcInJvb20tMTAxXCIgcm9vbVxuICAgICAqIGlvLmV4Y2VwdChcInJvb20tMTAxXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogaW8uZXhjZXB0KFtcInJvb20tMTAxXCIsIFwicm9vbS0xMDJcIl0pLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIG11bHRpcGxlIGNoYWluZWQgY2FsbHNcbiAgICAgKiBpby5leGNlcHQoXCJyb29tLTEwMVwiKS5leGNlcHQoXCJyb29tLTEwMlwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGV4Y2VwdChyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuZXhjZXB0KHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudCB0byBhbGwgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1pbWljcyB0aGUgV2ViU29ja2V0LnNlbmQoKSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJTb2NrZXQvc2VuZFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5zZW5kKFwiaGVsbG9cIik7XG4gICAgICpcbiAgICAgKiAvLyB0aGlzIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgKiBpby5lbWl0KFwibWVzc2FnZVwiLCBcImhlbGxvXCIpO1xuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgc2VuZCguLi5hcmdzKSB7XG4gICAgICAgIC8vIFRoaXMgdHlwZS1jYXN0IGlzIG5lZWRlZCBiZWNhdXNlIEVtaXRFdmVudHMgbGlrZWx5IGRvZXNuJ3QgaGF2ZSBgbWVzc2FnZWAgYXMgYSBrZXkuXG4gICAgICAgIC8vIGlmIHlvdSBzcGVjaWZ5IHRoZSBFbWl0RXZlbnRzLCB0aGUgdHlwZSBvZiBhcmdzIHdpbGwgYmUgbmV2ZXIuXG4gICAgICAgIHRoaXMuc29ja2V0cy5lbWl0KFwibWVzc2FnZVwiLCAuLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50IHRvIGFsbCBjbGllbnRzLiBBbGlhcyBvZiB7QGxpbmsgc2VuZH0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICB3cml0ZSguLi5hcmdzKSB7XG4gICAgICAgIC8vIFRoaXMgdHlwZS1jYXN0IGlzIG5lZWRlZCBiZWNhdXNlIEVtaXRFdmVudHMgbGlrZWx5IGRvZXNuJ3QgaGF2ZSBgbWVzc2FnZWAgYXMgYSBrZXkuXG4gICAgICAgIC8vIGlmIHlvdSBzcGVjaWZ5IHRoZSBFbWl0RXZlbnRzLCB0aGUgdHlwZSBvZiBhcmdzIHdpbGwgYmUgbmV2ZXIuXG4gICAgICAgIHRoaXMuc29ja2V0cy5lbWl0KFwibWVzc2FnZVwiLCAuLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgb3RoZXIgU29ja2V0LklPIHNlcnZlcnMgb2YgdGhlIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLnNlcnZlclNpZGVFbWl0KFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAgICAgKlxuICAgICAqIGlvLm9uKFwiaGVsbG9cIiwgKGFyZzEpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGFyZzEpOyAvLyBwcmludHMgXCJ3b3JsZFwiXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBhY2tub3dsZWRnZW1lbnRzICh3aXRob3V0IGJpbmFyeSBjb250ZW50KSBhcmUgc3VwcG9ydGVkIHRvbzpcbiAgICAgKiBpby5zZXJ2ZXJTaWRlRW1pdChcInBpbmdcIiwgKGVyciwgcmVzcG9uc2VzKSA9PiB7XG4gICAgICogIGlmIChlcnIpIHtcbiAgICAgKiAgICAgLy8gc29tZSBzZXJ2ZXJzIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgfSBlbHNlIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzcG9uc2VzKTsgLy8gb25lIHJlc3BvbnNlIHBlciBzZXJ2ZXIgKGV4Y2VwdCB0aGUgY3VycmVudCBvbmUpXG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBpby5vbihcInBpbmdcIiwgKGNiKSA9PiB7XG4gICAgICogICBjYihcInBvbmdcIik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgLSB0aGUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIC0gYW4gYXJyYXkgb2YgYXJndW1lbnRzLCB3aGljaCBtYXkgaW5jbHVkZSBhbiBhY2tub3dsZWRnZW1lbnQgY2FsbGJhY2sgYXQgdGhlIGVuZFxuICAgICAqL1xuICAgIHNlcnZlclNpZGVFbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuc2VydmVyU2lkZUVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgYW5kIGV4cGVjdCBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSB0aGUgb3RoZXIgU29ja2V0LklPIHNlcnZlcnMgb2YgdGhlIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHRyeSB7XG4gICAgICogICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBpby5zZXJ2ZXJTaWRlRW1pdFdpdGhBY2soXCJwaW5nXCIpO1xuICAgICAqICAgY29uc29sZS5sb2cocmVzcG9uc2VzKTsgLy8gb25lIHJlc3BvbnNlIHBlciBzZXJ2ZXIgKGV4Y2VwdCB0aGUgY3VycmVudCBvbmUpXG4gICAgICogfSBjYXRjaCAoZSkge1xuICAgICAqICAgLy8gc29tZSBzZXJ2ZXJzIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldiAtIHRoZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIGFyZ3MgLSBhbiBhcnJheSBvZiBhcmd1bWVudHNcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiBhbGwgc2VydmVycyBoYXZlIGFja25vd2xlZGdlZCB0aGUgZXZlbnRcbiAgICAgKi9cbiAgICBzZXJ2ZXJTaWRlRW1pdFdpdGhBY2soZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5zZXJ2ZXJTaWRlRW1pdFdpdGhBY2soZXYsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBzb2NrZXQgaWRzLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgdGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UsIHBsZWFzZSB1c2Uge0BsaW5rIFNlcnZlciNzZXJ2ZXJTaWRlRW1pdH0gb3JcbiAgICAgKiB7QGxpbmsgU2VydmVyI2ZldGNoU29ja2V0c30gaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhbGxTb2NrZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLmFsbFNvY2tldHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29tcHJlc3MgZmxhZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8uY29tcHJlc3MoZmFsc2UpLmVtaXQoXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21wcmVzcyAtIGlmIGB0cnVlYCwgY29tcHJlc3NlcyB0aGUgc2VuZGluZyBkYXRhXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGNvbXByZXNzKGNvbXByZXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuY29tcHJlc3MoY29tcHJlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIG1heSBiZSBsb3N0IGlmIHRoZSBjbGllbnQgaXMgbm90IHJlYWR5IHRvXG4gICAgICogcmVjZWl2ZSBtZXNzYWdlcyAoYmVjYXVzZSBvZiBuZXR3b3JrIHNsb3duZXNzIG9yIG90aGVyIGlzc3Vlcywgb3IgYmVjYXVzZSB0aGV54oCZcmUgY29ubmVjdGVkIHRocm91Z2ggbG9uZyBwb2xsaW5nXG4gICAgICogYW5kIGlzIGluIHRoZSBtaWRkbGUgb2YgYSByZXF1ZXN0LXJlc3BvbnNlIGN5Y2xlKS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8udm9sYXRpbGUuZW1pdChcImhlbGxvXCIpOyAvLyB0aGUgY2xpZW50cyBtYXkgb3IgbWF5IG5vdCByZWNlaXZlIGl0XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZ2V0IHZvbGF0aWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLnZvbGF0aWxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIHdpbGwgb25seSBiZSBicm9hZGNhc3QgdG8gdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gdGhlIOKAnGZvb+KAnSBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMgb24gdGhpcyBub2RlXG4gICAgICogaW8ubG9jYWwuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBnZXQgbG9jYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMubG9jYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIG5leHQgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby50aW1lb3V0KDEwMDApLmVtaXQoXCJzb21lLWV2ZW50XCIsIChlcnIsIHJlc3BvbnNlcykgPT4ge1xuICAgICAqICAgaWYgKGVycikge1xuICAgICAqICAgICAvLyBzb21lIGNsaWVudHMgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogICB9IGVsc2Uge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXNwb25zZXMpOyAvLyBvbmUgcmVzcG9uc2UgcGVyIGNsaWVudFxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHRpbWVvdXRcbiAgICAgKi9cbiAgICB0aW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy50aW1lb3V0KHRpbWVvdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHJldHVybiBhbGwgU29ja2V0IGluc3RhbmNlc1xuICAgICAqIGNvbnN0IHNvY2tldHMgPSBhd2FpdCBpby5mZXRjaFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIC8vIHJldHVybiBhbGwgU29ja2V0IGluc3RhbmNlcyBpbiB0aGUgXCJyb29tMVwiIHJvb21cbiAgICAgKiBjb25zdCBzb2NrZXRzID0gYXdhaXQgaW8uaW4oXCJyb29tMVwiKS5mZXRjaFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIGZvciAoY29uc3Qgc29ja2V0IG9mIHNvY2tldHMpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5pZCk7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuaGFuZHNoYWtlKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5yb29tcyk7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuZGF0YSk7XG4gICAgICpcbiAgICAgKiAgIHNvY2tldC5lbWl0KFwiaGVsbG9cIik7XG4gICAgICogICBzb2NrZXQuam9pbihcInJvb20xXCIpO1xuICAgICAqICAgc29ja2V0LmxlYXZlKFwicm9vbTJcIik7XG4gICAgICogICBzb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICBmZXRjaFNvY2tldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuZmV0Y2hTb2NrZXRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGpvaW4gdGhlIHNwZWNpZmllZCByb29tcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgam9pbiB0aGUgXCJyb29tMVwiIHJvb21cbiAgICAgKiBpby5zb2NrZXRzSm9pbihcInJvb20xXCIpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBpbiB0aGUgXCJyb29tMVwiIHJvb20gam9pbiB0aGUgXCJyb29tMlwiIGFuZCBcInJvb20zXCIgcm9vbXNcbiAgICAgKiBpby5pbihcInJvb20xXCIpLnNvY2tldHNKb2luKFtcInJvb20yXCIsIFwicm9vbTNcIl0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICovXG4gICAgc29ja2V0c0pvaW4ocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLnNvY2tldHNKb2luKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBsZWF2ZSB0aGUgc3BlY2lmaWVkIHJvb21zLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgbGVhdmUgdGhlIFwicm9vbTFcIiByb29tXG4gICAgICogaW8uc29ja2V0c0xlYXZlKFwicm9vbTFcIik7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbSBsZWF2ZSB0aGUgXCJyb29tMlwiIGFuZCBcInJvb20zXCIgcm9vbXNcbiAgICAgKiBpby5pbihcInJvb20xXCIpLnNvY2tldHNMZWF2ZShbXCJyb29tMlwiLCBcInJvb20zXCJdKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqL1xuICAgIHNvY2tldHNMZWF2ZShyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuc29ja2V0c0xlYXZlKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBkaXNjb25uZWN0LlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgZGlzY29ubmVjdCAodGhlIGNvbm5lY3Rpb25zIG1pZ2h0IGJlIGtlcHQgYWxpdmUgZm9yIG90aGVyIG5hbWVzcGFjZXMpXG4gICAgICogaW8uZGlzY29ubmVjdFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tIGRpc2Nvbm5lY3QgYW5kIGNsb3NlIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25zXG4gICAgICogaW8uaW4oXCJyb29tMVwiKS5kaXNjb25uZWN0U29ja2V0cyh0cnVlKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbG9zZSAtIHdoZXRoZXIgdG8gY2xvc2UgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RTb2NrZXRzKGNsb3NlID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5kaXNjb25uZWN0U29ja2V0cyhjbG9zZSk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXIgPSBTZXJ2ZXI7XG4vKipcbiAqIEV4cG9zZSBtYWluIG5hbWVzcGFjZSAoLykuXG4gKi9cbmNvbnN0IGVtaXR0ZXJNZXRob2RzID0gT2JqZWN0LmtleXMoZXZlbnRzXzEuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGV2ZW50c18xLkV2ZW50RW1pdHRlci5wcm90b3R5cGVba2V5XSA9PT0gXCJmdW5jdGlvblwiO1xufSk7XG5lbWl0dGVyTWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgIFNlcnZlci5wcm90b3R5cGVbZm5dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzW2ZuXS5hcHBseSh0aGlzLnNvY2tldHMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSAoc3J2LCBvcHRzKSA9PiBuZXcgU2VydmVyKHNydiwgb3B0cyk7XG5tb2R1bGUuZXhwb3J0cy5TZXJ2ZXIgPSBTZXJ2ZXI7XG5tb2R1bGUuZXhwb3J0cy5OYW1lc3BhY2UgPSBuYW1lc3BhY2VfMS5OYW1lc3BhY2U7XG5tb2R1bGUuZXhwb3J0cy5Tb2NrZXQgPSBzb2NrZXRfMS5Tb2NrZXQ7XG4iXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19zZXRNb2R1bGVEZWZhdWx0IiwidiIsInZhbHVlIiwiX19pbXBvcnRTdGFyIiwibW9kIiwicmVzdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19pbXBvcnREZWZhdWx0IiwiZXhwb3J0cyIsIk5hbWVzcGFjZSIsIlNvY2tldCIsIlNlcnZlciIsImh0dHAiLCJyZXF1aXJlIiwiZnNfMSIsInpsaWJfMSIsImFjY2VwdHMiLCJzdHJlYW1fMSIsInBhdGgiLCJlbmdpbmVfaW9fMSIsImNsaWVudF8xIiwiZXZlbnRzXzEiLCJuYW1lc3BhY2VfMSIsInBhcmVudF9uYW1lc3BhY2VfMSIsInNvY2tldF9pb19hZGFwdGVyXzEiLCJwYXJzZXIiLCJkZWJ1Z18xIiwic29ja2V0XzEiLCJ0eXBlZF9ldmVudHNfMSIsInV3c18xIiwiY29yc18xIiwiZGVidWciLCJkZWZhdWx0IiwiY2xpZW50VmVyc2lvbiIsInZlcnNpb24iLCJkb3RNYXBSZWdleCIsIlN0cmljdEV2ZW50RW1pdHRlciIsImNvbnN0cnVjdG9yIiwic3J2Iiwib3B0cyIsIl9uc3BzIiwiTWFwIiwicGFyZW50TnNwcyIsInBhcmVudE5hbWVzcGFjZXNGcm9tUmVnRXhwIiwibGlzdGVuIiwiY29ubmVjdFRpbWVvdXQiLCJzZXJ2ZUNsaWVudCIsIl9wYXJzZXIiLCJlbmNvZGVyIiwiRW5jb2RlciIsImNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5IiwiYXNzaWduIiwibWF4RGlzY29ubmVjdGlvbkR1cmF0aW9uIiwic2tpcE1pZGRsZXdhcmVzIiwiYWRhcHRlciIsIlNlc3Npb25Bd2FyZUFkYXB0ZXIiLCJBZGFwdGVyIiwiY2xlYW51cEVtcHR5Q2hpbGROYW1lc3BhY2VzIiwic29ja2V0cyIsIm9mIiwiYXR0YWNoIiwiY29ycyIsIl9jb3JzTWlkZGxld2FyZSIsIl9vcHRzIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiX3NlcnZlQ2xpZW50IiwiX2NoZWNrTmFtZXNwYWNlIiwibmFtZSIsImF1dGgiLCJmbiIsInNpemUiLCJrZXlzSXRlcmF0b3IiLCJrZXlzIiwicnVuIiwibmV4dEZuIiwibmV4dCIsImRvbmUiLCJlcnIiLCJhbGxvdyIsImhhcyIsIm5hbWVzcGFjZSIsImNyZWF0ZUNoaWxkIiwiX3BhdGgiLCJyZXBsYWNlIiwiZXNjYXBlZFBhdGgiLCJjbGllbnRQYXRoUmVnZXgiLCJSZWdFeHAiLCJfY29ubmVjdFRpbWVvdXQiLCJfYWRhcHRlciIsIm5zcCIsInZhbHVlcyIsIl9pbml0QWRhcHRlciIsIm1zZyIsIkVycm9yIiwiTnVtYmVyIiwicG9ydCIsImNyZWF0ZVNlcnZlciIsInJlcSIsInJlcyIsIndyaXRlSGVhZCIsImVuZCIsImluaXRFbmdpbmUiLCJhdHRhY2hBcHAiLCJhcHAiLCJlbmdpbmUiLCJ1U2VydmVyIiwiYmluZCIsInRlc3QiLCJnZXRVcmwiLCJzZXRZaWVsZCIsImZpbGVuYW1lIiwiaXNNYXAiLCJ0eXBlIiwiZXhwZWN0ZWRFdGFnIiwid2Vha0V0YWciLCJldGFnIiwiZ2V0SGVhZGVyIiwid3JpdGVTdGF0dXMiLCJ3cml0ZUhlYWRlciIsImZpbGVwYXRoIiwiam9pbiIsIl9fZGlybmFtZSIsInNlcnZlRmlsZSIsInBhdGNoQWRhcHRlciIsImVpbyIsImF0dGFjaFNlcnZlIiwiaHR0cFNlcnZlciIsImV2cyIsImxpc3RlbmVycyIsInNsaWNlIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwib24iLCJ1cmwiLCJzZXJ2ZSIsImkiLCJoZWFkZXJzIiwic2V0SGVhZGVyIiwic2VuZEZpbGUiLCJyZWFkU3RyZWFtIiwiY3JlYXRlUmVhZFN0cmVhbSIsImVuY29kaW5nIiwiZW5jb2RpbmdzIiwib25FcnJvciIsInBpcGVsaW5lIiwiY3JlYXRlQnJvdGxpQ29tcHJlc3MiLCJjcmVhdGVHemlwIiwiY3JlYXRlRGVmbGF0ZSIsIm9uY29ubmVjdGlvbiIsImNvbm4iLCJpZCIsImNsaWVudCIsIkNsaWVudCIsInByb3RvY29sIiwiY29ubmVjdCIsInBhcmVudE5zcCIsIlBhcmVudE5hbWVzcGFjZSIsInNldCIsIlN0cmluZyIsInJlZ2V4IiwicGFyZW50TmFtZXNwYWNlIiwiZW1pdFJlc2VydmVkIiwiY2xvc2UiLCJQcm9taXNlIiwiYWxsU2V0dGxlZCIsIm1hcCIsImZvckVhY2giLCJzb2NrZXQiLCJfb25jbG9zZSIsInJlc3RvcmVBZGFwdGVyIiwidXNlIiwidG8iLCJyb29tIiwiaW4iLCJleGNlcHQiLCJzZW5kIiwiYXJncyIsImVtaXQiLCJ3cml0ZSIsInNlcnZlclNpZGVFbWl0IiwiZXYiLCJzZXJ2ZXJTaWRlRW1pdFdpdGhBY2siLCJhbGxTb2NrZXRzIiwiY29tcHJlc3MiLCJ2b2xhdGlsZSIsImxvY2FsIiwidGltZW91dCIsImZldGNoU29ja2V0cyIsInNvY2tldHNKb2luIiwic29ja2V0c0xlYXZlIiwiZGlzY29ubmVjdFNvY2tldHMiLCJlbWl0dGVyTWV0aG9kcyIsIkV2ZW50RW1pdHRlciIsImZpbHRlciIsImtleSIsImFwcGx5IiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/namespace.js":
/*!**************************************************!*\
  !*** ./node_modules/socket.io/dist/namespace.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Namespace = exports.RESERVED_EVENTS = void 0;\nconst socket_1 = __webpack_require__(/*! ./socket */ \"(rsc)/./node_modules/socket.io/dist/socket.js\");\nconst typed_events_1 = __webpack_require__(/*! ./typed-events */ \"(rsc)/./node_modules/socket.io/dist/typed-events.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst broadcast_operator_1 = __webpack_require__(/*! ./broadcast-operator */ \"(rsc)/./node_modules/socket.io/dist/broadcast-operator.js\");\nconst debug = (0, debug_1.default)(\"socket.io:namespace\");\nexports.RESERVED_EVENTS = new Set([\n    \"connect\",\n    \"connection\",\n    \"new_namespace\"\n]);\n/**\n * A Namespace is a communication channel that allows you to split the logic of your application over a single shared\n * connection.\n *\n * Each namespace has its own:\n *\n * - event handlers\n *\n * ```\n * io.of(\"/orders\").on(\"connection\", (socket) => {\n *   socket.on(\"order:list\", () => {});\n *   socket.on(\"order:create\", () => {});\n * });\n *\n * io.of(\"/users\").on(\"connection\", (socket) => {\n *   socket.on(\"user:list\", () => {});\n * });\n * ```\n *\n * - rooms\n *\n * ```\n * const orderNamespace = io.of(\"/orders\");\n *\n * orderNamespace.on(\"connection\", (socket) => {\n *   socket.join(\"room1\");\n *   orderNamespace.to(\"room1\").emit(\"hello\");\n * });\n *\n * const userNamespace = io.of(\"/users\");\n *\n * userNamespace.on(\"connection\", (socket) => {\n *   socket.join(\"room1\"); // distinct from the room in the \"orders\" namespace\n *   userNamespace.to(\"room1\").emit(\"hol\");\n * });\n * ```\n *\n * - middlewares\n *\n * ```\n * const orderNamespace = io.of(\"/orders\");\n *\n * orderNamespace.use((socket, next) => {\n *   // ensure the socket has access to the \"orders\" namespace\n * });\n *\n * const userNamespace = io.of(\"/users\");\n *\n * userNamespace.use((socket, next) => {\n *   // ensure the socket has access to the \"users\" namespace\n * });\n * ```\n */ class Namespace extends typed_events_1.StrictEventEmitter {\n    /**\n     * Namespace constructor.\n     *\n     * @param server instance\n     * @param name\n     */ constructor(server, name){\n        super();\n        /**\n         * A map of currently connected sockets.\n         */ this.sockets = new Map();\n        /**\n         * A map of currently connecting sockets.\n         */ this._preConnectSockets = new Map();\n        this._fns = [];\n        /** @private */ this._ids = 0;\n        this.server = server;\n        this.name = name;\n        this._initAdapter();\n    }\n    /**\n     * Initializes the `Adapter` for this nsp.\n     * Run upon changing adapter by `Server#adapter`\n     * in addition to the constructor.\n     *\n     * @private\n     */ _initAdapter() {\n        // @ts-ignore\n        this.adapter = new (this.server.adapter())(this);\n    }\n    /**\n     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.use((socket, next) => {\n     *   // ...\n     *   next();\n     * });\n     *\n     * @param fn - the middleware function\n     */ use(fn) {\n        this._fns.push(fn);\n        return this;\n    }\n    /**\n     * Executes the middleware for an incoming client.\n     *\n     * @param socket - the socket that will get added\n     * @param fn - last fn call in the middleware\n     * @private\n     */ run(socket, fn) {\n        if (!this._fns.length) return fn();\n        const fns = this._fns.slice(0);\n        function run(i) {\n            fns[i](socket, (err)=>{\n                // upon error, short-circuit\n                if (err) return fn(err);\n                // if no middleware left, summon callback\n                if (!fns[i + 1]) return fn();\n                // go on to next\n                run(i + 1);\n            });\n        }\n        run(0);\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // the foo event will be broadcast to all connected clients in the room-101 room\n     * myNamespace.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms (a client will be notified at most once)\n     * myNamespace.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * myNamespace.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ to(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).to(room);\n    }\n    /**\n     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // disconnect all clients in the \"room-101\" room\n     * myNamespace.in(\"room-101\").disconnectSockets();\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ in(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).in(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     * myNamespace.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms\n     * myNamespace.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * myNamespace.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ except(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).except(room);\n    }\n    /**\n     * Adds a new client.\n     *\n     * @return {Socket}\n     * @private\n     */ async _add(client, auth, fn) {\n        var _a;\n        debug(\"adding socket to nsp %s\", this.name);\n        const socket = await this._createSocket(client, auth);\n        this._preConnectSockets.set(socket.id, socket);\n        if (// @ts-ignore\n        ((_a = this.server.opts.connectionStateRecovery) === null || _a === void 0 ? void 0 : _a.skipMiddlewares) && socket.recovered && client.conn.readyState === \"open\") {\n            return this._doConnect(socket, fn);\n        }\n        this.run(socket, (err)=>{\n            process.nextTick(()=>{\n                if (\"open\" !== client.conn.readyState) {\n                    debug(\"next called after client was closed - ignoring socket\");\n                    socket._cleanup();\n                    return;\n                }\n                if (err) {\n                    debug(\"middleware error, sending CONNECT_ERROR packet to the client\");\n                    socket._cleanup();\n                    if (client.conn.protocol === 3) {\n                        return socket._error(err.data || err.message);\n                    } else {\n                        return socket._error({\n                            message: err.message,\n                            data: err.data\n                        });\n                    }\n                }\n                this._doConnect(socket, fn);\n            });\n        });\n    }\n    async _createSocket(client, auth) {\n        const sessionId = auth.pid;\n        const offset = auth.offset;\n        if (// @ts-ignore\n        this.server.opts.connectionStateRecovery && typeof sessionId === \"string\" && typeof offset === \"string\") {\n            let session;\n            try {\n                session = await this.adapter.restoreSession(sessionId, offset);\n            } catch (e) {\n                debug(\"error while restoring session: %s\", e);\n            }\n            if (session) {\n                debug(\"connection state recovered for sid %s\", session.sid);\n                return new socket_1.Socket(this, client, auth, session);\n            }\n        }\n        return new socket_1.Socket(this, client, auth);\n    }\n    _doConnect(socket, fn) {\n        this._preConnectSockets.delete(socket.id);\n        this.sockets.set(socket.id, socket);\n        // it's paramount that the internal `onconnect` logic\n        // fires before user-set events to prevent state order\n        // violations (such as a disconnection before the connection\n        // logic is complete)\n        socket._onconnect();\n        if (fn) fn(socket);\n        // fire user-set events\n        this.emitReserved(\"connect\", socket);\n        this.emitReserved(\"connection\", socket);\n    }\n    /**\n     * Removes a client. Called by each `Socket`.\n     *\n     * @private\n     */ _remove(socket) {\n        this.sockets.delete(socket.id) || this._preConnectSockets.delete(socket.id);\n    }\n    /**\n     * Emits to all connected clients.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.emit(\"hello\", \"world\");\n     *\n     * // all serializable datastructures are supported (no need to call JSON.stringify)\n     * myNamespace.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n     *\n     * // with an acknowledgement from the clients\n     * myNamespace.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @return Always true\n     */ emit(ev, ...args) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).emit(ev, ...args);\n    }\n    /**\n     * Sends a `message` event to all clients.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.send(\"hello\");\n     *\n     * // this is equivalent to\n     * myNamespace.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */ send(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a `message` event to all clients. Sends a `message` event. Alias of {@link send}.\n     *\n     * @return self\n     */ write(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a message to the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.serverSideEmit(\"hello\", \"world\");\n     *\n     * myNamespace.on(\"hello\", (arg1) => {\n     *   console.log(arg1); // prints \"world\"\n     * });\n     *\n     * // acknowledgements (without binary content) are supported too:\n     * myNamespace.serverSideEmit(\"ping\", (err, responses) => {\n     *  if (err) {\n     *     // some servers did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per server (except the current one)\n     *   }\n     * });\n     *\n     * myNamespace.on(\"ping\", (cb) => {\n     *   cb(\"pong\");\n     * });\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments, which may include an acknowledgement callback at the end\n     */ serverSideEmit(ev, ...args) {\n        if (exports.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${String(ev)}\" is a reserved event name`);\n        }\n        args.unshift(ev);\n        this.adapter.serverSideEmit(args);\n        return true;\n    }\n    /**\n     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * try {\n     *   const responses = await myNamespace.serverSideEmitWithAck(\"ping\");\n     *   console.log(responses); // one response per server (except the current one)\n     * } catch (e) {\n     *   // some servers did not acknowledge the event in the given delay\n     * }\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments\n     *\n     * @return a Promise that will be fulfilled when all servers have acknowledged the event\n     */ serverSideEmitWithAck(ev, ...args) {\n        return new Promise((resolve, reject)=>{\n            args.push((err, responses)=>{\n                if (err) {\n                    err.responses = responses;\n                    return reject(err);\n                } else {\n                    return resolve(responses);\n                }\n            });\n            this.serverSideEmit(ev, ...args);\n        });\n    }\n    /**\n     * Called when a packet is received from another Socket.IO server\n     *\n     * @param args - an array of arguments, which may include an acknowledgement callback at the end\n     *\n     * @private\n     */ _onServerSideEmit(args) {\n        super.emitUntyped.apply(this, args);\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @deprecated this method will be removed in the next major release, please use {@link Namespace#serverSideEmit} or\n     * {@link Namespace#fetchSockets} instead.\n     */ allSockets() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).allSockets();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     */ compress(compress) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).compress(compress);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because theyre connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.volatile.emit(\"hello\"); // the clients may or may not receive it\n     *\n     * @return self\n     */ get volatile() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).volatile;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // the foo event will be broadcast to all connected clients on this node\n     * myNamespace.local.emit(\"foo\", \"bar\");\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ get local() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).local;\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @param timeout\n     */ timeout(timeout) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).timeout(timeout);\n    }\n    /**\n     * Returns the matching socket instances.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // return all Socket instances\n     * const sockets = await myNamespace.fetchSockets();\n     *\n     * // return all Socket instances in the \"room1\" room\n     * const sockets = await myNamespace.in(\"room1\").fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   console.log(socket.id);\n     *   console.log(socket.handshake);\n     *   console.log(socket.rooms);\n     *   console.log(socket.data);\n     *\n     *   socket.emit(\"hello\");\n     *   socket.join(\"room1\");\n     *   socket.leave(\"room2\");\n     *   socket.disconnect();\n     * }\n     */ fetchSockets() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).fetchSockets();\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // make all socket instances join the \"room1\" room\n     * myNamespace.socketsJoin(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room join the \"room2\" and \"room3\" rooms\n     * myNamespace.in(\"room1\").socketsJoin([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */ socketsJoin(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsJoin(room);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // make all socket instances leave the \"room1\" room\n     * myNamespace.socketsLeave(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room leave the \"room2\" and \"room3\" rooms\n     * myNamespace.in(\"room1\").socketsLeave([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */ socketsLeave(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsLeave(room);\n    }\n    /**\n     * Makes the matching socket instances disconnect.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)\n     * myNamespace.disconnectSockets();\n     *\n     * // make all socket instances in the \"room1\" room disconnect and close the underlying connections\n     * myNamespace.in(\"room1\").disconnectSockets(true);\n     *\n     * @param close - whether to close the underlying connection\n     */ disconnectSockets(close = false) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).disconnectSockets(close);\n    }\n}\nexports.Namespace = Namespace;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvbmFtZXNwYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUdBLHVCQUF1QixHQUFHLEtBQUs7QUFDbkQsTUFBTUksV0FBV0MsbUJBQU9BLENBQUMsK0RBQVU7QUFDbkMsTUFBTUMsaUJBQWlCRCxtQkFBT0EsQ0FBQywyRUFBZ0I7QUFDL0MsTUFBTUUsVUFBVVosZ0JBQWdCVSxtQkFBT0EsQ0FBQyw2RUFBTztBQUMvQyxNQUFNRyx1QkFBdUJILG1CQUFPQSxDQUFDLHVGQUFzQjtBQUMzRCxNQUFNSSxRQUFRLENBQUMsR0FBR0YsUUFBUUcsT0FBTyxFQUFFO0FBQ25DVix1QkFBdUIsR0FBRyxJQUFJVyxJQUFJO0lBQUM7SUFBVztJQUFjO0NBQWdCO0FBQzVFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0RDLEdBQ0QsTUFBTVQsa0JBQWtCSSxlQUFlTSxrQkFBa0I7SUFDckQ7Ozs7O0tBS0MsR0FDREMsWUFBWUMsTUFBTSxFQUFFQyxJQUFJLENBQUU7UUFDdEIsS0FBSztRQUNMOztTQUVDLEdBQ0QsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSUM7UUFDbkI7O1NBRUMsR0FDRCxJQUFJLENBQUNDLGtCQUFrQixHQUFHLElBQUlEO1FBQzlCLElBQUksQ0FBQ0UsSUFBSSxHQUFHLEVBQUU7UUFDZCxhQUFhLEdBQ2IsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNOLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLElBQUksR0FB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RUFBRXVFLE9BQU8sQ0FBQ0E7SUFDNUU7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXlCQyxHQUNEQyxlQUFlO1FBQ1gsT0FBTyxJQUFJdEYscUJBQXFCMkIsaUJBQWlCLENBQUMsSUFBSSxDQUFDYixPQUFPLEVBQUV3RSxZQUFZO0lBQ2hGO0lBQ0E7Ozs7Ozs7Ozs7Ozs7OztLQWVDLEdBQ0RDLFlBQVk3RCxJQUFJLEVBQUU7UUFDZCxPQUFPLElBQUkxQixxQkFBcUIyQixpQkFBaUIsQ0FBQyxJQUFJLENBQUNiLE9BQU8sRUFBRXlFLFdBQVcsQ0FBQzdEO0lBQ2hGO0lBQ0E7Ozs7Ozs7Ozs7Ozs7OztLQWVDLEdBQ0Q4RCxhQUFhOUQsSUFBSSxFQUFFO1FBQ2YsT0FBTyxJQUFJMUIscUJBQXFCMkIsaUJBQWlCLENBQUMsSUFBSSxDQUFDYixPQUFPLEVBQUUwRSxZQUFZLENBQUM5RDtJQUNqRjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7S0FlQyxHQUNEK0Qsa0JBQWtCQyxRQUFRLEtBQUssRUFBRTtRQUM3QixPQUFPLElBQUkxRixxQkFBcUIyQixpQkFBaUIsQ0FBQyxJQUFJLENBQUNiLE9BQU8sRUFBRTJFLGlCQUFpQixDQUFDQztJQUN0RjtBQUNKO0FBQ0FsRyxpQkFBaUIsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uaXJ2YWFuYWEtZWNvbW1lcmNlLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9kaXN0L25hbWVzcGFjZS5qcz9iOTdlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OYW1lc3BhY2UgPSBleHBvcnRzLlJFU0VSVkVEX0VWRU5UUyA9IHZvaWQgMDtcbmNvbnN0IHNvY2tldF8xID0gcmVxdWlyZShcIi4vc29ja2V0XCIpO1xuY29uc3QgdHlwZWRfZXZlbnRzXzEgPSByZXF1aXJlKFwiLi90eXBlZC1ldmVudHNcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBicm9hZGNhc3Rfb3BlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL2Jyb2FkY2FzdC1vcGVyYXRvclwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJzb2NrZXQuaW86bmFtZXNwYWNlXCIpO1xuZXhwb3J0cy5SRVNFUlZFRF9FVkVOVFMgPSBuZXcgU2V0KFtcImNvbm5lY3RcIiwgXCJjb25uZWN0aW9uXCIsIFwibmV3X25hbWVzcGFjZVwiXSk7XG4vKipcbiAqIEEgTmFtZXNwYWNlIGlzIGEgY29tbXVuaWNhdGlvbiBjaGFubmVsIHRoYXQgYWxsb3dzIHlvdSB0byBzcGxpdCB0aGUgbG9naWMgb2YgeW91ciBhcHBsaWNhdGlvbiBvdmVyIGEgc2luZ2xlIHNoYXJlZFxuICogY29ubmVjdGlvbi5cbiAqXG4gKiBFYWNoIG5hbWVzcGFjZSBoYXMgaXRzIG93bjpcbiAqXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKlxuICogYGBgXG4gKiBpby5vZihcIi9vcmRlcnNcIikub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAqICAgc29ja2V0Lm9uKFwib3JkZXI6bGlzdFwiLCAoKSA9PiB7fSk7XG4gKiAgIHNvY2tldC5vbihcIm9yZGVyOmNyZWF0ZVwiLCAoKSA9PiB7fSk7XG4gKiB9KTtcbiAqXG4gKiBpby5vZihcIi91c2Vyc1wiKS5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICogICBzb2NrZXQub24oXCJ1c2VyOmxpc3RcIiwgKCkgPT4ge30pO1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiAtIHJvb21zXG4gKlxuICogYGBgXG4gKiBjb25zdCBvcmRlck5hbWVzcGFjZSA9IGlvLm9mKFwiL29yZGVyc1wiKTtcbiAqXG4gKiBvcmRlck5hbWVzcGFjZS5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICogICBzb2NrZXQuam9pbihcInJvb20xXCIpO1xuICogICBvcmRlck5hbWVzcGFjZS50byhcInJvb20xXCIpLmVtaXQoXCJoZWxsb1wiKTtcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHVzZXJOYW1lc3BhY2UgPSBpby5vZihcIi91c2Vyc1wiKTtcbiAqXG4gKiB1c2VyTmFtZXNwYWNlLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gKiAgIHNvY2tldC5qb2luKFwicm9vbTFcIik7IC8vIGRpc3RpbmN0IGZyb20gdGhlIHJvb20gaW4gdGhlIFwib3JkZXJzXCIgbmFtZXNwYWNlXG4gKiAgIHVzZXJOYW1lc3BhY2UudG8oXCJyb29tMVwiKS5lbWl0KFwiaG9sw6BcIik7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIC0gbWlkZGxld2FyZXNcbiAqXG4gKiBgYGBcbiAqIGNvbnN0IG9yZGVyTmFtZXNwYWNlID0gaW8ub2YoXCIvb3JkZXJzXCIpO1xuICpcbiAqIG9yZGVyTmFtZXNwYWNlLnVzZSgoc29ja2V0LCBuZXh0KSA9PiB7XG4gKiAgIC8vIGVuc3VyZSB0aGUgc29ja2V0IGhhcyBhY2Nlc3MgdG8gdGhlIFwib3JkZXJzXCIgbmFtZXNwYWNlXG4gKiB9KTtcbiAqXG4gKiBjb25zdCB1c2VyTmFtZXNwYWNlID0gaW8ub2YoXCIvdXNlcnNcIik7XG4gKlxuICogdXNlck5hbWVzcGFjZS51c2UoKHNvY2tldCwgbmV4dCkgPT4ge1xuICogICAvLyBlbnN1cmUgdGhlIHNvY2tldCBoYXMgYWNjZXNzIHRvIHRoZSBcInVzZXJzXCIgbmFtZXNwYWNlXG4gKiB9KTtcbiAqIGBgYFxuICovXG5jbGFzcyBOYW1lc3BhY2UgZXh0ZW5kcyB0eXBlZF9ldmVudHNfMS5TdHJpY3RFdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIE5hbWVzcGFjZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXJ2ZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNlcnZlciwgbmFtZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgY3VycmVudGx5IGNvbm5lY3RlZCBzb2NrZXRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zb2NrZXRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgY3VycmVudGx5IGNvbm5lY3Rpbmcgc29ja2V0cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ByZUNvbm5lY3RTb2NrZXRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9mbnMgPSBbXTtcbiAgICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICAgIHRoaXMuX2lkcyA9IDA7XG4gICAgICAgIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl9pbml0QWRhcHRlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgYEFkYXB0ZXJgIGZvciB0aGlzIG5zcC5cbiAgICAgKiBSdW4gdXBvbiBjaGFuZ2luZyBhZGFwdGVyIGJ5IGBTZXJ2ZXIjYWRhcHRlcmBcbiAgICAgKiBpbiBhZGRpdGlvbiB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0QWRhcHRlcigpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmFkYXB0ZXIgPSBuZXcgKHRoaXMuc2VydmVyLmFkYXB0ZXIoKSkodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIG1pZGRsZXdhcmUsIHdoaWNoIGlzIGEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIGZvciBldmVyeSBpbmNvbWluZyB7QGxpbmsgU29ja2V0fS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiBteU5hbWVzcGFjZS51c2UoKHNvY2tldCwgbmV4dCkgPT4ge1xuICAgICAqICAgLy8gLi4uXG4gICAgICogICBuZXh0KCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm4gLSB0aGUgbWlkZGxld2FyZSBmdW5jdGlvblxuICAgICAqL1xuICAgIHVzZShmbikge1xuICAgICAgICB0aGlzLl9mbnMucHVzaChmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgbWlkZGxld2FyZSBmb3IgYW4gaW5jb21pbmcgY2xpZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNvY2tldCAtIHRoZSBzb2NrZXQgdGhhdCB3aWxsIGdldCBhZGRlZFxuICAgICAqIEBwYXJhbSBmbiAtIGxhc3QgZm4gY2FsbCBpbiB0aGUgbWlkZGxld2FyZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcnVuKHNvY2tldCwgZm4pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mbnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgIGNvbnN0IGZucyA9IHRoaXMuX2Zucy5zbGljZSgwKTtcbiAgICAgICAgZnVuY3Rpb24gcnVuKGkpIHtcbiAgICAgICAgICAgIGZuc1tpXShzb2NrZXQsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB1cG9uIGVycm9yLCBzaG9ydC1jaXJjdWl0XG4gICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGVycik7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gbWlkZGxld2FyZSBsZWZ0LCBzdW1tb24gY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBpZiAoIWZuc1tpICsgMV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICAgICAgICAgIC8vIGdvIG9uIHRvIG5leHRcbiAgICAgICAgICAgICAgICBydW4oaSArIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcnVuKDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYXJnZXRzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIC8vIHRoZSDigJxmb2/igJ0gZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzIGluIHRoZSDigJxyb29tLTEwMeKAnSByb29tXG4gICAgICogbXlOYW1lc3BhY2UudG8oXCJyb29tLTEwMVwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBhbiBhcnJheSBvZiByb29tcyAoYSBjbGllbnQgd2lsbCBiZSBub3RpZmllZCBhdCBtb3N0IG9uY2UpXG4gICAgICogbXlOYW1lc3BhY2UudG8oW1wicm9vbS0xMDFcIiwgXCJyb29tLTEwMlwiXSkuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggbXVsdGlwbGUgY2hhaW5lZCBjYWxsc1xuICAgICAqIG15TmFtZXNwYWNlLnRvKFwicm9vbS0xMDFcIikudG8oXCJyb29tLTEwMlwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIHRvKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLnRvKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYXJnZXRzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLiBTaW1pbGFyIHRvIGB0bygpYCwgYnV0IG1pZ2h0IGZlZWwgY2xlYXJlciBpbiBzb21lIGNhc2VzOlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIC8vIGRpc2Nvbm5lY3QgYWxsIGNsaWVudHMgaW4gdGhlIFwicm9vbS0xMDFcIiByb29tXG4gICAgICogbXlOYW1lc3BhY2UuaW4oXCJyb29tLTEwMVwiKS5kaXNjb25uZWN0U29ja2V0cygpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGluKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLmluKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGNsdWRlcyBhIHJvb20gd2hlbiBlbWl0dGluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiAvLyB0aGUgXCJmb29cIiBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMsIGV4Y2VwdCB0aGUgb25lcyB0aGF0IGFyZSBpbiB0aGUgXCJyb29tLTEwMVwiIHJvb21cbiAgICAgKiBteU5hbWVzcGFjZS5leGNlcHQoXCJyb29tLTEwMVwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIG15TmFtZXNwYWNlLmV4Y2VwdChbXCJyb29tLTEwMVwiLCBcInJvb20tMTAyXCJdKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBtdWx0aXBsZSBjaGFpbmVkIGNhbGxzXG4gICAgICogbXlOYW1lc3BhY2UuZXhjZXB0KFwicm9vbS0xMDFcIikuZXhjZXB0KFwicm9vbS0xMDJcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBleGNlcHQocm9vbSkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikuZXhjZXB0KHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGNsaWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NvY2tldH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIF9hZGQoY2xpZW50LCBhdXRoLCBmbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGRlYnVnKFwiYWRkaW5nIHNvY2tldCB0byBuc3AgJXNcIiwgdGhpcy5uYW1lKTtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gYXdhaXQgdGhpcy5fY3JlYXRlU29ja2V0KGNsaWVudCwgYXV0aCk7XG4gICAgICAgIHRoaXMuX3ByZUNvbm5lY3RTb2NrZXRzLnNldChzb2NrZXQuaWQsIHNvY2tldCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAoKF9hID0gdGhpcy5zZXJ2ZXIub3B0cy5jb25uZWN0aW9uU3RhdGVSZWNvdmVyeSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNraXBNaWRkbGV3YXJlcykgJiZcbiAgICAgICAgICAgIHNvY2tldC5yZWNvdmVyZWQgJiZcbiAgICAgICAgICAgIGNsaWVudC5jb25uLnJlYWR5U3RhdGUgPT09IFwib3BlblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZG9Db25uZWN0KHNvY2tldCwgZm4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucnVuKHNvY2tldCwgKGVycikgPT4ge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKFwib3BlblwiICE9PSBjbGllbnQuY29ubi5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwibmV4dCBjYWxsZWQgYWZ0ZXIgY2xpZW50IHdhcyBjbG9zZWQgLSBpZ25vcmluZyBzb2NrZXRcIik7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5fY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJtaWRkbGV3YXJlIGVycm9yLCBzZW5kaW5nIENPTk5FQ1RfRVJST1IgcGFja2V0IHRvIHRoZSBjbGllbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5fY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpZW50LmNvbm4ucHJvdG9jb2wgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQuX2Vycm9yKGVyci5kYXRhIHx8IGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQuX2Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBlcnIuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RvQ29ubmVjdChzb2NrZXQsIGZuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX2NyZWF0ZVNvY2tldChjbGllbnQsIGF1dGgpIHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gYXV0aC5waWQ7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGF1dGgub2Zmc2V0O1xuICAgICAgICBpZiAoXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5zZXJ2ZXIub3B0cy5jb25uZWN0aW9uU3RhdGVSZWNvdmVyeSAmJlxuICAgICAgICAgICAgdHlwZW9mIHNlc3Npb25JZCA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9mZnNldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbGV0IHNlc3Npb247XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNlc3Npb24gPSBhd2FpdCB0aGlzLmFkYXB0ZXIucmVzdG9yZVNlc3Npb24oc2Vzc2lvbklkLCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImVycm9yIHdoaWxlIHJlc3RvcmluZyBzZXNzaW9uOiAlc1wiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJjb25uZWN0aW9uIHN0YXRlIHJlY292ZXJlZCBmb3Igc2lkICVzXCIsIHNlc3Npb24uc2lkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHNvY2tldF8xLlNvY2tldCh0aGlzLCBjbGllbnQsIGF1dGgsIHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgc29ja2V0XzEuU29ja2V0KHRoaXMsIGNsaWVudCwgYXV0aCk7XG4gICAgfVxuICAgIF9kb0Nvbm5lY3Qoc29ja2V0LCBmbikge1xuICAgICAgICB0aGlzLl9wcmVDb25uZWN0U29ja2V0cy5kZWxldGUoc29ja2V0LmlkKTtcbiAgICAgICAgdGhpcy5zb2NrZXRzLnNldChzb2NrZXQuaWQsIHNvY2tldCk7XG4gICAgICAgIC8vIGl0J3MgcGFyYW1vdW50IHRoYXQgdGhlIGludGVybmFsIGBvbmNvbm5lY3RgIGxvZ2ljXG4gICAgICAgIC8vIGZpcmVzIGJlZm9yZSB1c2VyLXNldCBldmVudHMgdG8gcHJldmVudCBzdGF0ZSBvcmRlclxuICAgICAgICAvLyB2aW9sYXRpb25zIChzdWNoIGFzIGEgZGlzY29ubmVjdGlvbiBiZWZvcmUgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgLy8gbG9naWMgaXMgY29tcGxldGUpXG4gICAgICAgIHNvY2tldC5fb25jb25uZWN0KCk7XG4gICAgICAgIGlmIChmbilcbiAgICAgICAgICAgIGZuKHNvY2tldCk7XG4gICAgICAgIC8vIGZpcmUgdXNlci1zZXQgZXZlbnRzXG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiY29ubmVjdFwiLCBzb2NrZXQpO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImNvbm5lY3Rpb25cIiwgc29ja2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNsaWVudC4gQ2FsbGVkIGJ5IGVhY2ggYFNvY2tldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmUoc29ja2V0KSB7XG4gICAgICAgIHRoaXMuc29ja2V0cy5kZWxldGUoc29ja2V0LmlkKSB8fCB0aGlzLl9wcmVDb25uZWN0U29ja2V0cy5kZWxldGUoc29ja2V0LmlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIG15TmFtZXNwYWNlLmVtaXQoXCJoZWxsb1wiLCBcIndvcmxkXCIpO1xuICAgICAqXG4gICAgICogLy8gYWxsIHNlcmlhbGl6YWJsZSBkYXRhc3RydWN0dXJlcyBhcmUgc3VwcG9ydGVkIChubyBuZWVkIHRvIGNhbGwgSlNPTi5zdHJpbmdpZnkpXG4gICAgICogbXlOYW1lc3BhY2UuZW1pdChcImhlbGxvXCIsIDEsIFwiMlwiLCB7IDM6IFtcIjRcIl0sIDU6IFVpbnQ4QXJyYXkuZnJvbShbNl0pIH0pO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSB0aGUgY2xpZW50c1xuICAgICAqIG15TmFtZXNwYWNlLnRpbWVvdXQoMTAwMCkuZW1pdChcInNvbWUtZXZlbnRcIiwgKGVyciwgcmVzcG9uc2VzKSA9PiB7XG4gICAgICogICBpZiAoZXJyKSB7XG4gICAgICogICAgIC8vIHNvbWUgY2xpZW50cyBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiAgIH0gZWxzZSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlcyk7IC8vIG9uZSByZXNwb25zZSBwZXIgY2xpZW50XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEFsd2F5cyB0cnVlXG4gICAgICovXG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikuZW1pdChldiwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50IHRvIGFsbCBjbGllbnRzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWltaWNzIHRoZSBXZWJTb2NrZXQuc2VuZCgpIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlNvY2tldC9zZW5kXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogbXlOYW1lc3BhY2Uuc2VuZChcImhlbGxvXCIpO1xuICAgICAqXG4gICAgICogLy8gdGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICogbXlOYW1lc3BhY2UuZW1pdChcIm1lc3NhZ2VcIiwgXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIHNlbmQoLi4uYXJncykge1xuICAgICAgICAvLyBUaGlzIHR5cGUtY2FzdCBpcyBuZWVkZWQgYmVjYXVzZSBFbWl0RXZlbnRzIGxpa2VseSBkb2Vzbid0IGhhdmUgYG1lc3NhZ2VgIGFzIGEga2V5LlxuICAgICAgICAvLyBpZiB5b3Ugc3BlY2lmeSB0aGUgRW1pdEV2ZW50cywgdGhlIHR5cGUgb2YgYXJncyB3aWxsIGJlIG5ldmVyLlxuICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQgdG8gYWxsIGNsaWVudHMuIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LiBBbGlhcyBvZiB7QGxpbmsgc2VuZH0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICB3cml0ZSguLi5hcmdzKSB7XG4gICAgICAgIC8vIFRoaXMgdHlwZS1jYXN0IGlzIG5lZWRlZCBiZWNhdXNlIEVtaXRFdmVudHMgbGlrZWx5IGRvZXNuJ3QgaGF2ZSBgbWVzc2FnZWAgYXMgYSBrZXkuXG4gICAgICAgIC8vIGlmIHlvdSBzcGVjaWZ5IHRoZSBFbWl0RXZlbnRzLCB0aGUgdHlwZSBvZiBhcmdzIHdpbGwgYmUgbmV2ZXIuXG4gICAgICAgIHRoaXMuZW1pdChcIm1lc3NhZ2VcIiwgLi4uYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIG90aGVyIFNvY2tldC5JTyBzZXJ2ZXJzIG9mIHRoZSBjbHVzdGVyLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIG15TmFtZXNwYWNlLnNlcnZlclNpZGVFbWl0KFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAgICAgKlxuICAgICAqIG15TmFtZXNwYWNlLm9uKFwiaGVsbG9cIiwgKGFyZzEpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGFyZzEpOyAvLyBwcmludHMgXCJ3b3JsZFwiXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBhY2tub3dsZWRnZW1lbnRzICh3aXRob3V0IGJpbmFyeSBjb250ZW50KSBhcmUgc3VwcG9ydGVkIHRvbzpcbiAgICAgKiBteU5hbWVzcGFjZS5zZXJ2ZXJTaWRlRW1pdChcInBpbmdcIiwgKGVyciwgcmVzcG9uc2VzKSA9PiB7XG4gICAgICogIGlmIChlcnIpIHtcbiAgICAgKiAgICAgLy8gc29tZSBzZXJ2ZXJzIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgfSBlbHNlIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzcG9uc2VzKTsgLy8gb25lIHJlc3BvbnNlIHBlciBzZXJ2ZXIgKGV4Y2VwdCB0aGUgY3VycmVudCBvbmUpXG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBteU5hbWVzcGFjZS5vbihcInBpbmdcIiwgKGNiKSA9PiB7XG4gICAgICogICBjYihcInBvbmdcIik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgLSB0aGUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIC0gYW4gYXJyYXkgb2YgYXJndW1lbnRzLCB3aGljaCBtYXkgaW5jbHVkZSBhbiBhY2tub3dsZWRnZW1lbnQgY2FsbGJhY2sgYXQgdGhlIGVuZFxuICAgICAqL1xuICAgIHNlcnZlclNpZGVFbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIGlmIChleHBvcnRzLlJFU0VSVkVEX0VWRU5UUy5oYXMoZXYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtTdHJpbmcoZXYpfVwiIGlzIGEgcmVzZXJ2ZWQgZXZlbnQgbmFtZWApO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MudW5zaGlmdChldik7XG4gICAgICAgIHRoaXMuYWRhcHRlci5zZXJ2ZXJTaWRlRW1pdChhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSBhbmQgZXhwZWN0IGFuIGFja25vd2xlZGdlbWVudCBmcm9tIHRoZSBvdGhlciBTb2NrZXQuSU8gc2VydmVycyBvZiB0aGUgY2x1c3Rlci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiB0cnkge1xuICAgICAqICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgbXlOYW1lc3BhY2Uuc2VydmVyU2lkZUVtaXRXaXRoQWNrKFwicGluZ1wiKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHJlc3BvbnNlcyk7IC8vIG9uZSByZXNwb25zZSBwZXIgc2VydmVyIChleGNlcHQgdGhlIGN1cnJlbnQgb25lKVxuICAgICAqIH0gY2F0Y2ggKGUpIHtcbiAgICAgKiAgIC8vIHNvbWUgc2VydmVycyBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgLSB0aGUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIC0gYW4gYXJyYXkgb2YgYXJndW1lbnRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gYWxsIHNlcnZlcnMgaGF2ZSBhY2tub3dsZWRnZWQgdGhlIGV2ZW50XG4gICAgICovXG4gICAgc2VydmVyU2lkZUVtaXRXaXRoQWNrKGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBhcmdzLnB1c2goKGVyciwgcmVzcG9uc2VzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBlcnIucmVzcG9uc2VzID0gcmVzcG9uc2VzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXNwb25zZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJTaWRlRW1pdChldiwgLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHBhY2tldCBpcyByZWNlaXZlZCBmcm9tIGFub3RoZXIgU29ja2V0LklPIHNlcnZlclxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBhbiBhcnJheSBvZiBhcmd1bWVudHMsIHdoaWNoIG1heSBpbmNsdWRlIGFuIGFja25vd2xlZGdlbWVudCBjYWxsYmFjayBhdCB0aGUgZW5kXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblNlcnZlclNpZGVFbWl0KGFyZ3MpIHtcbiAgICAgICAgc3VwZXIuZW1pdFVudHlwZWQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBsaXN0IG9mIGNsaWVudHMuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCB0aGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZSwgcGxlYXNlIHVzZSB7QGxpbmsgTmFtZXNwYWNlI3NlcnZlclNpZGVFbWl0fSBvclxuICAgICAqIHtAbGluayBOYW1lc3BhY2UjZmV0Y2hTb2NrZXRzfSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFsbFNvY2tldHMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5hbGxTb2NrZXRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogbXlOYW1lc3BhY2UuY29tcHJlc3MoZmFsc2UpLmVtaXQoXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21wcmVzcyAtIGlmIGB0cnVlYCwgY29tcHJlc3NlcyB0aGUgc2VuZGluZyBkYXRhXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgY29tcHJlc3MoY29tcHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLmNvbXByZXNzKGNvbXByZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSBtYXkgYmUgbG9zdCBpZiB0aGUgY2xpZW50IGlzIG5vdCByZWFkeSB0b1xuICAgICAqIHJlY2VpdmUgbWVzc2FnZXMgKGJlY2F1c2Ugb2YgbmV0d29yayBzbG93bmVzcyBvciBvdGhlciBpc3N1ZXMsIG9yIGJlY2F1c2UgdGhleeKAmXJlIGNvbm5lY3RlZCB0aHJvdWdoIGxvbmcgcG9sbGluZ1xuICAgICAqIGFuZCBpcyBpbiB0aGUgbWlkZGxlIG9mIGEgcmVxdWVzdC1yZXNwb25zZSBjeWNsZSkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogbXlOYW1lc3BhY2Uudm9sYXRpbGUuZW1pdChcImhlbGxvXCIpOyAvLyB0aGUgY2xpZW50cyBtYXkgb3IgbWF5IG5vdCByZWNlaXZlIGl0XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBnZXQgdm9sYXRpbGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS52b2xhdGlsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSB3aWxsIG9ubHkgYmUgYnJvYWRjYXN0IHRvIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogLy8gdGhlIOKAnGZvb+KAnSBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMgb24gdGhpcyBub2RlXG4gICAgICogbXlOYW1lc3BhY2UubG9jYWwuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBnZXQgbG9jYWwoKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5sb2NhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgbmV4dCBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogbXlOYW1lc3BhY2UudGltZW91dCgxMDAwKS5lbWl0KFwic29tZS1ldmVudFwiLCAoZXJyLCByZXNwb25zZXMpID0+IHtcbiAgICAgKiAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgLy8gc29tZSBjbGllbnRzIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgfSBlbHNlIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzcG9uc2VzKTsgLy8gb25lIHJlc3BvbnNlIHBlciBjbGllbnRcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lb3V0XG4gICAgICovXG4gICAgdGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS50aW1lb3V0KHRpbWVvdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogLy8gcmV0dXJuIGFsbCBTb2NrZXQgaW5zdGFuY2VzXG4gICAgICogY29uc3Qgc29ja2V0cyA9IGF3YWl0IG15TmFtZXNwYWNlLmZldGNoU29ja2V0cygpO1xuICAgICAqXG4gICAgICogLy8gcmV0dXJuIGFsbCBTb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbVxuICAgICAqIGNvbnN0IHNvY2tldHMgPSBhd2FpdCBteU5hbWVzcGFjZS5pbihcInJvb20xXCIpLmZldGNoU29ja2V0cygpO1xuICAgICAqXG4gICAgICogZm9yIChjb25zdCBzb2NrZXQgb2Ygc29ja2V0cykge1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmlkKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5oYW5kc2hha2UpO1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LnJvb21zKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5kYXRhKTtcbiAgICAgKlxuICAgICAqICAgc29ja2V0LmVtaXQoXCJoZWxsb1wiKTtcbiAgICAgKiAgIHNvY2tldC5qb2luKFwicm9vbTFcIik7XG4gICAgICogICBzb2NrZXQubGVhdmUoXCJyb29tMlwiKTtcbiAgICAgKiAgIHNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICogfVxuICAgICAqL1xuICAgIGZldGNoU29ja2V0cygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLmZldGNoU29ja2V0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBqb2luIHRoZSBzcGVjaWZpZWQgcm9vbXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIHdpdGhpbiBhIGNsdXN0ZXIgb2YgbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBBZGFwdGVyfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGpvaW4gdGhlIFwicm9vbTFcIiByb29tXG4gICAgICogbXlOYW1lc3BhY2Uuc29ja2V0c0pvaW4oXCJyb29tMVwiKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tIGpvaW4gdGhlIFwicm9vbTJcIiBhbmQgXCJyb29tM1wiIHJvb21zXG4gICAgICogbXlOYW1lc3BhY2UuaW4oXCJyb29tMVwiKS5zb2NrZXRzSm9pbihbXCJyb29tMlwiLCBcInJvb20zXCJdKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqL1xuICAgIHNvY2tldHNKb2luKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLnNvY2tldHNKb2luKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBsZWF2ZSB0aGUgc3BlY2lmaWVkIHJvb21zLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBsZWF2ZSB0aGUgXCJyb29tMVwiIHJvb21cbiAgICAgKiBteU5hbWVzcGFjZS5zb2NrZXRzTGVhdmUoXCJyb29tMVwiKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tIGxlYXZlIHRoZSBcInJvb20yXCIgYW5kIFwicm9vbTNcIiByb29tc1xuICAgICAqIG15TmFtZXNwYWNlLmluKFwicm9vbTFcIikuc29ja2V0c0xlYXZlKFtcInJvb20yXCIsIFwicm9vbTNcIl0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICovXG4gICAgc29ja2V0c0xlYXZlKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLnNvY2tldHNMZWF2ZShyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgZGlzY29ubmVjdC5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgZGlzY29ubmVjdCAodGhlIGNvbm5lY3Rpb25zIG1pZ2h0IGJlIGtlcHQgYWxpdmUgZm9yIG90aGVyIG5hbWVzcGFjZXMpXG4gICAgICogbXlOYW1lc3BhY2UuZGlzY29ubmVjdFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tIGRpc2Nvbm5lY3QgYW5kIGNsb3NlIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25zXG4gICAgICogbXlOYW1lc3BhY2UuaW4oXCJyb29tMVwiKS5kaXNjb25uZWN0U29ja2V0cyh0cnVlKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbG9zZSAtIHdoZXRoZXIgdG8gY2xvc2UgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RTb2NrZXRzKGNsb3NlID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLmRpc2Nvbm5lY3RTb2NrZXRzKGNsb3NlKTtcbiAgICB9XG59XG5leHBvcnRzLk5hbWVzcGFjZSA9IE5hbWVzcGFjZTtcbiJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJOYW1lc3BhY2UiLCJSRVNFUlZFRF9FVkVOVFMiLCJzb2NrZXRfMSIsInJlcXVpcmUiLCJ0eXBlZF9ldmVudHNfMSIsImRlYnVnXzEiLCJicm9hZGNhc3Rfb3BlcmF0b3JfMSIsImRlYnVnIiwiZGVmYXVsdCIsIlNldCIsIlN0cmljdEV2ZW50RW1pdHRlciIsImNvbnN0cnVjdG9yIiwic2VydmVyIiwibmFtZSIsInNvY2tldHMiLCJNYXAiLCJfcHJlQ29ubmVjdFNvY2tldHMiLCJfZm5zIiwiX2lkcyIsIl9pbml0QWRhcHRlciIsImFkYXB0ZXIiLCJ1c2UiLCJmbiIsInB1c2giLCJydW4iLCJzb2NrZXQiLCJsZW5ndGgiLCJmbnMiLCJzbGljZSIsImkiLCJlcnIiLCJ0byIsInJvb20iLCJCcm9hZGNhc3RPcGVyYXRvciIsImluIiwiZXhjZXB0IiwiX2FkZCIsImNsaWVudCIsImF1dGgiLCJfYSIsIl9jcmVhdGVTb2NrZXQiLCJzZXQiLCJpZCIsIm9wdHMiLCJjb25uZWN0aW9uU3RhdGVSZWNvdmVyeSIsInNraXBNaWRkbGV3YXJlcyIsInJlY292ZXJlZCIsImNvbm4iLCJyZWFkeVN0YXRlIiwiX2RvQ29ubmVjdCIsInByb2Nlc3MiLCJuZXh0VGljayIsIl9jbGVhbnVwIiwicHJvdG9jb2wiLCJfZXJyb3IiLCJkYXRhIiwibWVzc2FnZSIsInNlc3Npb25JZCIsInBpZCIsIm9mZnNldCIsInNlc3Npb24iLCJyZXN0b3JlU2Vzc2lvbiIsImUiLCJzaWQiLCJTb2NrZXQiLCJkZWxldGUiLCJfb25jb25uZWN0IiwiZW1pdFJlc2VydmVkIiwiX3JlbW92ZSIsImVtaXQiLCJldiIsImFyZ3MiLCJzZW5kIiwid3JpdGUiLCJzZXJ2ZXJTaWRlRW1pdCIsImhhcyIsIkVycm9yIiwiU3RyaW5nIiwidW5zaGlmdCIsInNlcnZlclNpZGVFbWl0V2l0aEFjayIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVzcG9uc2VzIiwiX29uU2VydmVyU2lkZUVtaXQiLCJlbWl0VW50eXBlZCIsImFwcGx5IiwiYWxsU29ja2V0cyIsImNvbXByZXNzIiwidm9sYXRpbGUiLCJsb2NhbCIsInRpbWVvdXQiLCJmZXRjaFNvY2tldHMiLCJzb2NrZXRzSm9pbiIsInNvY2tldHNMZWF2ZSIsImRpc2Nvbm5lY3RTb2NrZXRzIiwiY2xvc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/namespace.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/parent-namespace.js":
/*!*********************************************************!*\
  !*** ./node_modules/socket.io/dist/parent-namespace.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ParentNamespace = void 0;\nconst namespace_1 = __webpack_require__(/*! ./namespace */ \"(rsc)/./node_modules/socket.io/dist/namespace.js\");\nconst socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/index.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst debug = (0, debug_1.default)(\"socket.io:parent-namespace\");\n/**\n * A parent namespace is a special {@link Namespace} that holds a list of child namespaces which were created either\n * with a regular expression or with a function.\n *\n * @example\n * const parentNamespace = io.of(/\\/dynamic-\\d+/);\n *\n * parentNamespace.on(\"connection\", (socket) => {\n *   const childNamespace = socket.nsp;\n * }\n *\n * // will reach all the clients that are in one of the child namespaces, like \"/dynamic-101\"\n * parentNamespace.emit(\"hello\", \"world\");\n *\n */ class ParentNamespace extends namespace_1.Namespace {\n    constructor(server){\n        super(server, \"/_\" + ParentNamespace.count++);\n        this.children = new Set();\n    }\n    /**\n     * @private\n     */ _initAdapter() {\n        this.adapter = new ParentBroadcastAdapter(this);\n    }\n    emit(ev, ...args) {\n        this.children.forEach((nsp)=>{\n            nsp.emit(ev, ...args);\n        });\n        return true;\n    }\n    createChild(name) {\n        debug(\"creating child namespace %s\", name);\n        const namespace = new namespace_1.Namespace(this.server, name);\n        this[\"_fns\"].forEach((fn)=>namespace.use(fn));\n        this.listeners(\"connect\").forEach((listener)=>namespace.on(\"connect\", listener));\n        this.listeners(\"connection\").forEach((listener)=>namespace.on(\"connection\", listener));\n        this.children.add(namespace);\n        if (this.server._opts.cleanupEmptyChildNamespaces) {\n            const remove = namespace._remove;\n            namespace._remove = (socket)=>{\n                remove.call(namespace, socket);\n                if (namespace.sockets.size === 0) {\n                    debug(\"closing child namespace %s\", name);\n                    namespace.adapter.close();\n                    this.server._nsps.delete(namespace.name);\n                    this.children.delete(namespace);\n                }\n            };\n        }\n        this.server._nsps.set(name, namespace);\n        // @ts-ignore\n        this.server.sockets.emitReserved(\"new_namespace\", namespace);\n        return namespace;\n    }\n    fetchSockets() {\n        // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\n        // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\n        // the behavior for namespaces created with a function is less clear\n        // note: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\n        // may exist on one node but not exist on another (since it is created upon client connection)\n        throw new Error(\"fetchSockets() is not supported on parent namespaces\");\n    }\n}\nexports.ParentNamespace = ParentNamespace;\nParentNamespace.count = 0;\n/**\n * A dummy adapter that only supports broadcasting to child (concrete) namespaces.\n * @private file\n */ class ParentBroadcastAdapter extends socket_io_adapter_1.Adapter {\n    broadcast(packet, opts) {\n        this.nsp.children.forEach((nsp)=>{\n            nsp.adapter.broadcast(packet, opts);\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvcGFyZW50LW5hbWVzcGFjZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHVCQUF1QixHQUFHLEtBQUs7QUFDL0IsTUFBTUcsY0FBY0MsbUJBQU9BLENBQUMscUVBQWE7QUFDekMsTUFBTUMsc0JBQXNCRCxtQkFBT0EsQ0FBQywrRUFBbUI7QUFDdkQsTUFBTUUsVUFBVVgsZ0JBQWdCUyxtQkFBT0EsQ0FBQyw2RUFBTztBQUMvQyxNQUFNRyxRQUFRLENBQUMsR0FBR0QsUUFBUUUsT0FBTyxFQUFFO0FBQ25DOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ0QsTUFBTU4sd0JBQXdCQyxZQUFZTSxTQUFTO0lBQy9DQyxZQUFZQyxNQUFNLENBQUU7UUFDaEIsS0FBSyxDQUFDQSxRQUFRLE9BQU9ULGdCQUFnQlUsS0FBSztRQUMxQyxJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJQztJQUN4QjtJQUNBOztLQUVDLEdBQ0RDLGVBQWU7UUFDWCxJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJQyx1QkFBdUIsSUFBSTtJQUNsRDtJQUNBQyxLQUFLQyxFQUFFLEVBQUUsR0FBR0MsSUFBSSxFQUFFO1FBQ2QsSUFBSSxDQUFDUCxRQUFRLENBQUNRLE9BQU8sQ0FBQyxDQUFDQztZQUNuQkEsSUFBSUosSUFBSSxDQUFDQyxPQUFPQztRQUNwQjtRQUNBLE9BQU87SUFDWDtJQUNBRyxZQUFZQyxJQUFJLEVBQUU7UUFDZGpCLE1BQU0sK0JBQStCaUI7UUFDckMsTUFBTUMsWUFBWSxJQUFJdEIsWUFBWU0sU0FBUyxDQUFDLElBQUksQ0FBQ0UsTUFBTSxFQUFFYTtRQUN6RCxJQUFJLENBQUMsT0FBTyxDQUFDSCxPQUFPLENBQUMsQ0FBQ0ssS0FBT0QsVUFBVUUsR0FBRyxDQUFDRDtRQUMzQyxJQUFJLENBQUNFLFNBQVMsQ0FBQyxXQUFXUCxPQUFPLENBQUMsQ0FBQ1EsV0FBYUosVUFBVUssRUFBRSxDQUFDLFdBQVdEO1FBQ3hFLElBQUksQ0FBQ0QsU0FBUyxDQUFDLGNBQWNQLE9BQU8sQ0FBQyxDQUFDUSxXQUFhSixVQUFVSyxFQUFFLENBQUMsY0FBY0Q7UUFDOUUsSUFBSSxDQUFDaEIsUUFBUSxDQUFDa0IsR0FBRyxDQUFDTjtRQUNsQixJQUFJLElBQUksQ0FBQ2QsTUFBTSxDQUFDcUIsS0FBSyxDQUFDQywyQkFBMkIsRUFBRTtZQUMvQyxNQUFNQyxTQUFTVCxVQUFVVSxPQUFPO1lBQ2hDVixVQUFVVSxPQUFPLEdBQUcsQ0FBQ0M7Z0JBQ2pCRixPQUFPRyxJQUFJLENBQUNaLFdBQVdXO2dCQUN2QixJQUFJWCxVQUFVYSxPQUFPLENBQUNDLElBQUksS0FBSyxHQUFHO29CQUM5QmhDLE1BQU0sOEJBQThCaUI7b0JBQ3BDQyxVQUFVVCxPQUFPLENBQUN3QixLQUFLO29CQUN2QixJQUFJLENBQUM3QixNQUFNLENBQUM4QixLQUFLLENBQUNDLE1BQU0sQ0FBQ2pCLFVBQVVELElBQUk7b0JBQ3ZDLElBQUksQ0FBQ1gsUUFBUSxDQUFDNkIsTUFBTSxDQUFDakI7Z0JBQ3pCO1lBQ0o7UUFDSjtRQUNBLElBQUksQ0FBQ2QsTUFBTSxDQUFDOEIsS0FBSyxDQUFDRSxHQUFHLENBQUNuQixNQUFNQztRQUM1QixhQUFhO1FBQ2IsSUFBSSxDQUFDZCxNQUFNLENBQUMyQixPQUFPLENBQUNNLFlBQVksQ0FBQyxpQkFBaUJuQjtRQUNsRCxPQUFPQTtJQUNYO0lBQ0FvQixlQUFlO1FBQ1gsaUhBQWlIO1FBQ2pILCtHQUErRztRQUMvRyxvRUFBb0U7UUFDcEUsaUhBQWlIO1FBQ2pILDhGQUE4RjtRQUM5RixNQUFNLElBQUlDLE1BQU07SUFDcEI7QUFDSjtBQUNBOUMsdUJBQXVCLEdBQUdFO0FBQzFCQSxnQkFBZ0JVLEtBQUssR0FBRztBQUN4Qjs7O0NBR0MsR0FDRCxNQUFNSywrQkFBK0JaLG9CQUFvQjBDLE9BQU87SUFDNURDLFVBQVVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFO1FBQ3BCLElBQUksQ0FBQzVCLEdBQUcsQ0FBQ1QsUUFBUSxDQUFDUSxPQUFPLENBQUMsQ0FBQ0M7WUFDdkJBLElBQUlOLE9BQU8sQ0FBQ2dDLFNBQVMsQ0FBQ0MsUUFBUUM7UUFDbEM7SUFDSjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmlydmFhbmFhLWVjb21tZXJjZS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9wYXJlbnQtbmFtZXNwYWNlLmpzP2VkYWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhcmVudE5hbWVzcGFjZSA9IHZvaWQgMDtcbmNvbnN0IG5hbWVzcGFjZV8xID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpO1xuY29uc3Qgc29ja2V0X2lvX2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCJzb2NrZXQuaW8tYWRhcHRlclwiKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJzb2NrZXQuaW86cGFyZW50LW5hbWVzcGFjZVwiKTtcbi8qKlxuICogQSBwYXJlbnQgbmFtZXNwYWNlIGlzIGEgc3BlY2lhbCB7QGxpbmsgTmFtZXNwYWNlfSB0aGF0IGhvbGRzIGEgbGlzdCBvZiBjaGlsZCBuYW1lc3BhY2VzIHdoaWNoIHdlcmUgY3JlYXRlZCBlaXRoZXJcbiAqIHdpdGggYSByZWd1bGFyIGV4cHJlc3Npb24gb3Igd2l0aCBhIGZ1bmN0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBwYXJlbnROYW1lc3BhY2UgPSBpby5vZigvXFwvZHluYW1pYy1cXGQrLyk7XG4gKlxuICogcGFyZW50TmFtZXNwYWNlLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gKiAgIGNvbnN0IGNoaWxkTmFtZXNwYWNlID0gc29ja2V0Lm5zcDtcbiAqIH1cbiAqXG4gKiAvLyB3aWxsIHJlYWNoIGFsbCB0aGUgY2xpZW50cyB0aGF0IGFyZSBpbiBvbmUgb2YgdGhlIGNoaWxkIG5hbWVzcGFjZXMsIGxpa2UgXCIvZHluYW1pYy0xMDFcIlxuICogcGFyZW50TmFtZXNwYWNlLmVtaXQoXCJoZWxsb1wiLCBcIndvcmxkXCIpO1xuICpcbiAqL1xuY2xhc3MgUGFyZW50TmFtZXNwYWNlIGV4dGVuZHMgbmFtZXNwYWNlXzEuTmFtZXNwYWNlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXIpIHtcbiAgICAgICAgc3VwZXIoc2VydmVyLCBcIi9fXCIgKyBQYXJlbnROYW1lc3BhY2UuY291bnQrKyk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRBZGFwdGVyKCkge1xuICAgICAgICB0aGlzLmFkYXB0ZXIgPSBuZXcgUGFyZW50QnJvYWRjYXN0QWRhcHRlcih0aGlzKTtcbiAgICB9XG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKG5zcCkgPT4ge1xuICAgICAgICAgICAgbnNwLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNyZWF0ZUNoaWxkKG5hbWUpIHtcbiAgICAgICAgZGVidWcoXCJjcmVhdGluZyBjaGlsZCBuYW1lc3BhY2UgJXNcIiwgbmFtZSk7XG4gICAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IG5ldyBuYW1lc3BhY2VfMS5OYW1lc3BhY2UodGhpcy5zZXJ2ZXIsIG5hbWUpO1xuICAgICAgICB0aGlzW1wiX2Zuc1wiXS5mb3JFYWNoKChmbikgPT4gbmFtZXNwYWNlLnVzZShmbikpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyhcImNvbm5lY3RcIikuZm9yRWFjaCgobGlzdGVuZXIpID0+IG5hbWVzcGFjZS5vbihcImNvbm5lY3RcIiwgbGlzdGVuZXIpKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMoXCJjb25uZWN0aW9uXCIpLmZvckVhY2goKGxpc3RlbmVyKSA9PiBuYW1lc3BhY2Uub24oXCJjb25uZWN0aW9uXCIsIGxpc3RlbmVyKSk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uYWRkKG5hbWVzcGFjZSk7XG4gICAgICAgIGlmICh0aGlzLnNlcnZlci5fb3B0cy5jbGVhbnVwRW1wdHlDaGlsZE5hbWVzcGFjZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZSA9IG5hbWVzcGFjZS5fcmVtb3ZlO1xuICAgICAgICAgICAgbmFtZXNwYWNlLl9yZW1vdmUgPSAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlLmNhbGwobmFtZXNwYWNlLCBzb2NrZXQpO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lc3BhY2Uuc29ja2V0cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiY2xvc2luZyBjaGlsZCBuYW1lc3BhY2UgJXNcIiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZS5hZGFwdGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyLl9uc3BzLmRlbGV0ZShuYW1lc3BhY2UubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZGVsZXRlKG5hbWVzcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcnZlci5fbnNwcy5zZXQobmFtZSwgbmFtZXNwYWNlKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLnNlcnZlci5zb2NrZXRzLmVtaXRSZXNlcnZlZChcIm5ld19uYW1lc3BhY2VcIiwgbmFtZXNwYWNlKTtcbiAgICAgICAgcmV0dXJuIG5hbWVzcGFjZTtcbiAgICB9XG4gICAgZmV0Y2hTb2NrZXRzKCkge1xuICAgICAgICAvLyBub3RlOiB3ZSBjb3VsZCBtYWtlIHRoZSBmZXRjaFNvY2tldHMoKSBtZXRob2Qgd29yayBmb3IgZHluYW1pYyBuYW1lc3BhY2VzIGNyZWF0ZWQgd2l0aCBhIHJlZ2V4IChieSBzZW5kaW5nIHRoZVxuICAgICAgICAvLyByZWdleCB0byB0aGUgb3RoZXIgU29ja2V0LklPIHNlcnZlcnMsIGFuZCByZXR1cm5pbmcgdGhlIHNvY2tldHMgb2YgZWFjaCBtYXRjaGluZyBuYW1lc3BhY2UgZm9yIGV4YW1wbGUpLCBidXRcbiAgICAgICAgLy8gdGhlIGJlaGF2aW9yIGZvciBuYW1lc3BhY2VzIGNyZWF0ZWQgd2l0aCBhIGZ1bmN0aW9uIGlzIGxlc3MgY2xlYXJcbiAgICAgICAgLy8gbm90ZcKyOiB3ZSBjYW5ub3QgbG9vcCBvdmVyIGVhY2ggY2hpbGRyZW4gbmFtZXNwYWNlLCBiZWNhdXNlIHdpdGggbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIGEgZ2l2ZW4gbmFtZXNwYWNlXG4gICAgICAgIC8vIG1heSBleGlzdCBvbiBvbmUgbm9kZSBidXQgbm90IGV4aXN0IG9uIGFub3RoZXIgKHNpbmNlIGl0IGlzIGNyZWF0ZWQgdXBvbiBjbGllbnQgY29ubmVjdGlvbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmV0Y2hTb2NrZXRzKCkgaXMgbm90IHN1cHBvcnRlZCBvbiBwYXJlbnQgbmFtZXNwYWNlc1wiKTtcbiAgICB9XG59XG5leHBvcnRzLlBhcmVudE5hbWVzcGFjZSA9IFBhcmVudE5hbWVzcGFjZTtcblBhcmVudE5hbWVzcGFjZS5jb3VudCA9IDA7XG4vKipcbiAqIEEgZHVtbXkgYWRhcHRlciB0aGF0IG9ubHkgc3VwcG9ydHMgYnJvYWRjYXN0aW5nIHRvIGNoaWxkIChjb25jcmV0ZSkgbmFtZXNwYWNlcy5cbiAqIEBwcml2YXRlIGZpbGVcbiAqL1xuY2xhc3MgUGFyZW50QnJvYWRjYXN0QWRhcHRlciBleHRlbmRzIHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlciB7XG4gICAgYnJvYWRjYXN0KHBhY2tldCwgb3B0cykge1xuICAgICAgICB0aGlzLm5zcC5jaGlsZHJlbi5mb3JFYWNoKChuc3ApID0+IHtcbiAgICAgICAgICAgIG5zcC5hZGFwdGVyLmJyb2FkY2FzdChwYWNrZXQsIG9wdHMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUGFyZW50TmFtZXNwYWNlIiwibmFtZXNwYWNlXzEiLCJyZXF1aXJlIiwic29ja2V0X2lvX2FkYXB0ZXJfMSIsImRlYnVnXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJOYW1lc3BhY2UiLCJjb25zdHJ1Y3RvciIsInNlcnZlciIsImNvdW50IiwiY2hpbGRyZW4iLCJTZXQiLCJfaW5pdEFkYXB0ZXIiLCJhZGFwdGVyIiwiUGFyZW50QnJvYWRjYXN0QWRhcHRlciIsImVtaXQiLCJldiIsImFyZ3MiLCJmb3JFYWNoIiwibnNwIiwiY3JlYXRlQ2hpbGQiLCJuYW1lIiwibmFtZXNwYWNlIiwiZm4iLCJ1c2UiLCJsaXN0ZW5lcnMiLCJsaXN0ZW5lciIsIm9uIiwiYWRkIiwiX29wdHMiLCJjbGVhbnVwRW1wdHlDaGlsZE5hbWVzcGFjZXMiLCJyZW1vdmUiLCJfcmVtb3ZlIiwic29ja2V0IiwiY2FsbCIsInNvY2tldHMiLCJzaXplIiwiY2xvc2UiLCJfbnNwcyIsImRlbGV0ZSIsInNldCIsImVtaXRSZXNlcnZlZCIsImZldGNoU29ja2V0cyIsIkVycm9yIiwiQWRhcHRlciIsImJyb2FkY2FzdCIsInBhY2tldCIsIm9wdHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/parent-namespace.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/socket-types.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io/dist/socket-types.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RESERVED_EVENTS = void 0;\nexports.RESERVED_EVENTS = new Set([\n    \"connect\",\n    \"connect_error\",\n    \"disconnect\",\n    \"disconnecting\",\n    \"newListener\",\n    \"removeListener\"\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3Qvc29ja2V0LXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx1QkFBdUIsR0FBRyxLQUFLO0FBQy9CQSx1QkFBdUIsR0FBRyxJQUFJRyxJQUFJO0lBQzlCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmlydmFhbmFhLWVjb21tZXJjZS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9zb2NrZXQtdHlwZXMuanM/YzBkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUkVTRVJWRURfRVZFTlRTID0gdm9pZCAwO1xuZXhwb3J0cy5SRVNFUlZFRF9FVkVOVFMgPSBuZXcgU2V0KFtcbiAgICBcImNvbm5lY3RcIixcbiAgICBcImNvbm5lY3RfZXJyb3JcIixcbiAgICBcImRpc2Nvbm5lY3RcIixcbiAgICBcImRpc2Nvbm5lY3RpbmdcIixcbiAgICBcIm5ld0xpc3RlbmVyXCIsXG4gICAgXCJyZW1vdmVMaXN0ZW5lclwiLFxuXSk7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSRVNFUlZFRF9FVkVOVFMiLCJTZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/socket-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/socket.js":
/*!***********************************************!*\
  !*** ./node_modules/socket.io/dist/socket.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Socket = void 0;\nconst socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ \"(rsc)/./node_modules/socket.io-parser/build/cjs/index.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst typed_events_1 = __webpack_require__(/*! ./typed-events */ \"(rsc)/./node_modules/socket.io/dist/typed-events.js\");\nconst base64id_1 = __importDefault(__webpack_require__(/*! base64id */ \"(rsc)/./node_modules/base64id/lib/base64id.js\"));\nconst broadcast_operator_1 = __webpack_require__(/*! ./broadcast-operator */ \"(rsc)/./node_modules/socket.io/dist/broadcast-operator.js\");\nconst socket_types_1 = __webpack_require__(/*! ./socket-types */ \"(rsc)/./node_modules/socket.io/dist/socket-types.js\");\nconst debug = (0, debug_1.default)(\"socket.io:socket\");\nconst RECOVERABLE_DISCONNECT_REASONS = new Set([\n    \"transport error\",\n    \"transport close\",\n    \"forced close\",\n    \"ping timeout\",\n    \"server shutting down\",\n    \"forced server close\"\n]);\nfunction noop() {}\n/**\n * This is the main object for interacting with a client.\n *\n * A Socket belongs to a given {@link Namespace} and uses an underlying {@link Client} to communicate.\n *\n * Within each {@link Namespace}, you can also define arbitrary channels (called \"rooms\") that the {@link Socket} can\n * join and leave. That provides a convenient way to broadcast to a group of socket instances.\n *\n * @example\n * io.on(\"connection\", (socket) => {\n *   console.log(`socket ${socket.id} connected`);\n *\n *   // send an event to the client\n *   socket.emit(\"foo\", \"bar\");\n *\n *   socket.on(\"foobar\", () => {\n *     // an event was received from the client\n *   });\n *\n *   // join the room named \"room1\"\n *   socket.join(\"room1\");\n *\n *   // broadcast to everyone in the room named \"room1\"\n *   io.to(\"room1\").emit(\"hello\");\n *\n *   // upon disconnection\n *   socket.on(\"disconnect\", (reason) => {\n *     console.log(`socket ${socket.id} disconnected due to ${reason}`);\n *   });\n * });\n */ class Socket extends typed_events_1.StrictEventEmitter {\n    /**\n     * Interface to a `Client` for a given `Namespace`.\n     *\n     * @param {Namespace} nsp\n     * @param {Client} client\n     * @param {Object} auth\n     * @package\n     */ constructor(nsp, client, auth, previousSession){\n        super();\n        this.nsp = nsp;\n        this.client = client;\n        /**\n         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\n         * be transmitted to the client, the data attribute and the rooms will be restored.\n         */ this.recovered = false;\n        /**\n         * Additional information that can be attached to the Socket instance and which will be used in the\n         * {@link Server.fetchSockets()} method.\n         */ this.data = {};\n        /**\n         * Whether the socket is currently connected or not.\n         *\n         * @example\n         * io.use((socket, next) => {\n         *   console.log(socket.connected); // false\n         *   next();\n         * });\n         *\n         * io.on(\"connection\", (socket) => {\n         *   console.log(socket.connected); // true\n         * });\n         */ this.connected = false;\n        this.acks = new Map();\n        this.fns = [];\n        this.flags = {};\n        this.server = nsp.server;\n        this.adapter = this.nsp.adapter;\n        if (previousSession) {\n            this.id = previousSession.sid;\n            this.pid = previousSession.pid;\n            previousSession.rooms.forEach((room)=>this.join(room));\n            this.data = previousSession.data;\n            previousSession.missedPackets.forEach((packet)=>{\n                this.packet({\n                    type: socket_io_parser_1.PacketType.EVENT,\n                    data: packet\n                });\n            });\n            this.recovered = true;\n        } else {\n            if (client.conn.protocol === 3) {\n                // @ts-ignore\n                this.id = nsp.name !== \"/\" ? nsp.name + \"#\" + client.id : client.id;\n            } else {\n                this.id = base64id_1.default.generateId(); // don't reuse the Engine.IO id because it's sensitive information\n            }\n            if (this.server._opts.connectionStateRecovery) {\n                this.pid = base64id_1.default.generateId();\n            }\n        }\n        this.handshake = this.buildHandshake(auth);\n        // prevents crash when the socket receives an \"error\" event without listener\n        this.on(\"error\", noop);\n    }\n    /**\n     * Builds the `handshake` BC object\n     *\n     * @private\n     */ buildHandshake(auth) {\n        var _a, _b, _c, _d;\n        return {\n            headers: ((_a = this.request) === null || _a === void 0 ? void 0 : _a.headers) || {},\n            time: new Date() + \"\",\n            address: this.conn.remoteAddress,\n            xdomain: !!((_b = this.request) === null || _b === void 0 ? void 0 : _b.headers.origin),\n            // @ts-ignore\n            secure: !this.request || !!this.request.connection.encrypted,\n            issued: +new Date(),\n            url: (_c = this.request) === null || _c === void 0 ? void 0 : _c.url,\n            // @ts-ignore\n            query: ((_d = this.request) === null || _d === void 0 ? void 0 : _d._query) || {},\n            auth\n        };\n    }\n    /**\n     * Emits to this client.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.emit(\"hello\", \"world\");\n     *\n     *   // all serializable datastructures are supported (no need to call JSON.stringify)\n     *   socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Buffer.from([6]) });\n     *\n     *   // with an acknowledgement from the client\n     *   socket.emit(\"hello\", \"world\", (val) => {\n     *     // ...\n     *   });\n     * });\n     *\n     * @return Always returns `true`.\n     */ emit(ev, ...args) {\n        if (socket_types_1.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${String(ev)}\" is a reserved event name`);\n        }\n        const data = [\n            ev,\n            ...args\n        ];\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: data\n        };\n        // access last argument to see if it's an ACK callback\n        if (typeof data[data.length - 1] === \"function\") {\n            const id = this.nsp._ids++;\n            debug(\"emitting packet with ack id %d\", id);\n            this.registerAckCallback(id, data.pop());\n            packet.id = id;\n        }\n        const flags = Object.assign({}, this.flags);\n        this.flags = {};\n        // @ts-ignore\n        if (this.nsp.server.opts.connectionStateRecovery) {\n            // this ensures the packet is stored and can be transmitted upon reconnection\n            this.adapter.broadcast(packet, {\n                rooms: new Set([\n                    this.id\n                ]),\n                except: new Set(),\n                flags\n            });\n        } else {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet, flags);\n        }\n        return true;\n    }\n    /**\n     * Emits an event and waits for an acknowledgement\n     *\n     * @example\n     * io.on(\"connection\", async (socket) => {\n     *   // without timeout\n     *   const response = await socket.emitWithAck(\"hello\", \"world\");\n     *\n     *   // with a specific timeout\n     *   try {\n     *     const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n     *   } catch (err) {\n     *     // the client did not acknowledge the event in the given delay\n     *   }\n     * });\n     *\n     * @return a Promise that will be fulfilled when the client acknowledges the event\n     */ emitWithAck(ev, ...args) {\n        // the timeout flag is optional\n        const withErr = this.flags.timeout !== undefined;\n        return new Promise((resolve, reject)=>{\n            args.push((arg1, arg2)=>{\n                if (withErr) {\n                    return arg1 ? reject(arg1) : resolve(arg2);\n                } else {\n                    return resolve(arg1);\n                }\n            });\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * @private\n     */ registerAckCallback(id, ack) {\n        const timeout = this.flags.timeout;\n        if (timeout === undefined) {\n            this.acks.set(id, ack);\n            return;\n        }\n        const timer = setTimeout(()=>{\n            debug(\"event with ack id %d has timed out after %d ms\", id, timeout);\n            this.acks.delete(id);\n            ack.call(this, new Error(\"operation has timed out\"));\n        }, timeout);\n        this.acks.set(id, (...args)=>{\n            clearTimeout(timer);\n            ack.apply(this, [\n                null,\n                ...args\n            ]);\n        });\n    }\n    /**\n     * Targets a room when broadcasting.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the foo event will be broadcast to all connected clients in the room-101 room, except this socket\n     *   socket.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     *   // the code above is equivalent to:\n     *   io.to(\"room-101\").except(socket.id).emit(\"foo\", \"bar\");\n     *\n     *   // with an array of rooms (a client will be notified at most once)\n     *   socket.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     *   // with multiple chained calls\n     *   socket.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ to(room) {\n        return this.newBroadcastOperator().to(room);\n    }\n    /**\n     * Targets a room when broadcasting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // disconnect all clients in the \"room-101\" room, except this socket\n     *   socket.in(\"room-101\").disconnectSockets();\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ in(room) {\n        return this.newBroadcastOperator().in(room);\n    }\n    /**\n     * Excludes a room when broadcasting.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     *   // and this socket\n     *   socket.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     *   // with an array of rooms\n     *   socket.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     *   // with multiple chained calls\n     *   socket.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ except(room) {\n        return this.newBroadcastOperator().except(room);\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.send(\"hello\");\n     *\n     *   // this is equivalent to\n     *   socket.emit(\"message\", \"hello\");\n     * });\n     *\n     * @return self\n     */ send(...args) {\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a `message` event. Alias of {@link send}.\n     *\n     * @return self\n     */ write(...args) {\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param {Object} packet - packet object\n     * @param {Object} opts - options\n     * @private\n     */ packet(packet, opts = {}) {\n        packet.nsp = this.nsp.name;\n        opts.compress = false !== opts.compress;\n        this.client._packet(packet, opts);\n    }\n    /**\n     * Joins a room.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // join a single room\n     *   socket.join(\"room1\");\n     *\n     *   // join multiple rooms\n     *   socket.join([\"room1\", \"room2\"]);\n     * });\n     *\n     * @param {String|Array} rooms - room or array of rooms\n     * @return a Promise or nothing, depending on the adapter\n     */ join(rooms) {\n        debug(\"join room %s\", rooms);\n        return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [\n            rooms\n        ]));\n    }\n    /**\n     * Leaves a room.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // leave a single room\n     *   socket.leave(\"room1\");\n     *\n     *   // leave multiple rooms\n     *   socket.leave(\"room1\").leave(\"room2\");\n     * });\n     *\n     * @param {String} room\n     * @return a Promise or nothing, depending on the adapter\n     */ leave(room) {\n        debug(\"leave room %s\", room);\n        return this.adapter.del(this.id, room);\n    }\n    /**\n     * Leave all rooms.\n     *\n     * @private\n     */ leaveAll() {\n        this.adapter.delAll(this.id);\n    }\n    /**\n     * Called by `Namespace` upon successful\n     * middleware execution (ie: authorization).\n     * Socket is added to namespace array before\n     * call to join, so adapters can access it.\n     *\n     * @private\n     */ _onconnect() {\n        debug(\"socket connected - writing packet\");\n        this.connected = true;\n        this.join(this.id);\n        if (this.conn.protocol === 3) {\n            this.packet({\n                type: socket_io_parser_1.PacketType.CONNECT\n            });\n        } else {\n            this.packet({\n                type: socket_io_parser_1.PacketType.CONNECT,\n                data: {\n                    sid: this.id,\n                    pid: this.pid\n                }\n            });\n        }\n    }\n    /**\n     * Called with each packet. Called by `Client`.\n     *\n     * @param {Object} packet\n     * @private\n     */ _onpacket(packet) {\n        debug(\"got packet %j\", packet);\n        switch(packet.type){\n            case socket_io_parser_1.PacketType.EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n        }\n    }\n    /**\n     * Called upon event packet.\n     *\n     * @param {Packet} packet - packet object\n     * @private\n     */ onevent(packet) {\n        const args = packet.data || [];\n        debug(\"emitting event %j\", args);\n        if (null != packet.id) {\n            debug(\"attaching ack callback to event\");\n            args.push(this.ack(packet.id));\n        }\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners){\n                listener.apply(this, args);\n            }\n        }\n        this.dispatch(args);\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @param {Number} id - packet id\n     * @private\n     */ ack(id) {\n        const self = this;\n        let sent = false;\n        return function() {\n            // prevent double callbacks\n            if (sent) return;\n            const args = Array.prototype.slice.call(arguments);\n            debug(\"sending ack %j\", args);\n            self.packet({\n                id: id,\n                type: socket_io_parser_1.PacketType.ACK,\n                data: args\n            });\n            sent = true;\n        };\n    }\n    /**\n     * Called upon ack packet.\n     *\n     * @private\n     */ onack(packet) {\n        const ack = this.acks.get(packet.id);\n        if (\"function\" == typeof ack) {\n            debug(\"calling ack %s with %j\", packet.id, packet.data);\n            ack.apply(this, packet.data);\n            this.acks.delete(packet.id);\n        } else {\n            debug(\"bad ack %s\", packet.id);\n        }\n    }\n    /**\n     * Called upon client disconnect packet.\n     *\n     * @private\n     */ ondisconnect() {\n        debug(\"got disconnect packet\");\n        this._onclose(\"client namespace disconnect\");\n    }\n    /**\n     * Handles a client error.\n     *\n     * @private\n     */ _onerror(err) {\n        // FIXME the meaning of the \"error\" event is overloaded:\n        //  - it can be sent by the client (`socket.emit(\"error\")`)\n        //  - it can be emitted when the connection encounters an error (an invalid packet for example)\n        //  - it can be emitted when a packet is rejected in a middleware (`socket.use()`)\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Called upon closing. Called by `Client`.\n     *\n     * @param {String} reason\n     * @param description\n     * @throw {Error} optional error object\n     *\n     * @private\n     */ _onclose(reason, description) {\n        if (!this.connected) return this;\n        debug(\"closing socket - reason %s\", reason);\n        this.emitReserved(\"disconnecting\", reason, description);\n        if (this.server._opts.connectionStateRecovery && RECOVERABLE_DISCONNECT_REASONS.has(reason)) {\n            debug(\"connection state recovery is enabled for sid %s\", this.id);\n            this.adapter.persistSession({\n                sid: this.id,\n                pid: this.pid,\n                rooms: [\n                    ...this.rooms\n                ],\n                data: this.data\n            });\n        }\n        this._cleanup();\n        this.client._remove(this);\n        this.connected = false;\n        this.emitReserved(\"disconnect\", reason, description);\n        return;\n    }\n    /**\n     * Makes the socket leave all the rooms it was part of and prevents it from joining any other room\n     *\n     * @private\n     */ _cleanup() {\n        this.leaveAll();\n        this.nsp._remove(this);\n        this.join = noop;\n    }\n    /**\n     * Produces an `error` packet.\n     *\n     * @param {Object} err - error object\n     *\n     * @private\n     */ _error(err) {\n        this.packet({\n            type: socket_io_parser_1.PacketType.CONNECT_ERROR,\n            data: err\n        });\n    }\n    /**\n     * Disconnects this client.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // disconnect this socket (the connection might be kept alive for other namespaces)\n     *   socket.disconnect();\n     *\n     *   // disconnect this socket and close the underlying connection\n     *   socket.disconnect(true);\n     * })\n     *\n     * @param {Boolean} close - if `true`, closes the underlying connection\n     * @return self\n     */ disconnect(close = false) {\n        if (!this.connected) return this;\n        if (close) {\n            this.client._disconnect();\n        } else {\n            this.packet({\n                type: socket_io_parser_1.PacketType.DISCONNECT\n            });\n            this._onclose(\"server namespace disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.compress(false).emit(\"hello\");\n     * });\n     *\n     * @param {Boolean} compress - if `true`, compresses the sending data\n     * @return {Socket} self\n     */ compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because theyre connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.volatile.emit(\"hello\"); // the client may or may not receive it\n     * });\n     *\n     * @return {Socket} self\n     */ get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the\n     * sender.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the foo event will be broadcast to all connected clients, except this socket\n     *   socket.broadcast.emit(\"foo\", \"bar\");\n     * });\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ get broadcast() {\n        return this.newBroadcastOperator();\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the foo event will be broadcast to all connected clients on this node, except this socket\n     *   socket.local.emit(\"foo\", \"bar\");\n     * });\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ get local() {\n        return this.newBroadcastOperator().local;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n     * given number of milliseconds have elapsed without an acknowledgement from the client:\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.timeout(5000).emit(\"my-event\", (err) => {\n     *     if (err) {\n     *       // the client did not acknowledge the event in the given delay\n     *     }\n     *   });\n     * });\n     *\n     * @returns self\n     */ timeout(timeout) {\n        this.flags.timeout = timeout;\n        return this;\n    }\n    /**\n     * Dispatch incoming event to socket listeners.\n     *\n     * @param {Array} event - event that will get emitted\n     * @private\n     */ dispatch(event) {\n        debug(\"dispatching an event %j\", event);\n        this.run(event, (err)=>{\n            process.nextTick(()=>{\n                if (err) {\n                    return this._onerror(err);\n                }\n                if (this.connected) {\n                    super.emitUntyped.apply(this, event);\n                } else {\n                    debug(\"ignore packet received after disconnection\");\n                }\n            });\n        });\n    }\n    /**\n     * Sets up socket middleware.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.use(([event, ...args], next) => {\n     *     if (isUnauthorized(event)) {\n     *       return next(new Error(\"unauthorized event\"));\n     *     }\n     *     // do not forget to call next\n     *     next();\n     *   });\n     *\n     *   socket.on(\"error\", (err) => {\n     *     if (err && err.message === \"unauthorized event\") {\n     *       socket.disconnect();\n     *     }\n     *   });\n     * });\n     *\n     * @param {Function} fn - middleware function (event, next)\n     * @return {Socket} self\n     */ use(fn) {\n        this.fns.push(fn);\n        return this;\n    }\n    /**\n     * Executes the middleware for an incoming event.\n     *\n     * @param {Array} event - event that will get emitted\n     * @param {Function} fn - last fn call in the middleware\n     * @private\n     */ run(event, fn) {\n        if (!this.fns.length) return fn();\n        const fns = this.fns.slice(0);\n        function run(i) {\n            fns[i](event, (err)=>{\n                // upon error, short-circuit\n                if (err) return fn(err);\n                // if no middleware left, summon callback\n                if (!fns[i + 1]) return fn();\n                // go on to next\n                run(i + 1);\n            });\n        }\n        run(0);\n    }\n    /**\n     * Whether the socket is currently disconnected\n     */ get disconnected() {\n        return !this.connected;\n    }\n    /**\n     * A reference to the request that originated the underlying Engine.IO Socket.\n     */ get request() {\n        return this.client.request;\n    }\n    /**\n     * A reference to the underlying Client transport connection (Engine.IO Socket object).\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   console.log(socket.conn.transport.name); // prints \"polling\" or \"websocket\"\n     *\n     *   socket.conn.once(\"upgrade\", () => {\n     *     console.log(socket.conn.transport.name); // prints \"websocket\"\n     *   });\n     * });\n     */ get conn() {\n        return this.client.conn;\n    }\n    /**\n     * Returns the rooms the socket is currently in.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   console.log(socket.rooms); // Set { <socket.id> }\n     *\n     *   socket.join(\"room1\");\n     *\n     *   console.log(socket.rooms); // Set { <socket.id>, \"room1\" }\n     * });\n     */ get rooms() {\n        return this.adapter.socketRooms(this.id) || new Set();\n    }\n    /**\n     * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to\n     * the callback.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.onAny((event, ...args) => {\n     *     console.log(`got event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */ onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to\n     * the callback. The listener is added to the beginning of the listeners array.\n     *\n     * @param listener\n     */ prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is received.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   const catchAllListener = (event, ...args) => {\n     *     console.log(`got event ${event}`);\n     *   }\n     *\n     *   socket.onAny(catchAllListener);\n     *\n     *   // remove a specific listener\n     *   socket.offAny(catchAllListener);\n     *\n     *   // or remove all listeners\n     *   socket.offAny();\n     * });\n     *\n     * @param listener\n     */ offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for(let i = 0; i < listeners.length; i++){\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        } else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */ listenersAny() {\n        return this._anyListeners || [];\n    }\n    /**\n     * Adds a listener that will be fired when any event is sent. The event name is passed as the first argument to\n     * the callback.\n     *\n     * Note: acknowledgements sent to the client are not included.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.onAnyOutgoing((event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */ onAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.prependAnyOutgoing((event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */ prependAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is sent.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   const catchAllListener = (event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   }\n     *\n     *   socket.onAnyOutgoing(catchAllListener);\n     *\n     *   // remove a specific listener\n     *   socket.offAnyOutgoing(catchAllListener);\n     *\n     *   // or remove all listeners\n     *   socket.offAnyOutgoing();\n     * });\n     *\n     * @param listener - the catch-all listener\n     */ offAnyOutgoing(listener) {\n        if (!this._anyOutgoingListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyOutgoingListeners;\n            for(let i = 0; i < listeners.length; i++){\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        } else {\n            this._anyOutgoingListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */ listenersAnyOutgoing() {\n        return this._anyOutgoingListeners || [];\n    }\n    /**\n     * Notify the listeners for each packet sent (emit or broadcast)\n     *\n     * @param packet\n     *\n     * @private\n     */ notifyOutgoingListeners(packet) {\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n            const listeners = this._anyOutgoingListeners.slice();\n            for (const listener of listeners){\n                listener.apply(this, packet.data);\n            }\n        }\n    }\n    newBroadcastOperator() {\n        const flags = Object.assign({}, this.flags);\n        this.flags = {};\n        return new broadcast_operator_1.BroadcastOperator(this.adapter, new Set(), new Set([\n            this.id\n        ]), flags);\n    }\n}\nexports.Socket = Socket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3Qvc29ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsTUFBTUcscUJBQXFCQyxtQkFBT0EsQ0FBQyxrRkFBa0I7QUFDckQsTUFBTUMsVUFBVVYsZ0JBQWdCUyxtQkFBT0EsQ0FBQyw2RUFBTztBQUMvQyxNQUFNRSxpQkFBaUJGLG1CQUFPQSxDQUFDLDJFQUFnQjtBQUMvQyxNQUFNRyxhQUFhWixnQkFBZ0JTLG1CQUFPQSxDQUFDLCtEQUFVO0FBQ3JELE1BQU1JLHVCQUF1QkosbUJBQU9BLENBQUMsdUZBQXNCO0FBQzNELE1BQU1LLGlCQUFpQkwsbUJBQU9BLENBQUMsMkVBQWdCO0FBQy9DLE1BQU1NLFFBQVEsQ0FBQyxHQUFHTCxRQUFRTSxPQUFPLEVBQUU7QUFDbkMsTUFBTUMsaUNBQWlDLElBQUlDLElBQUk7SUFDM0M7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxTQUFTQyxRQUFTO0FBQ2xCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E4QkMsR0FDRCxNQUFNWixlQUFlSSxlQUFlUyxrQkFBa0I7SUFDbEQ7Ozs7Ozs7S0FPQyxHQUNEQyxZQUFZQyxHQUFHLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxlQUFlLENBQUU7UUFDNUMsS0FBSztRQUNMLElBQUksQ0FBQ0gsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtRQUNkOzs7U0FHQyxHQUNELElBQUksQ0FBQ0csU0FBUyxHQUFHO1FBQ2pCOzs7U0FHQyxHQUNE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aW8vZGlzdC9zb2NrZXQuanM/YWU0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU29ja2V0ID0gdm9pZCAwO1xuY29uc3Qgc29ja2V0X2lvX3BhcnNlcl8xID0gcmVxdWlyZShcInNvY2tldC5pby1wYXJzZXJcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCB0eXBlZF9ldmVudHNfMSA9IHJlcXVpcmUoXCIuL3R5cGVkLWV2ZW50c1wiKTtcbmNvbnN0IGJhc2U2NGlkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJhc2U2NGlkXCIpKTtcbmNvbnN0IGJyb2FkY2FzdF9vcGVyYXRvcl8xID0gcmVxdWlyZShcIi4vYnJvYWRjYXN0LW9wZXJhdG9yXCIpO1xuY29uc3Qgc29ja2V0X3R5cGVzXzEgPSByZXF1aXJlKFwiLi9zb2NrZXQtdHlwZXNcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwic29ja2V0LmlvOnNvY2tldFwiKTtcbmNvbnN0IFJFQ09WRVJBQkxFX0RJU0NPTk5FQ1RfUkVBU09OUyA9IG5ldyBTZXQoW1xuICAgIFwidHJhbnNwb3J0IGVycm9yXCIsXG4gICAgXCJ0cmFuc3BvcnQgY2xvc2VcIixcbiAgICBcImZvcmNlZCBjbG9zZVwiLFxuICAgIFwicGluZyB0aW1lb3V0XCIsXG4gICAgXCJzZXJ2ZXIgc2h1dHRpbmcgZG93blwiLFxuICAgIFwiZm9yY2VkIHNlcnZlciBjbG9zZVwiLFxuXSk7XG5mdW5jdGlvbiBub29wKCkgeyB9XG4vKipcbiAqIFRoaXMgaXMgdGhlIG1haW4gb2JqZWN0IGZvciBpbnRlcmFjdGluZyB3aXRoIGEgY2xpZW50LlxuICpcbiAqIEEgU29ja2V0IGJlbG9uZ3MgdG8gYSBnaXZlbiB7QGxpbmsgTmFtZXNwYWNlfSBhbmQgdXNlcyBhbiB1bmRlcmx5aW5nIHtAbGluayBDbGllbnR9IHRvIGNvbW11bmljYXRlLlxuICpcbiAqIFdpdGhpbiBlYWNoIHtAbGluayBOYW1lc3BhY2V9LCB5b3UgY2FuIGFsc28gZGVmaW5lIGFyYml0cmFyeSBjaGFubmVscyAoY2FsbGVkIFwicm9vbXNcIikgdGhhdCB0aGUge0BsaW5rIFNvY2tldH0gY2FuXG4gKiBqb2luIGFuZCBsZWF2ZS4gVGhhdCBwcm92aWRlcyBhIGNvbnZlbmllbnQgd2F5IHRvIGJyb2FkY2FzdCB0byBhIGdyb3VwIG9mIHNvY2tldCBpbnN0YW5jZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKGBzb2NrZXQgJHtzb2NrZXQuaWR9IGNvbm5lY3RlZGApO1xuICpcbiAqICAgLy8gc2VuZCBhbiBldmVudCB0byB0aGUgY2xpZW50XG4gKiAgIHNvY2tldC5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICpcbiAqICAgc29ja2V0Lm9uKFwiZm9vYmFyXCIsICgpID0+IHtcbiAqICAgICAvLyBhbiBldmVudCB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgY2xpZW50XG4gKiAgIH0pO1xuICpcbiAqICAgLy8gam9pbiB0aGUgcm9vbSBuYW1lZCBcInJvb20xXCJcbiAqICAgc29ja2V0LmpvaW4oXCJyb29tMVwiKTtcbiAqXG4gKiAgIC8vIGJyb2FkY2FzdCB0byBldmVyeW9uZSBpbiB0aGUgcm9vbSBuYW1lZCBcInJvb20xXCJcbiAqICAgaW8udG8oXCJyb29tMVwiKS5lbWl0KFwiaGVsbG9cIik7XG4gKlxuICogICAvLyB1cG9uIGRpc2Nvbm5lY3Rpb25cbiAqICAgc29ja2V0Lm9uKFwiZGlzY29ubmVjdFwiLCAocmVhc29uKSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coYHNvY2tldCAke3NvY2tldC5pZH0gZGlzY29ubmVjdGVkIGR1ZSB0byAke3JlYXNvbn1gKTtcbiAqICAgfSk7XG4gKiB9KTtcbiAqL1xuY2xhc3MgU29ja2V0IGV4dGVuZHMgdHlwZWRfZXZlbnRzXzEuU3RyaWN0RXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBJbnRlcmZhY2UgdG8gYSBgQ2xpZW50YCBmb3IgYSBnaXZlbiBgTmFtZXNwYWNlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TmFtZXNwYWNlfSBuc3BcbiAgICAgKiBAcGFyYW0ge0NsaWVudH0gY2xpZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF1dGhcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5zcCwgY2xpZW50LCBhdXRoLCBwcmV2aW91c1Nlc3Npb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uc3AgPSBuc3A7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY29ubmVjdGlvbiBzdGF0ZSB3YXMgcmVjb3ZlcmVkIGFmdGVyIGEgdGVtcG9yYXJ5IGRpc2Nvbm5lY3Rpb24uIEluIHRoYXQgY2FzZSwgYW55IG1pc3NlZCBwYWNrZXRzIHdpbGxcbiAgICAgICAgICogYmUgdHJhbnNtaXR0ZWQgdG8gdGhlIGNsaWVudCwgdGhlIGRhdGEgYXR0cmlidXRlIGFuZCB0aGUgcm9vbXMgd2lsbCBiZSByZXN0b3JlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVjb3ZlcmVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBTb2NrZXQgaW5zdGFuY2UgYW5kIHdoaWNoIHdpbGwgYmUgdXNlZCBpbiB0aGVcbiAgICAgICAgICoge0BsaW5rIFNlcnZlci5mZXRjaFNvY2tldHMoKX0gbWV0aG9kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBzb2NrZXQgaXMgY3VycmVudGx5IGNvbm5lY3RlZCBvciBub3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGlvLnVzZSgoc29ja2V0LCBuZXh0KSA9PiB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmNvbm5lY3RlZCk7IC8vIGZhbHNlXG4gICAgICAgICAqICAgbmV4dCgpO1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuY29ubmVjdGVkKTsgLy8gdHJ1ZVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWNrcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5mbnMgPSBbXTtcbiAgICAgICAgdGhpcy5mbGFncyA9IHt9O1xuICAgICAgICB0aGlzLnNlcnZlciA9IG5zcC5zZXJ2ZXI7XG4gICAgICAgIHRoaXMuYWRhcHRlciA9IHRoaXMubnNwLmFkYXB0ZXI7XG4gICAgICAgIGlmIChwcmV2aW91c1Nlc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBwcmV2aW91c1Nlc3Npb24uc2lkO1xuICAgICAgICAgICAgdGhpcy5waWQgPSBwcmV2aW91c1Nlc3Npb24ucGlkO1xuICAgICAgICAgICAgcHJldmlvdXNTZXNzaW9uLnJvb21zLmZvckVhY2goKHJvb20pID0+IHRoaXMuam9pbihyb29tKSk7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBwcmV2aW91c1Nlc3Npb24uZGF0YTtcbiAgICAgICAgICAgIHByZXZpb3VzU2Vzc2lvbi5taXNzZWRQYWNrZXRzLmZvckVhY2goKHBhY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGFja2V0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRVZFTlQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHBhY2tldCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNsaWVudC5jb25uLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRoaXMuaWQgPSBuc3AubmFtZSAhPT0gXCIvXCIgPyBuc3AubmFtZSArIFwiI1wiICsgY2xpZW50LmlkIDogY2xpZW50LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IGJhc2U2NGlkXzEuZGVmYXVsdC5nZW5lcmF0ZUlkKCk7IC8vIGRvbid0IHJldXNlIHRoZSBFbmdpbmUuSU8gaWQgYmVjYXVzZSBpdCdzIHNlbnNpdGl2ZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VydmVyLl9vcHRzLmNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waWQgPSBiYXNlNjRpZF8xLmRlZmF1bHQuZ2VuZXJhdGVJZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZHNoYWtlID0gdGhpcy5idWlsZEhhbmRzaGFrZShhdXRoKTtcbiAgICAgICAgLy8gcHJldmVudHMgY3Jhc2ggd2hlbiB0aGUgc29ja2V0IHJlY2VpdmVzIGFuIFwiZXJyb3JcIiBldmVudCB3aXRob3V0IGxpc3RlbmVyXG4gICAgICAgIHRoaXMub24oXCJlcnJvclwiLCBub29wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIHRoZSBgaGFuZHNoYWtlYCBCQyBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnVpbGRIYW5kc2hha2UoYXV0aCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWFkZXJzOiAoKF9hID0gdGhpcy5yZXF1ZXN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhZGVycykgfHwge30sXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpICsgXCJcIixcbiAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuY29ubi5yZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgeGRvbWFpbjogISEoKF9iID0gdGhpcy5yZXF1ZXN0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVhZGVycy5vcmlnaW4pLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgc2VjdXJlOiAhdGhpcy5yZXF1ZXN0IHx8ICEhdGhpcy5yZXF1ZXN0LmNvbm5lY3Rpb24uZW5jcnlwdGVkLFxuICAgICAgICAgICAgaXNzdWVkOiArbmV3IERhdGUoKSxcbiAgICAgICAgICAgIHVybDogKF9jID0gdGhpcy5yZXF1ZXN0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcXVlcnk6ICgoX2QgPSB0aGlzLnJlcXVlc3QpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5fcXVlcnkpIHx8IHt9LFxuICAgICAgICAgICAgYXV0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgdG8gdGhpcyBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBzb2NrZXQuZW1pdChcImhlbGxvXCIsIFwid29ybGRcIik7XG4gICAgICpcbiAgICAgKiAgIC8vIGFsbCBzZXJpYWxpemFibGUgZGF0YXN0cnVjdHVyZXMgYXJlIHN1cHBvcnRlZCAobm8gbmVlZCB0byBjYWxsIEpTT04uc3RyaW5naWZ5KVxuICAgICAqICAgc29ja2V0LmVtaXQoXCJoZWxsb1wiLCAxLCBcIjJcIiwgeyAzOiBbXCI0XCJdLCA1OiBCdWZmZXIuZnJvbShbNl0pIH0pO1xuICAgICAqXG4gICAgICogICAvLyB3aXRoIGFuIGFja25vd2xlZGdlbWVudCBmcm9tIHRoZSBjbGllbnRcbiAgICAgKiAgIHNvY2tldC5lbWl0KFwiaGVsbG9cIiwgXCJ3b3JsZFwiLCAodmFsKSA9PiB7XG4gICAgICogICAgIC8vIC4uLlxuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEFsd2F5cyByZXR1cm5zIGB0cnVlYC5cbiAgICAgKi9cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIGlmIChzb2NrZXRfdHlwZXNfMS5SRVNFUlZFRF9FVkVOVFMuaGFzKGV2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7U3RyaW5nKGV2KX1cIiBpcyBhIHJlc2VydmVkIGV2ZW50IG5hbWVgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gW2V2LCAuLi5hcmdzXTtcbiAgICAgICAgY29uc3QgcGFja2V0ID0ge1xuICAgICAgICAgICAgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRVZFTlQsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICB9O1xuICAgICAgICAvLyBhY2Nlc3MgbGFzdCBhcmd1bWVudCB0byBzZWUgaWYgaXQncyBhbiBBQ0sgY2FsbGJhY2tcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2RhdGEubGVuZ3RoIC0gMV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLm5zcC5faWRzKys7XG4gICAgICAgICAgICBkZWJ1ZyhcImVtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZFwiLCBpZCk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyQWNrQ2FsbGJhY2soaWQsIGRhdGEucG9wKCkpO1xuICAgICAgICAgICAgcGFja2V0LmlkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZsYWdzKTtcbiAgICAgICAgdGhpcy5mbGFncyA9IHt9O1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICh0aGlzLm5zcC5zZXJ2ZXIub3B0cy5jb25uZWN0aW9uU3RhdGVSZWNvdmVyeSkge1xuICAgICAgICAgICAgLy8gdGhpcyBlbnN1cmVzIHRoZSBwYWNrZXQgaXMgc3RvcmVkIGFuZCBjYW4gYmUgdHJhbnNtaXR0ZWQgdXBvbiByZWNvbm5lY3Rpb25cbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci5icm9hZGNhc3QocGFja2V0LCB7XG4gICAgICAgICAgICAgICAgcm9vbXM6IG5ldyBTZXQoW3RoaXMuaWRdKSxcbiAgICAgICAgICAgICAgICBleGNlcHQ6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICBmbGFncyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlPdXRnb2luZ0xpc3RlbmVycyhwYWNrZXQpO1xuICAgICAgICAgICAgdGhpcy5wYWNrZXQocGFja2V0LCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGFuZCB3YWl0cyBmb3IgYW4gYWNrbm93bGVkZ2VtZW50XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCBhc3luYyAoc29ja2V0KSA9PiB7XG4gICAgICogICAvLyB3aXRob3V0IHRpbWVvdXRcbiAgICAgKiAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc29ja2V0LmVtaXRXaXRoQWNrKFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAgICAgKlxuICAgICAqICAgLy8gd2l0aCBhIHNwZWNpZmljIHRpbWVvdXRcbiAgICAgKiAgIHRyeSB7XG4gICAgICogICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc29ja2V0LnRpbWVvdXQoMTAwMCkuZW1pdFdpdGhBY2soXCJoZWxsb1wiLCBcIndvcmxkXCIpO1xuICAgICAqICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICogICAgIC8vIHRoZSBjbGllbnQgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIGNsaWVudCBhY2tub3dsZWRnZXMgdGhlIGV2ZW50XG4gICAgICovXG4gICAgZW1pdFdpdGhBY2soZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gdGhlIHRpbWVvdXQgZmxhZyBpcyBvcHRpb25hbFxuICAgICAgICBjb25zdCB3aXRoRXJyID0gdGhpcy5mbGFncy50aW1lb3V0ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBhcmdzLnB1c2goKGFyZzEsIGFyZzIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAod2l0aEVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnMSA/IHJlamVjdChhcmcxKSA6IHJlc29sdmUoYXJnMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShhcmcxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChldiwgLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlZ2lzdGVyQWNrQ2FsbGJhY2soaWQsIGFjaykge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy5mbGFncy50aW1lb3V0O1xuICAgICAgICBpZiAodGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFja3Muc2V0KGlkLCBhY2spO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcImV2ZW50IHdpdGggYWNrIGlkICVkIGhhcyB0aW1lZCBvdXQgYWZ0ZXIgJWQgbXNcIiwgaWQsIHRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5hY2tzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBhY2suY2FsbCh0aGlzLCBuZXcgRXJyb3IoXCJvcGVyYXRpb24gaGFzIHRpbWVkIG91dFwiKSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB0aGlzLmFja3Muc2V0KGlkLCAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIGFjay5hcHBseSh0aGlzLCBbbnVsbCwgLi4uYXJnc10pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBicm9hZGNhc3RpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cyBpbiB0aGUg4oCccm9vbS0xMDHigJ0gcm9vbSwgZXhjZXB0IHRoaXMgc29ja2V0XG4gICAgICogICBzb2NrZXQudG8oXCJyb29tLTEwMVwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogICAvLyB0aGUgY29kZSBhYm92ZSBpcyBlcXVpdmFsZW50IHRvOlxuICAgICAqICAgaW8udG8oXCJyb29tLTEwMVwiKS5leGNlcHQoc29ja2V0LmlkKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogICAvLyB3aXRoIGFuIGFycmF5IG9mIHJvb21zIChhIGNsaWVudCB3aWxsIGJlIG5vdGlmaWVkIGF0IG1vc3Qgb25jZSlcbiAgICAgKiAgIHNvY2tldC50byhbXCJyb29tLTEwMVwiLCBcInJvb20tMTAyXCJdKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogICAvLyB3aXRoIG11bHRpcGxlIGNoYWluZWQgY2FsbHNcbiAgICAgKiAgIHNvY2tldC50byhcInJvb20tMTAxXCIpLnRvKFwicm9vbS0xMDJcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICB0byhyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld0Jyb2FkY2FzdE9wZXJhdG9yKCkudG8ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gYnJvYWRjYXN0aW5nLiBTaW1pbGFyIHRvIGB0bygpYCwgYnV0IG1pZ2h0IGZlZWwgY2xlYXJlciBpbiBzb21lIGNhc2VzOlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgLy8gZGlzY29ubmVjdCBhbGwgY2xpZW50cyBpbiB0aGUgXCJyb29tLTEwMVwiIHJvb20sIGV4Y2VwdCB0aGlzIHNvY2tldFxuICAgICAqICAgc29ja2V0LmluKFwicm9vbS0xMDFcIikuZGlzY29ubmVjdFNvY2tldHMoKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBpbihyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld0Jyb2FkY2FzdE9wZXJhdG9yKCkuaW4ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4Y2x1ZGVzIGEgcm9vbSB3aGVuIGJyb2FkY2FzdGluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIC8vIHRoZSBcImZvb1wiIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cywgZXhjZXB0IHRoZSBvbmVzIHRoYXQgYXJlIGluIHRoZSBcInJvb20tMTAxXCIgcm9vbVxuICAgICAqICAgLy8gYW5kIHRoaXMgc29ja2V0XG4gICAgICogICBzb2NrZXQuZXhjZXB0KFwicm9vbS0xMDFcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqICAgLy8gd2l0aCBhbiBhcnJheSBvZiByb29tc1xuICAgICAqICAgc29ja2V0LmV4Y2VwdChbXCJyb29tLTEwMVwiLCBcInJvb20tMTAyXCJdKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogICAvLyB3aXRoIG11bHRpcGxlIGNoYWluZWQgY2FsbHNcbiAgICAgKiAgIHNvY2tldC5leGNlcHQoXCJyb29tLTEwMVwiKS5leGNlcHQoXCJyb29tLTEwMlwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGV4Y2VwdChyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld0Jyb2FkY2FzdE9wZXJhdG9yKCkuZXhjZXB0KHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1pbWljcyB0aGUgV2ViU29ja2V0LnNlbmQoKSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJTb2NrZXQvc2VuZFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgc29ja2V0LnNlbmQoXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqICAgLy8gdGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICogICBzb2NrZXQuZW1pdChcIm1lc3NhZ2VcIiwgXCJoZWxsb1wiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIHNlbmQoLi4uYXJncykge1xuICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuIEFsaWFzIG9mIHtAbGluayBzZW5kfS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIHdyaXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwibWVzc2FnZVwiLCAuLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBwYWNrZXQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwYWNrZXQocGFja2V0LCBvcHRzID0ge30pIHtcbiAgICAgICAgcGFja2V0Lm5zcCA9IHRoaXMubnNwLm5hbWU7XG4gICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZSAhPT0gb3B0cy5jb21wcmVzcztcbiAgICAgICAgdGhpcy5jbGllbnQuX3BhY2tldChwYWNrZXQsIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBKb2lucyBhIHJvb20uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICAvLyBqb2luIGEgc2luZ2xlIHJvb21cbiAgICAgKiAgIHNvY2tldC5qb2luKFwicm9vbTFcIik7XG4gICAgICpcbiAgICAgKiAgIC8vIGpvaW4gbXVsdGlwbGUgcm9vbXNcbiAgICAgKiAgIHNvY2tldC5qb2luKFtcInJvb20xXCIsIFwicm9vbTJcIl0pO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHJvb21zIC0gcm9vbSBvciBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBQcm9taXNlIG9yIG5vdGhpbmcsIGRlcGVuZGluZyBvbiB0aGUgYWRhcHRlclxuICAgICAqL1xuICAgIGpvaW4ocm9vbXMpIHtcbiAgICAgICAgZGVidWcoXCJqb2luIHJvb20gJXNcIiwgcm9vbXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdGVyLmFkZEFsbCh0aGlzLmlkLCBuZXcgU2V0KEFycmF5LmlzQXJyYXkocm9vbXMpID8gcm9vbXMgOiBbcm9vbXNdKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlYXZlcyBhIHJvb20uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICAvLyBsZWF2ZSBhIHNpbmdsZSByb29tXG4gICAgICogICBzb2NrZXQubGVhdmUoXCJyb29tMVwiKTtcbiAgICAgKlxuICAgICAqICAgLy8gbGVhdmUgbXVsdGlwbGUgcm9vbXNcbiAgICAgKiAgIHNvY2tldC5sZWF2ZShcInJvb20xXCIpLmxlYXZlKFwicm9vbTJcIik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcm9vbVxuICAgICAqIEByZXR1cm4gYSBQcm9taXNlIG9yIG5vdGhpbmcsIGRlcGVuZGluZyBvbiB0aGUgYWRhcHRlclxuICAgICAqL1xuICAgIGxlYXZlKHJvb20pIHtcbiAgICAgICAgZGVidWcoXCJsZWF2ZSByb29tICVzXCIsIHJvb20pO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdGVyLmRlbCh0aGlzLmlkLCByb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGVhdmUgYWxsIHJvb21zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBsZWF2ZUFsbCgpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyLmRlbEFsbCh0aGlzLmlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJ5IGBOYW1lc3BhY2VgIHVwb24gc3VjY2Vzc2Z1bFxuICAgICAqIG1pZGRsZXdhcmUgZXhlY3V0aW9uIChpZTogYXV0aG9yaXphdGlvbikuXG4gICAgICogU29ja2V0IGlzIGFkZGVkIHRvIG5hbWVzcGFjZSBhcnJheSBiZWZvcmVcbiAgICAgKiBjYWxsIHRvIGpvaW4sIHNvIGFkYXB0ZXJzIGNhbiBhY2Nlc3MgaXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbmNvbm5lY3QoKSB7XG4gICAgICAgIGRlYnVnKFwic29ja2V0IGNvbm5lY3RlZCAtIHdyaXRpbmcgcGFja2V0XCIpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuam9pbih0aGlzLmlkKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubi5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNUIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYWNrZXQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkNPTk5FQ1QsXG4gICAgICAgICAgICAgICAgZGF0YTogeyBzaWQ6IHRoaXMuaWQsIHBpZDogdGhpcy5waWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIGVhY2ggcGFja2V0LiBDYWxsZWQgYnkgYENsaWVudGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25wYWNrZXQocGFja2V0KSB7XG4gICAgICAgIGRlYnVnKFwiZ290IHBhY2tldCAlalwiLCBwYWNrZXQpO1xuICAgICAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkVWRU5UOlxuICAgICAgICAgICAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5CSU5BUllfRVZFTlQ6XG4gICAgICAgICAgICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkFDSzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkJJTkFSWV9BQ0s6XG4gICAgICAgICAgICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5ESVNDT05ORUNUOlxuICAgICAgICAgICAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gZXZlbnQgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYWNrZXR9IHBhY2tldCAtIHBhY2tldCBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZXZlbnQocGFja2V0KSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcbiAgICAgICAgZGVidWcoXCJlbWl0dGluZyBldmVudCAlalwiLCBhcmdzKTtcbiAgICAgICAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImF0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnRcIik7XG4gICAgICAgICAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2FueUxpc3RlbmVycyAmJiB0aGlzLl9hbnlMaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaChhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCAtIHBhY2tldCBpZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWNrKGlkKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgc2VudCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgICAgICAgICBpZiAoc2VudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGRlYnVnKFwic2VuZGluZyBhY2sgJWpcIiwgYXJncyk7XG4gICAgICAgICAgICBzZWxmLnBhY2tldCh7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkFDSyxcbiAgICAgICAgICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZW50ID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gYWNrIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25hY2socGFja2V0KSB7XG4gICAgICAgIGNvbnN0IGFjayA9IHRoaXMuYWNrcy5nZXQocGFja2V0LmlkKTtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYWNrKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImNhbGxpbmcgYWNrICVzIHdpdGggJWpcIiwgcGFja2V0LmlkLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgICBhY2suYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5hY2tzLmRlbGV0ZShwYWNrZXQuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoXCJiYWQgYWNrICVzXCIsIHBhY2tldC5pZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gY2xpZW50IGRpc2Nvbm5lY3QgcGFja2V0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGRlYnVnKFwiZ290IGRpc2Nvbm5lY3QgcGFja2V0XCIpO1xuICAgICAgICB0aGlzLl9vbmNsb3NlKFwiY2xpZW50IG5hbWVzcGFjZSBkaXNjb25uZWN0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGEgY2xpZW50IGVycm9yLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25lcnJvcihlcnIpIHtcbiAgICAgICAgLy8gRklYTUUgdGhlIG1lYW5pbmcgb2YgdGhlIFwiZXJyb3JcIiBldmVudCBpcyBvdmVybG9hZGVkOlxuICAgICAgICAvLyAgLSBpdCBjYW4gYmUgc2VudCBieSB0aGUgY2xpZW50IChgc29ja2V0LmVtaXQoXCJlcnJvclwiKWApXG4gICAgICAgIC8vICAtIGl0IGNhbiBiZSBlbWl0dGVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gZW5jb3VudGVycyBhbiBlcnJvciAoYW4gaW52YWxpZCBwYWNrZXQgZm9yIGV4YW1wbGUpXG4gICAgICAgIC8vICAtIGl0IGNhbiBiZSBlbWl0dGVkIHdoZW4gYSBwYWNrZXQgaXMgcmVqZWN0ZWQgaW4gYSBtaWRkbGV3YXJlIChgc29ja2V0LnVzZSgpYClcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJlcnJvclwiLCBlcnIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBjbG9zaW5nLiBDYWxsZWQgYnkgYENsaWVudGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uXG4gICAgICogQHBhcmFtIGRlc2NyaXB0aW9uXG4gICAgICogQHRocm93IHtFcnJvcn0gb3B0aW9uYWwgZXJyb3Igb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbmNsb3NlKHJlYXNvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBkZWJ1ZyhcImNsb3Npbmcgc29ja2V0IC0gcmVhc29uICVzXCIsIHJlYXNvbik7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZGlzY29ubmVjdGluZ1wiLCByZWFzb24sIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyLl9vcHRzLmNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5ICYmXG4gICAgICAgICAgICBSRUNPVkVSQUJMRV9ESVNDT05ORUNUX1JFQVNPTlMuaGFzKHJlYXNvbikpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiBzdGF0ZSByZWNvdmVyeSBpcyBlbmFibGVkIGZvciBzaWQgJXNcIiwgdGhpcy5pZCk7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIucGVyc2lzdFNlc3Npb24oe1xuICAgICAgICAgICAgICAgIHNpZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICBwaWQ6IHRoaXMucGlkLFxuICAgICAgICAgICAgICAgIHJvb21zOiBbLi4udGhpcy5yb29tc10sXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICB0aGlzLmNsaWVudC5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRpc2Nvbm5lY3RcIiwgcmVhc29uLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIHNvY2tldCBsZWF2ZSBhbGwgdGhlIHJvb21zIGl0IHdhcyBwYXJ0IG9mIGFuZCBwcmV2ZW50cyBpdCBmcm9tIGpvaW5pbmcgYW55IG90aGVyIHJvb21cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NsZWFudXAoKSB7XG4gICAgICAgIHRoaXMubGVhdmVBbGwoKTtcbiAgICAgICAgdGhpcy5uc3AuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5qb2luID0gbm9vcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYW4gYGVycm9yYCBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXJyIC0gZXJyb3Igb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9lcnJvcihlcnIpIHtcbiAgICAgICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNUX0VSUk9SLCBkYXRhOiBlcnIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIHRoaXMgY2xpZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgLy8gZGlzY29ubmVjdCB0aGlzIHNvY2tldCAodGhlIGNvbm5lY3Rpb24gbWlnaHQgYmUga2VwdCBhbGl2ZSBmb3Igb3RoZXIgbmFtZXNwYWNlcylcbiAgICAgKiAgIHNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICpcbiAgICAgKiAgIC8vIGRpc2Nvbm5lY3QgdGhpcyBzb2NrZXQgYW5kIGNsb3NlIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25cbiAgICAgKiAgIHNvY2tldC5kaXNjb25uZWN0KHRydWUpO1xuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsb3NlIC0gaWYgYHRydWVgLCBjbG9zZXMgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoY2xvc2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChjbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQuX2Rpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFja2V0KHsgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRElTQ09OTkVDVCB9KTtcbiAgICAgICAgICAgIHRoaXMuX29uY2xvc2UoXCJzZXJ2ZXIgbmFtZXNwYWNlIGRpc2Nvbm5lY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBzb2NrZXQuY29tcHJlc3MoZmFsc2UpLmVtaXQoXCJoZWxsb1wiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29tcHJlc3MgLSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICAgICAqL1xuICAgIGNvbXByZXNzKGNvbXByZXNzKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MuY29tcHJlc3MgPSBjb21wcmVzcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IGRhdGEgbWF5IGJlIGxvc3QgaWYgdGhlIGNsaWVudCBpcyBub3QgcmVhZHkgdG9cbiAgICAgKiByZWNlaXZlIG1lc3NhZ2VzIChiZWNhdXNlIG9mIG5ldHdvcmsgc2xvd25lc3Mgb3Igb3RoZXIgaXNzdWVzLCBvciBiZWNhdXNlIHRoZXnigJlyZSBjb25uZWN0ZWQgdGhyb3VnaCBsb25nIHBvbGxpbmdcbiAgICAgKiBhbmQgaXMgaW4gdGhlIG1pZGRsZSBvZiBhIHJlcXVlc3QtcmVzcG9uc2UgY3ljbGUpLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgc29ja2V0LnZvbGF0aWxlLmVtaXQoXCJoZWxsb1wiKTsgLy8gdGhlIGNsaWVudCBtYXkgb3IgbWF5IG5vdCByZWNlaXZlIGl0XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAgICAgKi9cbiAgICBnZXQgdm9sYXRpbGUoKSB7XG4gICAgICAgIHRoaXMuZmxhZ3Mudm9sYXRpbGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSB3aWxsIG9ubHkgYmUgYnJvYWRjYXN0IHRvIGV2ZXJ5IHNvY2tldHMgYnV0IHRoZVxuICAgICAqIHNlbmRlci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIC8vIHRoZSDigJxmb2/igJ0gZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzLCBleGNlcHQgdGhpcyBzb2NrZXRcbiAgICAgKiAgIHNvY2tldC5icm9hZGNhc3QuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBnZXQgYnJvYWRjYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdCcm9hZGNhc3RPcGVyYXRvcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIHdpbGwgb25seSBiZSBicm9hZGNhc3QgdG8gdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIC8vIHRoZSDigJxmb2/igJ0gZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzIG9uIHRoaXMgbm9kZSwgZXhjZXB0IHRoaXMgc29ja2V0XG4gICAgICogICBzb2NrZXQubG9jYWwuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBnZXQgbG9jYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld0Jyb2FkY2FzdE9wZXJhdG9yKCkubG9jYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYW4gZXJyb3Igd2hlbiB0aGVcbiAgICAgKiBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCB3aXRob3V0IGFuIGFja25vd2xlZGdlbWVudCBmcm9tIHRoZSBjbGllbnQ6XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBzb2NrZXQudGltZW91dCg1MDAwKS5lbWl0KFwibXktZXZlbnRcIiwgKGVycikgPT4ge1xuICAgICAqICAgICBpZiAoZXJyKSB7XG4gICAgICogICAgICAgLy8gdGhlIGNsaWVudCBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiAgICAgfVxuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBzZWxmXG4gICAgICovXG4gICAgdGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMuZmxhZ3MudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaCBpbmNvbWluZyBldmVudCB0byBzb2NrZXQgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gZXZlbnQgLSBldmVudCB0aGF0IHdpbGwgZ2V0IGVtaXR0ZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRpc3BhdGNoKGV2ZW50KSB7XG4gICAgICAgIGRlYnVnKFwiZGlzcGF0Y2hpbmcgYW4gZXZlbnQgJWpcIiwgZXZlbnQpO1xuICAgICAgICB0aGlzLnJ1bihldmVudCwgKGVycikgPT4ge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb25lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuZW1pdFVudHlwZWQuYXBwbHkodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJpZ25vcmUgcGFja2V0IHJlY2VpdmVkIGFmdGVyIGRpc2Nvbm5lY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHNvY2tldCBtaWRkbGV3YXJlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgc29ja2V0LnVzZSgoW2V2ZW50LCAuLi5hcmdzXSwgbmV4dCkgPT4ge1xuICAgICAqICAgICBpZiAoaXNVbmF1dGhvcml6ZWQoZXZlbnQpKSB7XG4gICAgICogICAgICAgcmV0dXJuIG5leHQobmV3IEVycm9yKFwidW5hdXRob3JpemVkIGV2ZW50XCIpKTtcbiAgICAgKiAgICAgfVxuICAgICAqICAgICAvLyBkbyBub3QgZm9yZ2V0IHRvIGNhbGwgbmV4dFxuICAgICAqICAgICBuZXh0KCk7XG4gICAgICogICB9KTtcbiAgICAgKlxuICAgICAqICAgc29ja2V0Lm9uKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAqICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBcInVuYXV0aG9yaXplZCBldmVudFwiKSB7XG4gICAgICogICAgICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgKiAgICAgfVxuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIG1pZGRsZXdhcmUgZnVuY3Rpb24gKGV2ZW50LCBuZXh0KVxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICAgICAqL1xuICAgIHVzZShmbikge1xuICAgICAgICB0aGlzLmZucy5wdXNoKGZuKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBtaWRkbGV3YXJlIGZvciBhbiBpbmNvbWluZyBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGV2ZW50IC0gZXZlbnQgdGhhdCB3aWxsIGdldCBlbWl0dGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBsYXN0IGZuIGNhbGwgaW4gdGhlIG1pZGRsZXdhcmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJ1bihldmVudCwgZm4pIHtcbiAgICAgICAgaWYgKCF0aGlzLmZucy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgY29uc3QgZm5zID0gdGhpcy5mbnMuc2xpY2UoMCk7XG4gICAgICAgIGZ1bmN0aW9uIHJ1bihpKSB7XG4gICAgICAgICAgICBmbnNbaV0oZXZlbnQsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB1cG9uIGVycm9yLCBzaG9ydC1jaXJjdWl0XG4gICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGVycik7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gbWlkZGxld2FyZSBsZWZ0LCBzdW1tb24gY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBpZiAoIWZuc1tpICsgMV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICAgICAgICAgIC8vIGdvIG9uIHRvIG5leHRcbiAgICAgICAgICAgICAgICBydW4oaSArIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcnVuKDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBzb2NrZXQgaXMgY3VycmVudGx5IGRpc2Nvbm5lY3RlZFxuICAgICAqL1xuICAgIGdldCBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb25uZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSByZXF1ZXN0IHRoYXQgb3JpZ2luYXRlZCB0aGUgdW5kZXJseWluZyBFbmdpbmUuSU8gU29ja2V0LlxuICAgICAqL1xuICAgIGdldCByZXF1ZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIHVuZGVybHlpbmcgQ2xpZW50IHRyYW5zcG9ydCBjb25uZWN0aW9uIChFbmdpbmUuSU8gU29ja2V0IG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuY29ubi50cmFuc3BvcnQubmFtZSk7IC8vIHByaW50cyBcInBvbGxpbmdcIiBvciBcIndlYnNvY2tldFwiXG4gICAgICpcbiAgICAgKiAgIHNvY2tldC5jb25uLm9uY2UoXCJ1cGdyYWRlXCIsICgpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coc29ja2V0LmNvbm4udHJhbnNwb3J0Lm5hbWUpOyAvLyBwcmludHMgXCJ3ZWJzb2NrZXRcIlxuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgZ2V0IGNvbm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jb25uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByb29tcyB0aGUgc29ja2V0IGlzIGN1cnJlbnRseSBpbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5yb29tcyk7IC8vIFNldCB7IDxzb2NrZXQuaWQ+IH1cbiAgICAgKlxuICAgICAqICAgc29ja2V0LmpvaW4oXCJyb29tMVwiKTtcbiAgICAgKlxuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LnJvb21zKTsgLy8gU2V0IHsgPHNvY2tldC5pZD4sIFwicm9vbTFcIiB9XG4gICAgICogfSk7XG4gICAgICovXG4gICAgZ2V0IHJvb21zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdGVyLnNvY2tldFJvb21zKHRoaXMuaWQpIHx8IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyByZWNlaXZlZC4gVGhlIGV2ZW50IG5hbWUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0b1xuICAgICAqIHRoZSBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIHNvY2tldC5vbkFueSgoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYGdvdCBldmVudCAke2V2ZW50fWApO1xuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvbkFueShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnMgfHwgW107XG4gICAgICAgIHRoaXMuX2FueUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgcmVjZWl2ZWQuIFRoZSBldmVudCBuYW1lIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG9cbiAgICAgKiB0aGUgY2FsbGJhY2suIFRoZSBsaXN0ZW5lciBpcyBhZGRlZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBwcmVwZW5kQW55KGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FueUxpc3RlbmVycyA9IHRoaXMuX2FueUxpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5fYW55TGlzdGVuZXJzLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIHJlY2VpdmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgY29uc3QgY2F0Y2hBbGxMaXN0ZW5lciA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhgZ290IGV2ZW50ICR7ZXZlbnR9YCk7XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiAgIHNvY2tldC5vbkFueShjYXRjaEFsbExpc3RlbmVyKTtcbiAgICAgKlxuICAgICAqICAgLy8gcmVtb3ZlIGEgc3BlY2lmaWMgbGlzdGVuZXJcbiAgICAgKiAgIHNvY2tldC5vZmZBbnkoY2F0Y2hBbGxMaXN0ZW5lcik7XG4gICAgICpcbiAgICAgKiAgIC8vIG9yIHJlbW92ZSBhbGwgbGlzdGVuZXJzXG4gICAgICogICBzb2NrZXQub2ZmQW55KCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvZmZBbnkobGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hbnlMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fYW55TGlzdGVuZXJzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIgPT09IGxpc3RlbmVyc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgdGhhdCBhcmUgbGlzdGVuaW5nIGZvciBhbnkgZXZlbnQgdGhhdCBpcyBzcGVjaWZpZWQuIFRoaXMgYXJyYXkgY2FuIGJlIG1hbmlwdWxhdGVkLFxuICAgICAqIGUuZy4gdG8gcmVtb3ZlIGxpc3RlbmVycy5cbiAgICAgKi9cbiAgICBsaXN0ZW5lcnNBbnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbnlMaXN0ZW5lcnMgfHwgW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgc2VudC4gVGhlIGV2ZW50IG5hbWUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0b1xuICAgICAqIHRoZSBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIE5vdGU6IGFja25vd2xlZGdlbWVudHMgc2VudCB0byB0aGUgY2xpZW50IGFyZSBub3QgaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBzb2NrZXQub25BbnlPdXRnb2luZygoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYHNlbnQgZXZlbnQgJHtldmVudH1gKTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgb25BbnlPdXRnb2luZyhsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyA9IHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzIHx8IFtdO1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgZW1pdHRlZC4gVGhlIGV2ZW50IG5hbWUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGVcbiAgICAgKiBjYWxsYmFjay4gVGhlIGxpc3RlbmVyIGlzIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RlbmVycyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIHNvY2tldC5wcmVwZW5kQW55T3V0Z29pbmcoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGBzZW50IGV2ZW50ICR7ZXZlbnR9YCk7XG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqL1xuICAgIHByZXBlbmRBbnlPdXRnb2luZyhsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyA9IHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzIHx8IFtdO1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyBzZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgY29uc3QgY2F0Y2hBbGxMaXN0ZW5lciA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhgc2VudCBldmVudCAke2V2ZW50fWApO1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogICBzb2NrZXQub25BbnlPdXRnb2luZyhjYXRjaEFsbExpc3RlbmVyKTtcbiAgICAgKlxuICAgICAqICAgLy8gcmVtb3ZlIGEgc3BlY2lmaWMgbGlzdGVuZXJcbiAgICAgKiAgIHNvY2tldC5vZmZBbnlPdXRnb2luZyhjYXRjaEFsbExpc3RlbmVyKTtcbiAgICAgKlxuICAgICAqICAgLy8gb3IgcmVtb3ZlIGFsbCBsaXN0ZW5lcnNcbiAgICAgKiAgIHNvY2tldC5vZmZBbnlPdXRnb2luZygpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gdGhlIGNhdGNoLWFsbCBsaXN0ZW5lclxuICAgICAqL1xuICAgIG9mZkFueU91dGdvaW5nKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lciA9PT0gbGlzdGVuZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRoYXQgYXJlIGxpc3RlbmluZyBmb3IgYW55IGV2ZW50IHRoYXQgaXMgc3BlY2lmaWVkLiBUaGlzIGFycmF5IGNhbiBiZSBtYW5pcHVsYXRlZCxcbiAgICAgKiBlLmcuIHRvIHJlbW92ZSBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgbGlzdGVuZXJzQW55T3V0Z29pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyB8fCBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90aWZ5IHRoZSBsaXN0ZW5lcnMgZm9yIGVhY2ggcGFja2V0IHNlbnQgKGVtaXQgb3IgYnJvYWRjYXN0KVxuICAgICAqXG4gICAgICogQHBhcmFtIHBhY2tldFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBub3RpZnlPdXRnb2luZ0xpc3RlbmVycyhwYWNrZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzICYmIHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5ld0Jyb2FkY2FzdE9wZXJhdG9yKCkge1xuICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZmxhZ3MpO1xuICAgICAgICB0aGlzLmZsYWdzID0ge307XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyLCBuZXcgU2V0KCksIG5ldyBTZXQoW3RoaXMuaWRdKSwgZmxhZ3MpO1xuICAgIH1cbn1cbmV4cG9ydHMuU29ja2V0ID0gU29ja2V0O1xuIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNvY2tldCIsInNvY2tldF9pb19wYXJzZXJfMSIsInJlcXVpcmUiLCJkZWJ1Z18xIiwidHlwZWRfZXZlbnRzXzEiLCJiYXNlNjRpZF8xIiwiYnJvYWRjYXN0X29wZXJhdG9yXzEiLCJzb2NrZXRfdHlwZXNfMSIsImRlYnVnIiwiZGVmYXVsdCIsIlJFQ09WRVJBQkxFX0RJU0NPTk5FQ1RfUkVBU09OUyIsIlNldCIsIm5vb3AiLCJTdHJpY3RFdmVudEVtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsIm5zcCIsImNsaWVudCIsImF1dGgiLCJwcmV2aW91c1Nlc3Npb24iLCJyZWNvdmVyZWQiLCJkYXRhIiwiY29ubmVjdGVkIiwiYWNrcyIsIk1hcCIsImZucyIsImZsYWdzIiwic2VydmVyIiwiYWRhcHRlciIsImlkIiwic2lkIiwicGlkIiwicm9vbXMiLCJmb3JFYWNoIiwicm9vbSIsImpvaW4iLCJtaXNzZWRQYWNrZXRzIiwicGFja2V0IiwidHlwZSIsIlBhY2tldFR5cGUiLCJFVkVOVCIsImNvbm4iLCJwcm90b2NvbCIsIm5hbWUiLCJnZW5lcmF0ZUlkIiwiX29wdHMiLCJjb25uZWN0aW9uU3RhdGVSZWNvdmVyeSIsImhhbmRzaGFrZSIsImJ1aWxkSGFuZHNoYWtlIiwib24iLCJfYSIsIl9iIiwiX2MiLCJfZCIsImhlYWRlcnMiLCJyZXF1ZXN0IiwidGltZSIsIkRhdGUiLCJhZGRyZXNzIiwicmVtb3RlQWRkcmVzcyIsInhkb21haW4iLCJvcmlnaW4iLCJzZWN1cmUiLCJjb25uZWN0aW9uIiwiZW5jcnlwdGVkIiwiaXNzdWVkIiwidXJsIiwicXVlcnkiLCJfcXVlcnkiLCJlbWl0IiwiZXYiLCJhcmdzIiwiUkVTRVJWRURfRVZFTlRTIiwiaGFzIiwiRXJyb3IiLCJTdHJpbmciLCJsZW5ndGgiLCJfaWRzIiwicmVnaXN0ZXJBY2tDYWxsYmFjayIsInBvcCIsImFzc2lnbiIsIm9wdHMiLCJicm9hZGNhc3QiLCJleGNlcHQiLCJub3RpZnlPdXRnb2luZ0xpc3RlbmVycyIsImVtaXRXaXRoQWNrIiwid2l0aEVyciIsInRpbWVvdXQiLCJ1bmRlZmluZWQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInB1c2giLCJhcmcxIiwiYXJnMiIsImFjayIsInNldCIsInRpbWVyIiwic2V0VGltZW91dCIsImRlbGV0ZSIsImNhbGwiLCJjbGVhclRpbWVvdXQiLCJhcHBseSIsInRvIiwibmV3QnJvYWRjYXN0T3BlcmF0b3IiLCJpbiIsInNlbmQiLCJ3cml0ZSIsImNvbXByZXNzIiwiX3BhY2tldCIsImFkZEFsbCIsIkFycmF5IiwiaXNBcnJheSIsImxlYXZlIiwiZGVsIiwibGVhdmVBbGwiLCJkZWxBbGwiLCJfb25jb25uZWN0IiwiQ09OTkVDVCIsIl9vbnBhY2tldCIsIm9uZXZlbnQiLCJCSU5BUllfRVZFTlQiLCJBQ0siLCJvbmFjayIsIkJJTkFSWV9BQ0siLCJESVNDT05ORUNUIiwib25kaXNjb25uZWN0IiwiX2FueUxpc3RlbmVycyIsImxpc3RlbmVycyIsInNsaWNlIiwibGlzdGVuZXIiLCJkaXNwYXRjaCIsInNlbGYiLCJzZW50IiwicHJvdG90eXBlIiwiYXJndW1lbnRzIiwiZ2V0IiwiX29uY2xvc2UiLCJfb25lcnJvciIsImVyciIsImVtaXRSZXNlcnZlZCIsInJlYXNvbiIsImRlc2NyaXB0aW9uIiwicGVyc2lzdFNlc3Npb24iLCJfY2xlYW51cCIsIl9yZW1vdmUiLCJfZXJyb3IiLCJDT05ORUNUX0VSUk9SIiwiZGlzY29ubmVjdCIsImNsb3NlIiwiX2Rpc2Nvbm5lY3QiLCJ2b2xhdGlsZSIsImxvY2FsIiwiZXZlbnQiLCJydW4iLCJwcm9jZXNzIiwibmV4dFRpY2siLCJlbWl0VW50eXBlZCIsInVzZSIsImZuIiwiaSIsImRpc2Nvbm5lY3RlZCIsInNvY2tldFJvb21zIiwib25BbnkiLCJwcmVwZW5kQW55IiwidW5zaGlmdCIsIm9mZkFueSIsInNwbGljZSIsImxpc3RlbmVyc0FueSIsIm9uQW55T3V0Z29pbmciLCJfYW55T3V0Z29pbmdMaXN0ZW5lcnMiLCJwcmVwZW5kQW55T3V0Z29pbmciLCJvZmZBbnlPdXRnb2luZyIsImxpc3RlbmVyc0FueU91dGdvaW5nIiwiQnJvYWRjYXN0T3BlcmF0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/socket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/typed-events.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io/dist/typed-events.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StrictEventEmitter = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\n/**\n * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type\n * parameters for mappings of event names to event data types, and strictly\n * types method calls to the `EventEmitter` according to these event maps.\n *\n * @typeParam ListenEvents - `EventsMap` of user-defined events that can be\n * listened to with `on` or `once`\n * @typeParam EmitEvents - `EventsMap` of user-defined events that can be\n * emitted with `emit`\n * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be\n * emitted by socket.io with `emitReserved`, and can be listened to with\n * `listen`.\n */ class StrictEventEmitter extends events_1.EventEmitter {\n    /**\n     * Adds the `listener` function as an event listener for `ev`.\n     *\n     * @param ev Name of the event\n     * @param listener Callback function\n     */ on(ev, listener) {\n        return super.on(ev, listener);\n    }\n    /**\n     * Adds a one-time `listener` function as an event listener for `ev`.\n     *\n     * @param ev Name of the event\n     * @param listener Callback function\n     */ once(ev, listener) {\n        return super.once(ev, listener);\n    }\n    /**\n     * Emits an event.\n     *\n     * @param ev Name of the event\n     * @param args Values to send to listeners of this event\n     */ emit(ev, ...args) {\n        return super.emit(ev, ...args);\n    }\n    /**\n     * Emits a reserved event.\n     *\n     * This method is `protected`, so that only a class extending\n     * `StrictEventEmitter` can emit its own reserved events.\n     *\n     * @param ev Reserved event name\n     * @param args Arguments to emit along with the event\n     */ emitReserved(ev, ...args) {\n        return super.emit(ev, ...args);\n    }\n    /**\n     * Emits an event.\n     *\n     * This method is `protected`, so that only a class extending\n     * `StrictEventEmitter` can get around the strict typing. This is useful for\n     * calling `emit.apply`, which can be called as `emitUntyped.apply`.\n     *\n     * @param ev Event name\n     * @param args Arguments to emit along with the event\n     */ emitUntyped(ev, ...args) {\n        return super.emit(ev, ...args);\n    }\n    /**\n     * Returns the listeners listening to an event.\n     *\n     * @param event Event name\n     * @returns Array of listeners subscribed to `event`\n     */ listeners(event) {\n        return super.listeners(event);\n    }\n}\nexports.StrictEventEmitter = StrictEventEmitter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvdHlwZWQtZXZlbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQkFBMEIsR0FBRyxLQUFLO0FBQ2xDLE1BQU1HLFdBQVdDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNELE1BQU1GLDJCQUEyQkMsU0FBU0UsWUFBWTtJQUNsRDs7Ozs7S0FLQyxHQUNEQyxHQUFHQyxFQUFFLEVBQUVDLFFBQVEsRUFBRTtRQUNiLE9BQU8sS0FBSyxDQUFDRixHQUFHQyxJQUFJQztJQUN4QjtJQUNBOzs7OztLQUtDLEdBQ0RDLEtBQUtGLEVBQUUsRUFBRUMsUUFBUSxFQUFFO1FBQ2YsT0FBTyxLQUFLLENBQUNDLEtBQUtGLElBQUlDO0lBQzFCO0lBQ0E7Ozs7O0tBS0MsR0FDREUsS0FBS0gsRUFBRSxFQUFFLEdBQUdJLElBQUksRUFBRTtRQUNkLE9BQU8sS0FBSyxDQUFDRCxLQUFLSCxPQUFPSTtJQUM3QjtJQUNBOzs7Ozs7OztLQVFDLEdBQ0RDLGFBQWFMLEVBQUUsRUFBRSxHQUFHSSxJQUFJLEVBQUU7UUFDdEIsT0FBTyxLQUFLLENBQUNELEtBQUtILE9BQU9JO0lBQzdCO0lBQ0E7Ozs7Ozs7OztLQVNDLEdBQ0RFLFlBQVlOLEVBQUUsRUFBRSxHQUFHSSxJQUFJLEVBQUU7UUFDckIsT0FBTyxLQUFLLENBQUNELEtBQUtILE9BQU9JO0lBQzdCO0lBQ0E7Ozs7O0tBS0MsR0FDREcsVUFBVUMsS0FBSyxFQUFFO1FBQ2IsT0FBTyxLQUFLLENBQUNELFVBQVVDO0lBQzNCO0FBQ0o7QUFDQWYsMEJBQTBCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmlydmFhbmFhLWVjb21tZXJjZS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC90eXBlZC1ldmVudHMuanM/ZGMyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RyaWN0RXZlbnRFbWl0dGVyID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuLyoqXG4gKiBTdHJpY3RseSB0eXBlZCB2ZXJzaW9uIG9mIGFuIGBFdmVudEVtaXR0ZXJgLiBBIGBUeXBlZEV2ZW50RW1pdHRlcmAgdGFrZXMgdHlwZVxuICogcGFyYW1ldGVycyBmb3IgbWFwcGluZ3Mgb2YgZXZlbnQgbmFtZXMgdG8gZXZlbnQgZGF0YSB0eXBlcywgYW5kIHN0cmljdGx5XG4gKiB0eXBlcyBtZXRob2QgY2FsbHMgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGFjY29yZGluZyB0byB0aGVzZSBldmVudCBtYXBzLlxuICpcbiAqIEB0eXBlUGFyYW0gTGlzdGVuRXZlbnRzIC0gYEV2ZW50c01hcGAgb2YgdXNlci1kZWZpbmVkIGV2ZW50cyB0aGF0IGNhbiBiZVxuICogbGlzdGVuZWQgdG8gd2l0aCBgb25gIG9yIGBvbmNlYFxuICogQHR5cGVQYXJhbSBFbWl0RXZlbnRzIC0gYEV2ZW50c01hcGAgb2YgdXNlci1kZWZpbmVkIGV2ZW50cyB0aGF0IGNhbiBiZVxuICogZW1pdHRlZCB3aXRoIGBlbWl0YFxuICogQHR5cGVQYXJhbSBSZXNlcnZlZEV2ZW50cyAtIGBFdmVudHNNYXBgIG9mIHJlc2VydmVkIGV2ZW50cywgdGhhdCBjYW4gYmVcbiAqIGVtaXR0ZWQgYnkgc29ja2V0LmlvIHdpdGggYGVtaXRSZXNlcnZlZGAsIGFuZCBjYW4gYmUgbGlzdGVuZWQgdG8gd2l0aFxuICogYGxpc3RlbmAuXG4gKi9cbmNsYXNzIFN0cmljdEV2ZW50RW1pdHRlciBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgYGxpc3RlbmVyYCBmdW5jdGlvbiBhcyBhbiBldmVudCBsaXN0ZW5lciBmb3IgYGV2YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldiBOYW1lIG9mIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqL1xuICAgIG9uKGV2LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIub24oZXYsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG9uZS10aW1lIGBsaXN0ZW5lcmAgZnVuY3Rpb24gYXMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGBldmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgTmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBvbmNlKGV2LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIub25jZShldiwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldiBOYW1lIG9mIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSBhcmdzIFZhbHVlcyB0byBzZW5kIHRvIGxpc3RlbmVycyBvZiB0aGlzIGV2ZW50XG4gICAgICovXG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldiwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGEgcmVzZXJ2ZWQgZXZlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBgcHJvdGVjdGVkYCwgc28gdGhhdCBvbmx5IGEgY2xhc3MgZXh0ZW5kaW5nXG4gICAgICogYFN0cmljdEV2ZW50RW1pdHRlcmAgY2FuIGVtaXQgaXRzIG93biByZXNlcnZlZCBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgUmVzZXJ2ZWQgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIEFyZ3VtZW50cyB0byBlbWl0IGFsb25nIHdpdGggdGhlIGV2ZW50XG4gICAgICovXG4gICAgZW1pdFJlc2VydmVkKGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBgcHJvdGVjdGVkYCwgc28gdGhhdCBvbmx5IGEgY2xhc3MgZXh0ZW5kaW5nXG4gICAgICogYFN0cmljdEV2ZW50RW1pdHRlcmAgY2FuIGdldCBhcm91bmQgdGhlIHN0cmljdCB0eXBpbmcuIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgICAqIGNhbGxpbmcgYGVtaXQuYXBwbHlgLCB3aGljaCBjYW4gYmUgY2FsbGVkIGFzIGBlbWl0VW50eXBlZC5hcHBseWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgRXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIEFyZ3VtZW50cyB0byBlbWl0IGFsb25nIHdpdGggdGhlIGV2ZW50XG4gICAgICovXG4gICAgZW1pdFVudHlwZWQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IEV2ZW50IG5hbWVcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBsaXN0ZW5lcnMgc3Vic2NyaWJlZCB0byBgZXZlbnRgXG4gICAgICovXG4gICAgbGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBzdXBlci5saXN0ZW5lcnMoZXZlbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyaWN0RXZlbnRFbWl0dGVyID0gU3RyaWN0RXZlbnRFbWl0dGVyO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU3RyaWN0RXZlbnRFbWl0dGVyIiwiZXZlbnRzXzEiLCJyZXF1aXJlIiwiRXZlbnRFbWl0dGVyIiwib24iLCJldiIsImxpc3RlbmVyIiwib25jZSIsImVtaXQiLCJhcmdzIiwiZW1pdFJlc2VydmVkIiwiZW1pdFVudHlwZWQiLCJsaXN0ZW5lcnMiLCJldmVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/typed-events.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/uws.js":
/*!********************************************!*\
  !*** ./node_modules/socket.io/dist/uws.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.patchAdapter = patchAdapter;\nexports.restoreAdapter = restoreAdapter;\nexports.serveFile = serveFile;\nconst socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/index.js\");\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst debug = (0, debug_1.default)(\"socket.io:adapter-uws\");\nconst SEPARATOR = \"\\x1f\"; // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nconst { addAll, del, broadcast } = socket_io_adapter_1.Adapter.prototype;\nfunction patchAdapter(app /* : TemplatedApp */ ) {\n    socket_io_adapter_1.Adapter.prototype.addAll = function(id, rooms) {\n        const isNew = !this.sids.has(id);\n        addAll.call(this, id, rooms);\n        const socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);\n        if (!socket) {\n            return;\n        }\n        if (socket.conn.transport.name === \"websocket\") {\n            subscribe(this.nsp.name, socket, isNew, rooms);\n            return;\n        }\n        if (isNew) {\n            socket.conn.on(\"upgrade\", ()=>{\n                const rooms = this.sids.get(id);\n                if (rooms) {\n                    subscribe(this.nsp.name, socket, isNew, rooms);\n                }\n            });\n        }\n    };\n    socket_io_adapter_1.Adapter.prototype.del = function(id, room) {\n        del.call(this, id, room);\n        const socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);\n        if (socket && socket.conn.transport.name === \"websocket\") {\n            // @ts-ignore\n            const sessionId = socket.conn.id;\n            // @ts-ignore\n            const websocket = socket.conn.transport.socket;\n            const topic = `${this.nsp.name}${SEPARATOR}${room}`;\n            debug(\"unsubscribe connection %s from topic %s\", sessionId, topic);\n            websocket.unsubscribe(topic);\n        }\n    };\n    socket_io_adapter_1.Adapter.prototype.broadcast = function(packet, opts) {\n        const useFastPublish = opts.rooms.size <= 1 && opts.except.size === 0;\n        if (!useFastPublish) {\n            broadcast.call(this, packet, opts);\n            return;\n        }\n        const flags = opts.flags || {};\n        const basePacketOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress\n        };\n        packet.nsp = this.nsp.name;\n        const encodedPackets = this.encoder.encode(packet);\n        const topic = opts.rooms.size === 0 ? this.nsp.name : `${this.nsp.name}${SEPARATOR}${opts.rooms.keys().next().value}`;\n        debug(\"fast publish to %s\", topic);\n        // fast publish for clients connected with WebSocket\n        encodedPackets.forEach((encodedPacket)=>{\n            const isBinary = typeof encodedPacket !== \"string\";\n            // \"4\" being the message type in the Engine.IO protocol, see https://github.com/socketio/engine.io-protocol\n            app.publish(topic, isBinary ? encodedPacket : \"4\" + encodedPacket, isBinary);\n        });\n        this.apply(opts, (socket)=>{\n            if (socket.conn.transport.name !== \"websocket\") {\n                // classic publish for clients connected with HTTP long-polling\n                socket.client.writeToEngine(encodedPackets, basePacketOpts);\n            }\n        });\n    };\n}\nfunction subscribe(namespaceName, socket, isNew, rooms) {\n    // @ts-ignore\n    const sessionId = socket.conn.id;\n    // @ts-ignore\n    const websocket = socket.conn.transport.socket;\n    if (isNew) {\n        debug(\"subscribe connection %s to topic %s\", sessionId, namespaceName);\n        websocket.subscribe(namespaceName);\n    }\n    rooms.forEach((room)=>{\n        const topic = `${namespaceName}${SEPARATOR}${room}`; // '#' can be used as wildcard\n        debug(\"subscribe connection %s to topic %s\", sessionId, topic);\n        websocket.subscribe(topic);\n    });\n}\nfunction restoreAdapter() {\n    socket_io_adapter_1.Adapter.prototype.addAll = addAll;\n    socket_io_adapter_1.Adapter.prototype.del = del;\n    socket_io_adapter_1.Adapter.prototype.broadcast = broadcast;\n}\nconst toArrayBuffer = (buffer)=>{\n    const { buffer: arrayBuffer, byteOffset, byteLength } = buffer;\n    return arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n};\n// imported from https://github.com/kolodziejczak-sz/uwebsocket-serve\nfunction serveFile(res /* : HttpResponse */ , filepath) {\n    const { size } = (0, fs_1.statSync)(filepath);\n    const readStream = (0, fs_1.createReadStream)(filepath);\n    const destroyReadStream = ()=>!readStream.destroyed && readStream.destroy();\n    const onError = (error)=>{\n        destroyReadStream();\n        throw error;\n    };\n    const onDataChunk = (chunk)=>{\n        const arrayBufferChunk = toArrayBuffer(chunk);\n        res.cork(()=>{\n            const lastOffset = res.getWriteOffset();\n            const [ok, done] = res.tryEnd(arrayBufferChunk, size);\n            if (!done && !ok) {\n                readStream.pause();\n                res.onWritable((offset)=>{\n                    const [ok, done] = res.tryEnd(arrayBufferChunk.slice(offset - lastOffset), size);\n                    if (!done && ok) {\n                        readStream.resume();\n                    }\n                    return ok;\n                });\n            }\n        });\n    };\n    res.onAborted(destroyReadStream);\n    readStream.on(\"data\", onDataChunk).on(\"error\", onError).on(\"end\", destroyReadStream);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvdXdzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsb0JBQW9CLEdBQUdFO0FBQ3ZCRixzQkFBc0IsR0FBR0c7QUFDekJILGlCQUFpQixHQUFHSTtBQUNwQixNQUFNQyxzQkFBc0JDLG1CQUFPQSxDQUFDLCtFQUFtQjtBQUN2RCxNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQyxjQUFJO0FBQ3pCLE1BQU1FLFVBQVViLGdCQUFnQlcsbUJBQU9BLENBQUMsNkVBQU87QUFDL0MsTUFBTUcsUUFBUSxDQUFDLEdBQUdELFFBQVFFLE9BQU8sRUFBRTtBQUNuQyxNQUFNQyxZQUFZLFFBQVEsbUVBQW1FO0FBQzdGLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxHQUFHLEVBQUVDLFNBQVMsRUFBRSxHQUFHVCxvQkFBb0JVLE9BQU8sQ0FBQ0MsU0FBUztBQUN4RSxTQUFTZCxhQUFhZSxJQUFJLGtCQUFrQixHQUFuQjtJQUNyQlosb0JBQW9CVSxPQUFPLENBQUNDLFNBQVMsQ0FBQ0osTUFBTSxHQUFHLFNBQVVNLEVBQUUsRUFBRUMsS0FBSztRQUM5RCxNQUFNQyxRQUFRLENBQUMsSUFBSSxDQUFDQyxJQUFJLENBQUNDLEdBQUcsQ0FBQ0o7UUFDN0JOLE9BQU9XLElBQUksQ0FBQyxJQUFJLEVBQUVMLElBQUlDO1FBQ3RCLE1BQU1LLFNBQVMsSUFBSSxDQUFDQyxHQUFHLENBQUNDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDVCxPQUFPLElBQUksQ0FBQ08sR0FBRyxDQUFDRyxrQkFBa0IsQ0FBQ0QsR0FBRyxDQUFDVDtRQUMzRSxJQUFJLENBQUNN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R25DLEtBQUsrRCxRQUFRLEVBQUVEO0lBQ3BDLE1BQU1FLGFBQWEsQ0FBQyxHQUFHaEUsS0FBS2lFLGdCQUFnQixFQUFFSDtJQUM5QyxNQUFNSSxvQkFBb0IsSUFBTSxDQUFDRixXQUFXRyxTQUFTLElBQUlILFdBQVdJLE9BQU87SUFDM0UsTUFBTUMsVUFBVSxDQUFDQztRQUNiSjtRQUNBLE1BQU1JO0lBQ1Y7SUFDQSxNQUFNQyxjQUFjLENBQUNDO1FBQ2pCLE1BQU1DLG1CQUFtQmxCLGNBQWNpQjtRQUN2Q1gsSUFBSWEsSUFBSSxDQUFDO1lBQ0wsTUFBTUMsYUFBYWQsSUFBSWUsY0FBYztZQUNyQyxNQUFNLENBQUNDLElBQUlDLEtBQUssR0FBR2pCLElBQUlrQixNQUFNLENBQUNOLGtCQUFrQnRDO1lBQ2hELElBQUksQ0FBQzJDLFFBQVEsQ0FBQ0QsSUFBSTtnQkFDZGIsV0FBV2dCLEtBQUs7Z0JBQ2hCbkIsSUFBSW9CLFVBQVUsQ0FBQyxDQUFDQztvQkFDWixNQUFNLENBQUNMLElBQUlDLEtBQUssR0FBR2pCLElBQUlrQixNQUFNLENBQUNOLGlCQUFpQmIsS0FBSyxDQUFDc0IsU0FBU1AsYUFBYXhDO29CQUMzRSxJQUFJLENBQUMyQyxRQUFRRCxJQUFJO3dCQUNiYixXQUFXbUIsTUFBTTtvQkFDckI7b0JBQ0EsT0FBT047Z0JBQ1g7WUFDSjtRQUNKO0lBQ0o7SUFDQWhCLElBQUl1QixTQUFTLENBQUNsQjtJQUNkRixXQUNLdEMsRUFBRSxDQUFDLFFBQVE2QyxhQUNYN0MsRUFBRSxDQUFDLFNBQVMyQyxTQUNaM0MsRUFBRSxDQUFDLE9BQU93QztBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL25pcnZhYW5hYS1lY29tbWVyY2UvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvdXdzLmpzPzBiZDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhdGNoQWRhcHRlciA9IHBhdGNoQWRhcHRlcjtcbmV4cG9ydHMucmVzdG9yZUFkYXB0ZXIgPSByZXN0b3JlQWRhcHRlcjtcbmV4cG9ydHMuc2VydmVGaWxlID0gc2VydmVGaWxlO1xuY29uc3Qgc29ja2V0X2lvX2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCJzb2NrZXQuaW8tYWRhcHRlclwiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwic29ja2V0LmlvOmFkYXB0ZXItdXdzXCIpO1xuY29uc3QgU0VQQVJBVE9SID0gXCJcXHgxZlwiOyAvLyBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVsaW1pdGVyI0FTQ0lJX2RlbGltaXRlZF90ZXh0XG5jb25zdCB7IGFkZEFsbCwgZGVsLCBicm9hZGNhc3QgfSA9IHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlci5wcm90b3R5cGU7XG5mdW5jdGlvbiBwYXRjaEFkYXB0ZXIoYXBwIC8qIDogVGVtcGxhdGVkQXBwICovKSB7XG4gICAgc29ja2V0X2lvX2FkYXB0ZXJfMS5BZGFwdGVyLnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbiAoaWQsIHJvb21zKSB7XG4gICAgICAgIGNvbnN0IGlzTmV3ID0gIXRoaXMuc2lkcy5oYXMoaWQpO1xuICAgICAgICBhZGRBbGwuY2FsbCh0aGlzLCBpZCwgcm9vbXMpO1xuICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLm5zcC5zb2NrZXRzLmdldChpZCkgfHwgdGhpcy5uc3AuX3ByZUNvbm5lY3RTb2NrZXRzLmdldChpZCk7XG4gICAgICAgIGlmICghc29ja2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvY2tldC5jb25uLnRyYW5zcG9ydC5uYW1lID09PSBcIndlYnNvY2tldFwiKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmUodGhpcy5uc3AubmFtZSwgc29ja2V0LCBpc05ldywgcm9vbXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05ldykge1xuICAgICAgICAgICAgc29ja2V0LmNvbm4ub24oXCJ1cGdyYWRlXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByb29tcyA9IHRoaXMuc2lkcy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChyb29tcykge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUodGhpcy5uc3AubmFtZSwgc29ja2V0LCBpc05ldywgcm9vbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIChpZCwgcm9vbSkge1xuICAgICAgICBkZWwuY2FsbCh0aGlzLCBpZCwgcm9vbSk7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubnNwLnNvY2tldHMuZ2V0KGlkKSB8fCB0aGlzLm5zcC5fcHJlQ29ubmVjdFNvY2tldHMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKHNvY2tldCAmJiBzb2NrZXQuY29ubi50cmFuc3BvcnQubmFtZSA9PT0gXCJ3ZWJzb2NrZXRcIikge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gc29ja2V0LmNvbm4uaWQ7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCB3ZWJzb2NrZXQgPSBzb2NrZXQuY29ubi50cmFuc3BvcnQuc29ja2V0O1xuICAgICAgICAgICAgY29uc3QgdG9waWMgPSBgJHt0aGlzLm5zcC5uYW1lfSR7U0VQQVJBVE9SfSR7cm9vbX1gO1xuICAgICAgICAgICAgZGVidWcoXCJ1bnN1YnNjcmliZSBjb25uZWN0aW9uICVzIGZyb20gdG9waWMgJXNcIiwgc2Vzc2lvbklkLCB0b3BpYyk7XG4gICAgICAgICAgICB3ZWJzb2NrZXQudW5zdWJzY3JpYmUodG9waWMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIucHJvdG90eXBlLmJyb2FkY2FzdCA9IGZ1bmN0aW9uIChwYWNrZXQsIG9wdHMpIHtcbiAgICAgICAgY29uc3QgdXNlRmFzdFB1Ymxpc2ggPSBvcHRzLnJvb21zLnNpemUgPD0gMSAmJiBvcHRzLmV4Y2VwdC5zaXplID09PSAwO1xuICAgICAgICBpZiAoIXVzZUZhc3RQdWJsaXNoKSB7XG4gICAgICAgICAgICBicm9hZGNhc3QuY2FsbCh0aGlzLCBwYWNrZXQsIG9wdHMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZsYWdzID0gb3B0cy5mbGFncyB8fCB7fTtcbiAgICAgICAgY29uc3QgYmFzZVBhY2tldE9wdHMgPSB7XG4gICAgICAgICAgICBwcmVFbmNvZGVkOiB0cnVlLFxuICAgICAgICAgICAgdm9sYXRpbGU6IGZsYWdzLnZvbGF0aWxlLFxuICAgICAgICAgICAgY29tcHJlc3M6IGZsYWdzLmNvbXByZXNzLFxuICAgICAgICB9O1xuICAgICAgICBwYWNrZXQubnNwID0gdGhpcy5uc3AubmFtZTtcbiAgICAgICAgY29uc3QgZW5jb2RlZFBhY2tldHMgPSB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCk7XG4gICAgICAgIGNvbnN0IHRvcGljID0gb3B0cy5yb29tcy5zaXplID09PSAwXG4gICAgICAgICAgICA/IHRoaXMubnNwLm5hbWVcbiAgICAgICAgICAgIDogYCR7dGhpcy5uc3AubmFtZX0ke1NFUEFSQVRPUn0ke29wdHMucm9vbXMua2V5cygpLm5leHQoKS52YWx1ZX1gO1xuICAgICAgICBkZWJ1ZyhcImZhc3QgcHVibGlzaCB0byAlc1wiLCB0b3BpYyk7XG4gICAgICAgIC8vIGZhc3QgcHVibGlzaCBmb3IgY2xpZW50cyBjb25uZWN0ZWQgd2l0aCBXZWJTb2NrZXRcbiAgICAgICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaCgoZW5jb2RlZFBhY2tldCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNCaW5hcnkgPSB0eXBlb2YgZW5jb2RlZFBhY2tldCAhPT0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgIC8vIFwiNFwiIGJlaW5nIHRoZSBtZXNzYWdlIHR5cGUgaW4gdGhlIEVuZ2luZS5JTyBwcm90b2NvbCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NrZXRpby9lbmdpbmUuaW8tcHJvdG9jb2xcbiAgICAgICAgICAgIGFwcC5wdWJsaXNoKHRvcGljLCBpc0JpbmFyeSA/IGVuY29kZWRQYWNrZXQgOiBcIjRcIiArIGVuY29kZWRQYWNrZXQsIGlzQmluYXJ5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXBwbHkob3B0cywgKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNvY2tldC5jb25uLnRyYW5zcG9ydC5uYW1lICE9PSBcIndlYnNvY2tldFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gY2xhc3NpYyBwdWJsaXNoIGZvciBjbGllbnRzIGNvbm5lY3RlZCB3aXRoIEhUVFAgbG9uZy1wb2xsaW5nXG4gICAgICAgICAgICAgICAgc29ja2V0LmNsaWVudC53cml0ZVRvRW5naW5lKGVuY29kZWRQYWNrZXRzLCBiYXNlUGFja2V0T3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBzdWJzY3JpYmUobmFtZXNwYWNlTmFtZSwgc29ja2V0LCBpc05ldywgcm9vbXMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgc2Vzc2lvbklkID0gc29ja2V0LmNvbm4uaWQ7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHdlYnNvY2tldCA9IHNvY2tldC5jb25uLnRyYW5zcG9ydC5zb2NrZXQ7XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICAgIGRlYnVnKFwic3Vic2NyaWJlIGNvbm5lY3Rpb24gJXMgdG8gdG9waWMgJXNcIiwgc2Vzc2lvbklkLCBuYW1lc3BhY2VOYW1lKTtcbiAgICAgICAgd2Vic29ja2V0LnN1YnNjcmliZShuYW1lc3BhY2VOYW1lKTtcbiAgICB9XG4gICAgcm9vbXMuZm9yRWFjaCgocm9vbSkgPT4ge1xuICAgICAgICBjb25zdCB0b3BpYyA9IGAke25hbWVzcGFjZU5hbWV9JHtTRVBBUkFUT1J9JHtyb29tfWA7IC8vICcjJyBjYW4gYmUgdXNlZCBhcyB3aWxkY2FyZFxuICAgICAgICBkZWJ1ZyhcInN1YnNjcmliZSBjb25uZWN0aW9uICVzIHRvIHRvcGljICVzXCIsIHNlc3Npb25JZCwgdG9waWMpO1xuICAgICAgICB3ZWJzb2NrZXQuc3Vic2NyaWJlKHRvcGljKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVBZGFwdGVyKCkge1xuICAgIHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlci5wcm90b3R5cGUuYWRkQWxsID0gYWRkQWxsO1xuICAgIHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlci5wcm90b3R5cGUuZGVsID0gZGVsO1xuICAgIHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlci5wcm90b3R5cGUuYnJvYWRjYXN0ID0gYnJvYWRjYXN0O1xufVxuY29uc3QgdG9BcnJheUJ1ZmZlciA9IChidWZmZXIpID0+IHtcbiAgICBjb25zdCB7IGJ1ZmZlcjogYXJyYXlCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGggfSA9IGJ1ZmZlcjtcbiAgICByZXR1cm4gYXJyYXlCdWZmZXIuc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGgpO1xufTtcbi8vIGltcG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2tvbG9kemllamN6YWstc3ovdXdlYnNvY2tldC1zZXJ2ZVxuZnVuY3Rpb24gc2VydmVGaWxlKHJlcyAvKiA6IEh0dHBSZXNwb25zZSAqLywgZmlsZXBhdGgpIHtcbiAgICBjb25zdCB7IHNpemUgfSA9ICgwLCBmc18xLnN0YXRTeW5jKShmaWxlcGF0aCk7XG4gICAgY29uc3QgcmVhZFN0cmVhbSA9ICgwLCBmc18xLmNyZWF0ZVJlYWRTdHJlYW0pKGZpbGVwYXRoKTtcbiAgICBjb25zdCBkZXN0cm95UmVhZFN0cmVhbSA9ICgpID0+ICFyZWFkU3RyZWFtLmRlc3Ryb3llZCAmJiByZWFkU3RyZWFtLmRlc3Ryb3koKTtcbiAgICBjb25zdCBvbkVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgIGRlc3Ryb3lSZWFkU3RyZWFtKCk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH07XG4gICAgY29uc3Qgb25EYXRhQ2h1bmsgPSAoY2h1bmspID0+IHtcbiAgICAgICAgY29uc3QgYXJyYXlCdWZmZXJDaHVuayA9IHRvQXJyYXlCdWZmZXIoY2h1bmspO1xuICAgICAgICByZXMuY29yaygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsYXN0T2Zmc2V0ID0gcmVzLmdldFdyaXRlT2Zmc2V0KCk7XG4gICAgICAgICAgICBjb25zdCBbb2ssIGRvbmVdID0gcmVzLnRyeUVuZChhcnJheUJ1ZmZlckNodW5rLCBzaXplKTtcbiAgICAgICAgICAgIGlmICghZG9uZSAmJiAhb2spIHtcbiAgICAgICAgICAgICAgICByZWFkU3RyZWFtLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgcmVzLm9uV3JpdGFibGUoKG9mZnNldCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbb2ssIGRvbmVdID0gcmVzLnRyeUVuZChhcnJheUJ1ZmZlckNodW5rLnNsaWNlKG9mZnNldCAtIGxhc3RPZmZzZXQpLCBzaXplKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb25lICYmIG9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkU3RyZWFtLnJlc3VtZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvaztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXMub25BYm9ydGVkKGRlc3Ryb3lSZWFkU3RyZWFtKTtcbiAgICByZWFkU3RyZWFtXG4gICAgICAgIC5vbihcImRhdGFcIiwgb25EYXRhQ2h1bmspXG4gICAgICAgIC5vbihcImVycm9yXCIsIG9uRXJyb3IpXG4gICAgICAgIC5vbihcImVuZFwiLCBkZXN0cm95UmVhZFN0cmVhbSk7XG59XG4iXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicGF0Y2hBZGFwdGVyIiwicmVzdG9yZUFkYXB0ZXIiLCJzZXJ2ZUZpbGUiLCJzb2NrZXRfaW9fYWRhcHRlcl8xIiwicmVxdWlyZSIsImZzXzEiLCJkZWJ1Z18xIiwiZGVidWciLCJkZWZhdWx0IiwiU0VQQVJBVE9SIiwiYWRkQWxsIiwiZGVsIiwiYnJvYWRjYXN0IiwiQWRhcHRlciIsInByb3RvdHlwZSIsImFwcCIsImlkIiwicm9vbXMiLCJpc05ldyIsInNpZHMiLCJoYXMiLCJjYWxsIiwic29ja2V0IiwibnNwIiwic29ja2V0cyIsImdldCIsIl9wcmVDb25uZWN0U29ja2V0cyIsImNvbm4iLCJ0cmFuc3BvcnQiLCJuYW1lIiwic3Vic2NyaWJlIiwib24iLCJyb29tIiwic2Vzc2lvbklkIiwid2Vic29ja2V0IiwidG9waWMiLCJ1bnN1YnNjcmliZSIsInBhY2tldCIsIm9wdHMiLCJ1c2VGYXN0UHVibGlzaCIsInNpemUiLCJleGNlcHQiLCJmbGFncyIsImJhc2VQYWNrZXRPcHRzIiwicHJlRW5jb2RlZCIsInZvbGF0aWxlIiwiY29tcHJlc3MiLCJlbmNvZGVkUGFja2V0cyIsImVuY29kZXIiLCJlbmNvZGUiLCJrZXlzIiwibmV4dCIsImZvckVhY2giLCJlbmNvZGVkUGFja2V0IiwiaXNCaW5hcnkiLCJwdWJsaXNoIiwiYXBwbHkiLCJjbGllbnQiLCJ3cml0ZVRvRW5naW5lIiwibmFtZXNwYWNlTmFtZSIsInRvQXJyYXlCdWZmZXIiLCJidWZmZXIiLCJhcnJheUJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwic2xpY2UiLCJyZXMiLCJmaWxlcGF0aCIsInN0YXRTeW5jIiwicmVhZFN0cmVhbSIsImNyZWF0ZVJlYWRTdHJlYW0iLCJkZXN0cm95UmVhZFN0cmVhbSIsImRlc3Ryb3llZCIsImRlc3Ryb3kiLCJvbkVycm9yIiwiZXJyb3IiLCJvbkRhdGFDaHVuayIsImNodW5rIiwiYXJyYXlCdWZmZXJDaHVuayIsImNvcmsiLCJsYXN0T2Zmc2V0IiwiZ2V0V3JpdGVPZmZzZXQiLCJvayIsImRvbmUiLCJ0cnlFbmQiLCJwYXVzZSIsIm9uV3JpdGFibGUiLCJvZmZzZXQiLCJyZXN1bWUiLCJvbkFib3J0ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/uws.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/package.json":
/*!*********************************************!*\
  !*** ./node_modules/socket.io/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"socket.io","version":"4.8.1","description":"node.js realtime framework server","keywords":["realtime","framework","websocket","tcp","events","socket","io"],"files":["dist/","client-dist/","wrapper.mjs","!**/*.tsbuildinfo"],"directories":{"doc":"docs/","example":"example/","lib":"lib/","test":"test/"},"type":"commonjs","main":"./dist/index.js","exports":{"types":"./dist/index.d.ts","import":"./wrapper.mjs","require":"./dist/index.js"},"types":"./dist/index.d.ts","license":"MIT","homepage":"https://github.com/socketio/socket.io/tree/main/packages/socket.io#readme","repository":{"type":"git","url":"git+https://github.com/socketio/socket.io.git"},"bugs":{"url":"https://github.com/socketio/socket.io/issues"},"scripts":{"compile":"rimraf ./dist && tsc","test":"npm run format:check && npm run compile && npm run test:types && npm run test:unit","test:types":"tsd","test:unit":"nyc mocha --require ts-node/register --reporter spec --slow 200 --bail --timeout 10000 test/index.ts","format:check":"prettier --check \\"lib/**/*.ts\\" \\"test/**/*.ts\\"","format:fix":"prettier --write \\"lib/**/*.ts\\" \\"test/**/*.ts\\"","prepack":"npm run compile"},"dependencies":{"accepts":"~1.3.4","base64id":"~2.0.0","cors":"~2.8.5","debug":"~4.3.2","engine.io":"~6.6.0","socket.io-adapter":"~2.5.2","socket.io-parser":"~4.2.4"},"contributors":[{"name":"Guillermo Rauch","email":"rauchg@gmail.com"},{"name":"Arnout Kazemier","email":"info@3rd-eden.com"},{"name":"Vladimir Dronnikov","email":"dronnikov@gmail.com"},{"name":"Einar Otto Stangvik","email":"einaros@gmail.com"}],"engines":{"node":">=10.2.0"},"tsd":{"directory":"test"}}');

/***/ })

};
;