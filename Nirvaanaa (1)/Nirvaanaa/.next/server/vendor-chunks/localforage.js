/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/localforage";
exports.ids = ["vendor-chunks/localforage"];
exports.modules = {

/***/ "(ssr)/./node_modules/localforage/dist/localforage.js":
/*!******************************************************!*\
  !*** ./node_modules/localforage/dist/localforage.js ***!
  \******************************************************/
/***/ ((module) => {

eval("/*!\n    localForage -- Offline Storage, Improved\n    Version 1.10.0\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/ (function(f) {\n    if (true) {\n        module.exports = f();\n    } else { var g; }\n})(function() {\n    var define1, module1, exports1;\n    return (function e(t, n, r) {\n        function s(o, u) {\n            if (!n[o]) {\n                if (!t[o]) {\n                    var a = undefined;\n                    if (!u && a) return require(o, !0);\n                    if (i) return i(o, !0);\n                    var f = new Error(\"Cannot find module '\" + o + \"'\");\n                    throw f.code = \"MODULE_NOT_FOUND\", f;\n                }\n                var l = n[o] = {\n                    exports: {}\n                };\n                t[o][0].call(l.exports, function(e) {\n                    var n = t[o][1][e];\n                    return s(n ? n : e);\n                }, l, l.exports, e, t, n, r);\n            }\n            return n[o].exports;\n        }\n        var i = undefined;\n        for(var o = 0; o < r.length; o++)s(r[o]);\n        return s;\n    })({\n        1: [\n            function(_dereq_, module1, exports1) {\n                (function(global1) {\n                    \"use strict\";\n                    var Mutation = global1.MutationObserver || global1.WebKitMutationObserver;\n                    var scheduleDrain;\n                    {\n                        if (Mutation) {\n                            var called = 0;\n                            var observer = new Mutation(nextTick);\n                            var element = global1.document.createTextNode(\"\");\n                            observer.observe(element, {\n                                characterData: true\n                            });\n                            scheduleDrain = function() {\n                                element.data = called = ++called % 2;\n                            };\n                        } else if (!global1.setImmediate && typeof global1.MessageChannel !== \"undefined\") {\n                            var channel = new global1.MessageChannel();\n                            channel.port1.onmessage = nextTick;\n                            scheduleDrain = function() {\n                                channel.port2.postMessage(0);\n                            };\n                        } else if (\"document\" in global1 && \"onreadystatechange\" in global1.document.createElement(\"script\")) {\n                            scheduleDrain = function() {\n                                // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n                                // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n                                var scriptEl = global1.document.createElement(\"script\");\n                                scriptEl.onreadystatechange = function() {\n                                    nextTick();\n                                    scriptEl.onreadystatechange = null;\n                                    scriptEl.parentNode.removeChild(scriptEl);\n                                    scriptEl = null;\n                                };\n                                global1.document.documentElement.appendChild(scriptEl);\n                            };\n                        } else {\n                            scheduleDrain = function() {\n                                setTimeout(nextTick, 0);\n                            };\n                        }\n                    }\n                    var draining;\n                    var queue = [];\n                    //named nextTick for less confusing stack traces\n                    function nextTick() {\n                        draining = true;\n                        var i, oldQueue;\n                        var len = queue.length;\n                        while(len){\n                            oldQueue = queue;\n                            queue = [];\n                            i = -1;\n                            while(++i < len){\n                                oldQueue[i]();\n                            }\n                            len = queue.length;\n                        }\n                        draining = false;\n                    }\n                    module1.exports = immediate;\n                    function immediate(task) {\n                        if (queue.push(task) === 1 && !draining) {\n                            scheduleDrain();\n                        }\n                    }\n                }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self :  false ? 0 : {});\n            },\n            {}\n        ],\n        2: [\n            function(_dereq_, module1, exports1) {\n                \"use strict\";\n                var immediate = _dereq_(1);\n                /* istanbul ignore next */ function INTERNAL() {}\n                var handlers = {};\n                var REJECTED = [\n                    \"REJECTED\"\n                ];\n                var FULFILLED = [\n                    \"FULFILLED\"\n                ];\n                var PENDING = [\n                    \"PENDING\"\n                ];\n                module1.exports = Promise1;\n                function Promise1(resolver) {\n                    if (typeof resolver !== \"function\") {\n                        throw new TypeError(\"resolver must be a function\");\n                    }\n                    this.state = PENDING;\n                    this.queue = [];\n                    this.outcome = void 0;\n                    if (resolver !== INTERNAL) {\n                        safelyResolveThenable(this, resolver);\n                    }\n                }\n                Promise1.prototype[\"catch\"] = function(onRejected) {\n                    return this.then(null, onRejected);\n                };\n                Promise1.prototype.then = function(onFulfilled, onRejected) {\n                    if (typeof onFulfilled !== \"function\" && this.state === FULFILLED || typeof onRejected !== \"function\" && this.state === REJECTED) {\n                        return this;\n                    }\n                    var promise = new this.constructor(INTERNAL);\n                    if (this.state !== PENDING) {\n                        var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n                        unwrap(promise, resolver, this.outcome);\n                    } else {\n                        this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n                    }\n                    return promise;\n                };\n                function QueueItem(promise, onFulfilled, onRejected) {\n                    this.promise = promise;\n                    if (typeof onFulfilled === \"function\") {\n                        this.onFulfilled = onFulfilled;\n                        this.callFulfilled = this.otherCallFulfilled;\n                    }\n                    if (typeof onRejected === \"function\") {\n                        this.onRejected = onRejected;\n                        this.callRejected = this.otherCallRejected;\n                    }\n                }\n                QueueItem.prototype.callFulfilled = function(value) {\n                    handlers.resolve(this.promise, value);\n                };\n                QueueItem.prototype.otherCallFulfilled = function(value) {\n                    unwrap(this.promise, this.onFulfilled, value);\n                };\n                QueueItem.prototype.callRejected = function(value) {\n                    handlers.reject(this.promise, value);\n                };\n                QueueItem.prototype.otherCallRejected = function(value) {\n                    unwrap(this.promise, this.onRejected, value);\n                };\n                function unwrap(promise, func, value) {\n                    immediate(function() {\n                        var returnValue;\n                        try {\n                            returnValue = func(value);\n                        } catch (e) {\n                            return handlers.reject(promise, e);\n                        }\n                        if (returnValue === promise) {\n                            handlers.reject(promise, new TypeError(\"Cannot resolve promise with itself\"));\n                        } else {\n                            handlers.resolve(promise, returnValue);\n                        }\n                    });\n                }\n                handlers.resolve = function(self1, value) {\n                    var result = tryCatch(getThen, value);\n                    if (result.status === \"error\") {\n                        return handlers.reject(self1, result.value);\n                    }\n                    var thenable = result.value;\n                    if (thenable) {\n                        safelyResolveThenable(self1, thenable);\n                    } else {\n                        self1.state = FULFILLED;\n                        self1.outcome = value;\n                        var i = -1;\n                        var len = self1.queue.length;\n                        while(++i < len){\n                            self1.queue[i].callFulfilled(value);\n                        }\n                    }\n                    return self1;\n                };\n                handlers.reject = function(self1, error) {\n                    self1.state = REJECTED;\n                    self1.outcome = error;\n                    var i = -1;\n                    var len = self1.queue.length;\n                    while(++i < len){\n                        self1.queue[i].callRejected(error);\n                    }\n                    return self1;\n                };\n                function getThen(obj) {\n                    // Make sure we only access the accessor once as required by the spec\n                    var then = obj && obj.then;\n                    if (obj && (typeof obj === \"object\" || typeof obj === \"function\") && typeof then === \"function\") {\n                        return function appyThen() {\n                            then.apply(obj, arguments);\n                        };\n                    }\n                }\n                function safelyResolveThenable(self1, thenable) {\n                    // Either fulfill, reject or reject with error\n                    var called = false;\n                    function onError(value) {\n                        if (called) {\n                            return;\n                        }\n                        called = true;\n                        handlers.reject(self1, value);\n                    }\n                    function onSuccess(value) {\n                        if (called) {\n                            return;\n                        }\n                        called = true;\n                        handlers.resolve(self1, value);\n                    }\n                    function tryToUnwrap() {\n                        thenable(onSuccess, onError);\n                    }\n                    var result = tryCatch(tryToUnwrap);\n                    if (result.status === \"error\") {\n                        onError(result.value);\n                    }\n                }\n                function tryCatch(func, value) {\n                    var out = {};\n                    try {\n                        out.value = func(value);\n                        out.status = \"success\";\n                    } catch (e) {\n                        out.status = \"error\";\n                        out.value = e;\n                    }\n                    return out;\n                }\n                Promise1.resolve = resolve;\n                function resolve(value) {\n                    if (value instanceof this) {\n                        return value;\n                    }\n                    return handlers.resolve(new this(INTERNAL), value);\n                }\n                Promise1.reject = reject;\n                function reject(reason) {\n                    var promise = new this(INTERNAL);\n                    return handlers.reject(promise, reason);\n                }\n                Promise1.all = all;\n                function all(iterable) {\n                    var self1 = this;\n                    if (Object.prototype.toString.call(iterable) !== \"[object Array]\") {\n                        return this.reject(new TypeError(\"must be an array\"));\n                    }\n                    var len = iterable.length;\n                    var called = false;\n                    if (!len) {\n                        return this.resolve([]);\n                    }\n                    var values = new Array(len);\n                    var resolved = 0;\n                    var i = -1;\n                    var promise = new this(INTERNAL);\n                    while(++i < len){\n                        allResolver(iterable[i], i);\n                    }\n                    return promise;\n                    function allResolver(value, i) {\n                        self1.resolve(value).then(resolveFromAll, function(error) {\n                            if (!called) {\n                                called = true;\n                                handlers.reject(promise, error);\n                            }\n                        });\n                        function resolveFromAll(outValue) {\n                            values[i] = outValue;\n                            if (++resolved === len && !called) {\n                                called = true;\n                                handlers.resolve(promise, values);\n                            }\n                        }\n                    }\n                }\n                Promise1.race = race;\n                function race(iterable) {\n                    var self1 = this;\n                    if (Object.prototype.toString.call(iterable) !== \"[object Array]\") {\n                        return this.reject(new TypeError(\"must be an array\"));\n                    }\n                    var len = iterable.length;\n                    var called = false;\n                    if (!len) {\n                        return this.resolve([]);\n                    }\n                    var i = -1;\n                    var promise = new this(INTERNAL);\n                    while(++i < len){\n                        resolver(iterable[i]);\n                    }\n                    return promise;\n                    function resolver(value) {\n                        self1.resolve(value).then(function(response) {\n                            if (!called) {\n                                called = true;\n                                handlers.resolve(promise, response);\n                            }\n                        }, function(error) {\n                            if (!called) {\n                                called = true;\n                                handlers.reject(promise, error);\n                            }\n                        });\n                    }\n                }\n            },\n            {\n                \"1\": 1\n            }\n        ],\n        3: [\n            function(_dereq_, module1, exports1) {\n                (function(global1) {\n                    \"use strict\";\n                    if (typeof global1.Promise !== \"function\") {\n                        global1.Promise = _dereq_(2);\n                    }\n                }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self :  false ? 0 : {});\n            },\n            {\n                \"2\": 2\n            }\n        ],\n        4: [\n            function(_dereq_, module1, exports1) {\n                \"use strict\";\n                var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                };\n                function _classCallCheck(instance, Constructor) {\n                    if (!(instance instanceof Constructor)) {\n                        throw new TypeError(\"Cannot call a class as a function\");\n                    }\n                }\n                function getIDB() {\n                    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */ try {\n                        if (typeof indexedDB !== \"undefined\") {\n                            return indexedDB;\n                        }\n                        if (typeof webkitIndexedDB !== \"undefined\") {\n                            return webkitIndexedDB;\n                        }\n                        if (typeof mozIndexedDB !== \"undefined\") {\n                            return mozIndexedDB;\n                        }\n                        if (typeof OIndexedDB !== \"undefined\") {\n                            return OIndexedDB;\n                        }\n                        if (typeof msIndexedDB !== \"undefined\") {\n                            return msIndexedDB;\n                        }\n                    } catch (e) {\n                        return;\n                    }\n                }\n                var idb = getIDB();\n                function isIndexedDBValid() {\n                    try {\n                        // Initialize IndexedDB; fall back to vendor-prefixed versions\n                        // if needed.\n                        if (!idb || !idb.open) {\n                            return false;\n                        }\n                        // We mimic PouchDB here;\n                        //\n                        // We test for openDatabase because IE Mobile identifies itself\n                        // as Safari. Oh the lulz...\n                        var isSafari = typeof openDatabase !== \"undefined\" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n                        var hasFetch = typeof fetch === \"function\" && fetch.toString().indexOf(\"[native code\") !== -1;\n                        // Safari <10.1 does not meet our requirements for IDB support\n                        // (see: https://github.com/pouchdb/pouchdb/issues/5572).\n                        // Safari 10.1 shipped with fetch, we can use that to detect it.\n                        // Note: this creates issues with `window.fetch` polyfills and\n                        // overrides; see:\n                        // https://github.com/localForage/localForage/issues/856\n                        return (!isSafari || hasFetch) && typeof indexedDB !== \"undefined\" && // some outdated implementations of IDB that appear on Samsung\n                        // and HTC Android devices <4.4 are missing IDBKeyRange\n                        // See: https://github.com/mozilla/localForage/issues/128\n                        // See: https://github.com/mozilla/localForage/issues/272\n                        typeof IDBKeyRange !== \"undefined\";\n                    } catch (e) {\n                        return false;\n                    }\n                }\n                // Abstracts constructing a Blob object, so it also works in older\n                // browsers that don't support the native Blob constructor. (i.e.\n                // old QtWebKit versions, at least).\n                // Abstracts constructing a Blob object, so it also works in older\n                // browsers that don't support the native Blob constructor. (i.e.\n                // old QtWebKit versions, at least).\n                function createBlob(parts, properties) {\n                    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */ parts = parts || [];\n                    properties = properties || {};\n                    try {\n                        return new Blob(parts, properties);\n                    } catch (e) {\n                        if (e.name !== \"TypeError\") {\n                            throw e;\n                        }\n                        var Builder = typeof BlobBuilder !== \"undefined\" ? BlobBuilder : typeof MSBlobBuilder !== \"undefined\" ? MSBlobBuilder : typeof MozBlobBuilder !== \"undefined\" ? MozBlobBuilder : WebKitBlobBuilder;\n                        var builder = new Builder();\n                        for(var i = 0; i < parts.length; i += 1){\n                            builder.append(parts[i]);\n                        }\n                        return builder.getBlob(properties.type);\n                    }\n                }\n                // This is CommonJS because lie is an external dependency, so Rollup\n                // can just ignore it.\n                if (typeof Promise === \"undefined\") {\n                    // In the \"nopromises\" build this will just throw if you don't have\n                    // a global promise object, but it would throw anyway later.\n                    _dereq_(3);\n                }\n                var Promise$1 = Promise;\n                function executeCallback(promise, callback) {\n                    if (callback) {\n                        promise.then(function(result) {\n                            callback(null, result);\n                        }, function(error) {\n                            callback(error);\n                        });\n                    }\n                }\n                function executeTwoCallbacks(promise, callback, errorCallback) {\n                    if (typeof callback === \"function\") {\n                        promise.then(callback);\n                    }\n                    if (typeof errorCallback === \"function\") {\n                        promise[\"catch\"](errorCallback);\n                    }\n                }\n                function normalizeKey(key) {\n                    // Cast the key to a string, as that's all we can set as a key.\n                    if (typeof key !== \"string\") {\n                        console.warn(key + \" used as a key, but it is not a string.\");\n                        key = String(key);\n                    }\n                    return key;\n                }\n                function getCallback() {\n                    if (arguments.length && typeof arguments[arguments.length - 1] === \"function\") {\n                        return arguments[arguments.length - 1];\n                    }\n                }\n                // Some code originally from async_storage.js in\n                // [Gaia](https://github.com/mozilla-b2g/gaia).\n                var DETECT_BLOB_SUPPORT_STORE = \"local-forage-detect-blob-support\";\n                var supportsBlobs = void 0;\n                var dbContexts = {};\n                var toString = Object.prototype.toString;\n                // Transaction Modes\n                var READ_ONLY = \"readonly\";\n                var READ_WRITE = \"readwrite\";\n                // Transform a binary string to an array buffer, because otherwise\n                // weird stuff happens when you try to work with the binary string directly.\n                // It is known.\n                // From http://stackoverflow.com/questions/14967647/ (continues on next line)\n                // encode-decode-image-with-base64-breaks-image (2013-04-21)\n                function _binStringToArrayBuffer(bin) {\n                    var length = bin.length;\n                    var buf = new ArrayBuffer(length);\n                    var arr = new Uint8Array(buf);\n                    for(var i = 0; i < length; i++){\n                        arr[i] = bin.charCodeAt(i);\n                    }\n                    return buf;\n                }\n                //\n                // Blobs are not supported in all versions of IndexedDB, notably\n                // Chrome <37 and Android <5. In those versions, storing a blob will throw.\n                //\n                // Various other blob bugs exist in Chrome v37-42 (inclusive).\n                // Detecting them is expensive and confusing to users, and Chrome 37-42\n                // is at very low usage worldwide, so we do a hacky userAgent check instead.\n                //\n                // content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n                // 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n                // FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n                //\n                // Code borrowed from PouchDB. See:\n                // https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n                //\n                function _checkBlobSupportWithoutCaching(idb) {\n                    return new Promise$1(function(resolve) {\n                        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\n                        var blob = createBlob([\n                            \"\"\n                        ]);\n                        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, \"key\");\n                        txn.onabort = function(e) {\n                            // If the transaction aborts now its due to not being able to\n                            // write to the database, likely due to the disk being full\n                            e.preventDefault();\n                            e.stopPropagation();\n                            resolve(false);\n                        };\n                        txn.oncomplete = function() {\n                            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n                            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n                            // MS Edge pretends to be Chrome 42:\n                            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n                            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n                        };\n                    })[\"catch\"](function() {\n                        return false; // error, so assume unsupported\n                    });\n                }\n                function _checkBlobSupport(idb) {\n                    if (typeof supportsBlobs === \"boolean\") {\n                        return Promise$1.resolve(supportsBlobs);\n                    }\n                    return _checkBlobSupportWithoutCaching(idb).then(function(value) {\n                        supportsBlobs = value;\n                        return supportsBlobs;\n                    });\n                }\n                function _deferReadiness(dbInfo) {\n                    var dbContext = dbContexts[dbInfo.name];\n                    // Create a deferred object representing the current database operation.\n                    var deferredOperation = {};\n                    deferredOperation.promise = new Promise$1(function(resolve, reject) {\n                        deferredOperation.resolve = resolve;\n                        deferredOperation.reject = reject;\n                    });\n                    // Enqueue the deferred operation.\n                    dbContext.deferredOperations.push(deferredOperation);\n                    // Chain its promise to the database readiness.\n                    if (!dbContext.dbReady) {\n                        dbContext.dbReady = deferredOperation.promise;\n                    } else {\n                        dbContext.dbReady = dbContext.dbReady.then(function() {\n                            return deferredOperation.promise;\n                        });\n                    }\n                }\n                function _advanceReadiness(dbInfo) {\n                    var dbContext = dbContexts[dbInfo.name];\n                    // Dequeue a deferred operation.\n                    var deferredOperation = dbContext.deferredOperations.pop();\n                    // Resolve its promise (which is part of the database readiness\n                    // chain of promises).\n                    if (deferredOperation) {\n                        deferredOperation.resolve();\n                        return deferredOperation.promise;\n                    }\n                }\n                function _rejectReadiness(dbInfo, err) {\n                    var dbContext = dbContexts[dbInfo.name];\n                    // Dequeue a deferred operation.\n                    var deferredOperation = dbContext.deferredOperations.pop();\n                    // Reject its promise (which is part of the database readiness\n                    // chain of promises).\n                    if (deferredOperation) {\n                        deferredOperation.reject(err);\n                        return deferredOperation.promise;\n                    }\n                }\n                function _getConnection(dbInfo, upgradeNeeded) {\n                    return new Promise$1(function(resolve, reject) {\n                        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();\n                        if (dbInfo.db) {\n                            if (upgradeNeeded) {\n                                _deferReadiness(dbInfo);\n                                dbInfo.db.close();\n                            } else {\n                                return resolve(dbInfo.db);\n                            }\n                        }\n                        var dbArgs = [\n                            dbInfo.name\n                        ];\n                        if (upgradeNeeded) {\n                            dbArgs.push(dbInfo.version);\n                        }\n                        var openreq = idb.open.apply(idb, dbArgs);\n                        if (upgradeNeeded) {\n                            openreq.onupgradeneeded = function(e) {\n                                var db = openreq.result;\n                                try {\n                                    db.createObjectStore(dbInfo.storeName);\n                                    if (e.oldVersion <= 1) {\n                                        // Added when support for blob shims was added\n                                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                                    }\n                                } catch (ex) {\n                                    if (ex.name === \"ConstraintError\") {\n                                        console.warn('The database \"' + dbInfo.name + '\"' + \" has been upgraded from version \" + e.oldVersion + \" to version \" + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                                    } else {\n                                        throw ex;\n                                    }\n                                }\n                            };\n                        }\n                        openreq.onerror = function(e) {\n                            e.preventDefault();\n                            reject(openreq.error);\n                        };\n                        openreq.onsuccess = function() {\n                            var db = openreq.result;\n                            db.onversionchange = function(e) {\n                                // Triggered when the database is modified (e.g. adding an objectStore) or\n                                // deleted (even when initiated by other sessions in different tabs).\n                                // Closing the connection here prevents those operations from being blocked.\n                                // If the database is accessed again later by this instance, the connection\n                                // will be reopened or the database recreated as needed.\n                                e.target.close();\n                            };\n                            resolve(db);\n                            _advanceReadiness(dbInfo);\n                        };\n                    });\n                }\n                function _getOriginalConnection(dbInfo) {\n                    return _getConnection(dbInfo, false);\n                }\n                function _getUpgradedConnection(dbInfo) {\n                    return _getConnection(dbInfo, true);\n                }\n                function _isUpgradeNeeded(dbInfo, defaultVersion) {\n                    if (!dbInfo.db) {\n                        return true;\n                    }\n                    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n                    var isDowngrade = dbInfo.version < dbInfo.db.version;\n                    var isUpgrade = dbInfo.version > dbInfo.db.version;\n                    if (isDowngrade) {\n                        // If the version is not the default one\n                        // then warn for impossible downgrade.\n                        if (dbInfo.version !== defaultVersion) {\n                            console.warn('The database \"' + dbInfo.name + '\"' + \" can't be downgraded from version \" + dbInfo.db.version + \" to version \" + dbInfo.version + \".\");\n                        }\n                        // Align the versions to prevent errors.\n                        dbInfo.version = dbInfo.db.version;\n                    }\n                    if (isUpgrade || isNewStore) {\n                        // If the store is new then increment the version (if needed).\n                        // This will trigger an \"upgradeneeded\" event which is required\n                        // for creating a store.\n                        if (isNewStore) {\n                            var incVersion = dbInfo.db.version + 1;\n                            if (incVersion > dbInfo.version) {\n                                dbInfo.version = incVersion;\n                            }\n                        }\n                        return true;\n                    }\n                    return false;\n                }\n                // encode a blob for indexeddb engines that don't support blobs\n                function _encodeBlob(blob) {\n                    return new Promise$1(function(resolve, reject) {\n                        var reader = new FileReader();\n                        reader.onerror = reject;\n                        reader.onloadend = function(e) {\n                            var base64 = btoa(e.target.result || \"\");\n                            resolve({\n                                __local_forage_encoded_blob: true,\n                                data: base64,\n                                type: blob.type\n                            });\n                        };\n                        reader.readAsBinaryString(blob);\n                    });\n                }\n                // decode an encoded blob\n                function _decodeBlob(encodedBlob) {\n                    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n                    return createBlob([\n                        arrayBuff\n                    ], {\n                        type: encodedBlob.type\n                    });\n                }\n                // is this one of our fancy encoded blobs?\n                function _isEncodedBlob(value) {\n                    return value && value.__local_forage_encoded_blob;\n                }\n                // Specialize the default `ready()` function by making it dependent\n                // on the current database operations. Thus, the driver will be actually\n                // ready when it's been initialized (default) *and* there are no pending\n                // operations on the database (initiated by some other instances).\n                function _fullyReady(callback) {\n                    var self1 = this;\n                    var promise = self1._initReady().then(function() {\n                        var dbContext = dbContexts[self1._dbInfo.name];\n                        if (dbContext && dbContext.dbReady) {\n                            return dbContext.dbReady;\n                        }\n                    });\n                    executeTwoCallbacks(promise, callback, callback);\n                    return promise;\n                }\n                // Try to establish a new db connection to replace the\n                // current one which is broken (i.e. experiencing\n                // InvalidStateError while creating a transaction).\n                function _tryReconnect(dbInfo) {\n                    _deferReadiness(dbInfo);\n                    var dbContext = dbContexts[dbInfo.name];\n                    var forages = dbContext.forages;\n                    for(var i = 0; i < forages.length; i++){\n                        var forage = forages[i];\n                        if (forage._dbInfo.db) {\n                            forage._dbInfo.db.close();\n                            forage._dbInfo.db = null;\n                        }\n                    }\n                    dbInfo.db = null;\n                    return _getOriginalConnection(dbInfo).then(function(db) {\n                        dbInfo.db = db;\n                        if (_isUpgradeNeeded(dbInfo)) {\n                            // Reopen the database for upgrading.\n                            return _getUpgradedConnection(dbInfo);\n                        }\n                        return db;\n                    }).then(function(db) {\n                        // store the latest db reference\n                        // in case the db was upgraded\n                        dbInfo.db = dbContext.db = db;\n                        for(var i = 0; i < forages.length; i++){\n                            forages[i]._dbInfo.db = db;\n                        }\n                    })[\"catch\"](function(err) {\n                        _rejectReadiness(dbInfo, err);\n                        throw err;\n                    });\n                }\n                // FF doesn't like Promises (micro-tasks) and IDDB store operations,\n                // so we have to do it with callbacks\n                function createTransaction(dbInfo, mode, callback, retries) {\n                    if (retries === undefined) {\n                        retries = 1;\n                    }\n                    try {\n                        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n                        callback(null, tx);\n                    } catch (err) {\n                        if (retries > 0 && (!dbInfo.db || err.name === \"InvalidStateError\" || err.name === \"NotFoundError\")) {\n                            return Promise$1.resolve().then(function() {\n                                if (!dbInfo.db || err.name === \"NotFoundError\" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {\n                                    // increase the db version, to create the new ObjectStore\n                                    if (dbInfo.db) {\n                                        dbInfo.version = dbInfo.db.version + 1;\n                                    }\n                                    // Reopen the database for upgrading.\n                                    return _getUpgradedConnection(dbInfo);\n                                }\n                            }).then(function() {\n                                return _tryReconnect(dbInfo).then(function() {\n                                    createTransaction(dbInfo, mode, callback, retries - 1);\n                                });\n                            })[\"catch\"](callback);\n                        }\n                        callback(err);\n                    }\n                }\n                function createDbContext() {\n                    return {\n                        // Running localForages sharing a database.\n                        forages: [],\n                        // Shared database.\n                        db: null,\n                        // Database readiness (promise).\n                        dbReady: null,\n                        // Deferred operations on the database.\n                        deferredOperations: []\n                    };\n                }\n                // Open the IndexedDB database (automatically creates one if one didn't\n                // previously exist), using any options set in the config.\n                function _initStorage(options) {\n                    var self1 = this;\n                    var dbInfo = {\n                        db: null\n                    };\n                    if (options) {\n                        for(var i in options){\n                            dbInfo[i] = options[i];\n                        }\n                    }\n                    // Get the current context of the database;\n                    var dbContext = dbContexts[dbInfo.name];\n                    // ...or create a new context.\n                    if (!dbContext) {\n                        dbContext = createDbContext();\n                        // Register the new context in the global container.\n                        dbContexts[dbInfo.name] = dbContext;\n                    }\n                    // Register itself as a running localForage in the current context.\n                    dbContext.forages.push(self1);\n                    // Replace the default `ready()` function with the specialized one.\n                    if (!self1._initReady) {\n                        self1._initReady = self1.ready;\n                        self1.ready = _fullyReady;\n                    }\n                    // Create an array of initialization states of the related localForages.\n                    var initPromises = [];\n                    function ignoreErrors() {\n                        // Don't handle errors here,\n                        // just makes sure related localForages aren't pending.\n                        return Promise$1.resolve();\n                    }\n                    for(var j = 0; j < dbContext.forages.length; j++){\n                        var forage = dbContext.forages[j];\n                        if (forage !== self1) {\n                            // Don't wait for itself...\n                            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n                        }\n                    }\n                    // Take a snapshot of the related localForages.\n                    var forages = dbContext.forages.slice(0);\n                    // Initialize the connection process only when\n                    // all the related localForages aren't pending.\n                    return Promise$1.all(initPromises).then(function() {\n                        dbInfo.db = dbContext.db;\n                        // Get the connection or open a new one without upgrade.\n                        return _getOriginalConnection(dbInfo);\n                    }).then(function(db) {\n                        dbInfo.db = db;\n                        if (_isUpgradeNeeded(dbInfo, self1._defaultConfig.version)) {\n                            // Reopen the database for upgrading.\n                            return _getUpgradedConnection(dbInfo);\n                        }\n                        return db;\n                    }).then(function(db) {\n                        dbInfo.db = dbContext.db = db;\n                        self1._dbInfo = dbInfo;\n                        // Share the final connection amongst related localForages.\n                        for(var k = 0; k < forages.length; k++){\n                            var forage = forages[k];\n                            if (forage !== self1) {\n                                // Self is already up-to-date.\n                                forage._dbInfo.db = dbInfo.db;\n                                forage._dbInfo.version = dbInfo.version;\n                            }\n                        }\n                    });\n                }\n                function getItem(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) {\n                                    return reject(err);\n                                }\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.get(key);\n                                    req.onsuccess = function() {\n                                        var value = req.result;\n                                        if (value === undefined) {\n                                            value = null;\n                                        }\n                                        if (_isEncodedBlob(value)) {\n                                            value = _decodeBlob(value);\n                                        }\n                                        resolve(value);\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Iterate over all items stored in database.\n                function iterate(iterator, callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) {\n                                    return reject(err);\n                                }\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.openCursor();\n                                    var iterationNumber = 1;\n                                    req.onsuccess = function() {\n                                        var cursor = req.result;\n                                        if (cursor) {\n                                            var value = cursor.value;\n                                            if (_isEncodedBlob(value)) {\n                                                value = _decodeBlob(value);\n                                            }\n                                            var result = iterator(value, cursor.key, iterationNumber++);\n                                            // when the iterator callback returns any\n                                            // (non-`undefined`) value, then we stop\n                                            // the iteration immediately\n                                            if (result !== void 0) {\n                                                resolve(result);\n                                            } else {\n                                                cursor[\"continue\"]();\n                                            }\n                                        } else {\n                                            resolve();\n                                        }\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function setItem(key, value, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        var dbInfo;\n                        self1.ready().then(function() {\n                            dbInfo = self1._dbInfo;\n                            if (toString.call(value) === \"[object Blob]\") {\n                                return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {\n                                    if (blobSupport) {\n                                        return value;\n                                    }\n                                    return _encodeBlob(value);\n                                });\n                            }\n                            return value;\n                        }).then(function(value) {\n                            createTransaction(self1._dbInfo, READ_WRITE, function(err, transaction) {\n                                if (err) {\n                                    return reject(err);\n                                }\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    // The reason we don't _save_ null is because IE 10 does\n                                    // not support saving the `null` type in IndexedDB. How\n                                    // ironic, given the bug below!\n                                    // See: https://github.com/mozilla/localForage/issues/161\n                                    if (value === null) {\n                                        value = undefined;\n                                    }\n                                    var req = store.put(value, key);\n                                    transaction.oncomplete = function() {\n                                        // Cast to undefined so the value passed to\n                                        // callback/promise is the same as what one would get out\n                                        // of `getItem()` later. This leads to some weirdness\n                                        // (setItem('foo', undefined) will return `null`), but\n                                        // it's not my fault localStorage is our baseline and that\n                                        // it's weird.\n                                        if (value === undefined) {\n                                            value = null;\n                                        }\n                                        resolve(value);\n                                    };\n                                    transaction.onabort = transaction.onerror = function() {\n                                        var err = req.error ? req.error : req.transaction.error;\n                                        reject(err);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function removeItem(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_WRITE, function(err, transaction) {\n                                if (err) {\n                                    return reject(err);\n                                }\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    // We use a Grunt task to make this safe for IE and some\n                                    // versions of Android (including those used by Cordova).\n                                    // Normally IE won't like `.delete()` and will insist on\n                                    // using `['delete']()`, but we have a build step that\n                                    // fixes this for us now.\n                                    var req = store[\"delete\"](key);\n                                    transaction.oncomplete = function() {\n                                        resolve();\n                                    };\n                                    transaction.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                    // The request will be also be aborted if we've exceeded our storage\n                                    // space.\n                                    transaction.onabort = function() {\n                                        var err = req.error ? req.error : req.transaction.error;\n                                        reject(err);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function clear(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_WRITE, function(err, transaction) {\n                                if (err) {\n                                    return reject(err);\n                                }\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.clear();\n                                    transaction.oncomplete = function() {\n                                        resolve();\n                                    };\n                                    transaction.onabort = transaction.onerror = function() {\n                                        var err = req.error ? req.error : req.transaction.error;\n                                        reject(err);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function length(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) {\n                                    return reject(err);\n                                }\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.count();\n                                    req.onsuccess = function() {\n                                        resolve(req.result);\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function key(n, callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        if (n < 0) {\n                            resolve(null);\n                            return;\n                        }\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) {\n                                    return reject(err);\n                                }\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var advanced = false;\n                                    var req = store.openKeyCursor();\n                                    req.onsuccess = function() {\n                                        var cursor = req.result;\n                                        if (!cursor) {\n                                            // this means there weren't enough keys\n                                            resolve(null);\n                                            return;\n                                        }\n                                        if (n === 0) {\n                                            // We have the first key, return it if that's what they\n                                            // wanted.\n                                            resolve(cursor.key);\n                                        } else {\n                                            if (!advanced) {\n                                                // Otherwise, ask the cursor to skip ahead n\n                                                // records.\n                                                advanced = true;\n                                                cursor.advance(n);\n                                            } else {\n                                                // When we get here, we've got the nth key.\n                                                resolve(cursor.key);\n                                            }\n                                        }\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function keys(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) {\n                                    return reject(err);\n                                }\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.openKeyCursor();\n                                    var keys = [];\n                                    req.onsuccess = function() {\n                                        var cursor = req.result;\n                                        if (!cursor) {\n                                            resolve(keys);\n                                            return;\n                                        }\n                                        keys.push(cursor.key);\n                                        cursor[\"continue\"]();\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function dropInstance(options, callback) {\n                    callback = getCallback.apply(this, arguments);\n                    var currentConfig = this.config();\n                    options = typeof options !== \"function\" && options || {};\n                    if (!options.name) {\n                        options.name = options.name || currentConfig.name;\n                        options.storeName = options.storeName || currentConfig.storeName;\n                    }\n                    var self1 = this;\n                    var promise;\n                    if (!options.name) {\n                        promise = Promise$1.reject(\"Invalid arguments\");\n                    } else {\n                        var isCurrentDb = options.name === currentConfig.name && self1._dbInfo.db;\n                        var dbPromise = isCurrentDb ? Promise$1.resolve(self1._dbInfo.db) : _getOriginalConnection(options).then(function(db) {\n                            var dbContext = dbContexts[options.name];\n                            var forages = dbContext.forages;\n                            dbContext.db = db;\n                            for(var i = 0; i < forages.length; i++){\n                                forages[i]._dbInfo.db = db;\n                            }\n                            return db;\n                        });\n                        if (!options.storeName) {\n                            promise = dbPromise.then(function(db) {\n                                _deferReadiness(options);\n                                var dbContext = dbContexts[options.name];\n                                var forages = dbContext.forages;\n                                db.close();\n                                for(var i = 0; i < forages.length; i++){\n                                    var forage = forages[i];\n                                    forage._dbInfo.db = null;\n                                }\n                                var dropDBPromise = new Promise$1(function(resolve, reject) {\n                                    var req = idb.deleteDatabase(options.name);\n                                    req.onerror = function() {\n                                        var db = req.result;\n                                        if (db) {\n                                            db.close();\n                                        }\n                                        reject(req.error);\n                                    };\n                                    req.onblocked = function() {\n                                        // Closing all open connections in onversionchange handler should prevent this situation, but if\n                                        // we do get here, it just means the request remains pending - eventually it will succeed or error\n                                        console.warn('dropInstance blocked for database \"' + options.name + '\" until all open connections are closed');\n                                    };\n                                    req.onsuccess = function() {\n                                        var db = req.result;\n                                        if (db) {\n                                            db.close();\n                                        }\n                                        resolve(db);\n                                    };\n                                });\n                                return dropDBPromise.then(function(db) {\n                                    dbContext.db = db;\n                                    for(var i = 0; i < forages.length; i++){\n                                        var _forage = forages[i];\n                                        _advanceReadiness(_forage._dbInfo);\n                                    }\n                                })[\"catch\"](function(err) {\n                                    (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function() {});\n                                    throw err;\n                                });\n                            });\n                        } else {\n                            promise = dbPromise.then(function(db) {\n                                if (!db.objectStoreNames.contains(options.storeName)) {\n                                    return;\n                                }\n                                var newVersion = db.version + 1;\n                                _deferReadiness(options);\n                                var dbContext = dbContexts[options.name];\n                                var forages = dbContext.forages;\n                                db.close();\n                                for(var i = 0; i < forages.length; i++){\n                                    var forage = forages[i];\n                                    forage._dbInfo.db = null;\n                                    forage._dbInfo.version = newVersion;\n                                }\n                                var dropObjectPromise = new Promise$1(function(resolve, reject) {\n                                    var req = idb.open(options.name, newVersion);\n                                    req.onerror = function(err) {\n                                        var db = req.result;\n                                        db.close();\n                                        reject(err);\n                                    };\n                                    req.onupgradeneeded = function() {\n                                        var db = req.result;\n                                        db.deleteObjectStore(options.storeName);\n                                    };\n                                    req.onsuccess = function() {\n                                        var db = req.result;\n                                        db.close();\n                                        resolve(db);\n                                    };\n                                });\n                                return dropObjectPromise.then(function(db) {\n                                    dbContext.db = db;\n                                    for(var j = 0; j < forages.length; j++){\n                                        var _forage2 = forages[j];\n                                        _forage2._dbInfo.db = db;\n                                        _advanceReadiness(_forage2._dbInfo);\n                                    }\n                                })[\"catch\"](function(err) {\n                                    (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function() {});\n                                    throw err;\n                                });\n                            });\n                        }\n                    }\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                var asyncStorage = {\n                    _driver: \"asyncStorage\",\n                    _initStorage: _initStorage,\n                    _support: isIndexedDBValid(),\n                    iterate: iterate,\n                    getItem: getItem,\n                    setItem: setItem,\n                    removeItem: removeItem,\n                    clear: clear,\n                    length: length,\n                    key: key,\n                    keys: keys,\n                    dropInstance: dropInstance\n                };\n                function isWebSQLValid() {\n                    return typeof openDatabase === \"function\";\n                }\n                // Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n                // it to Base64, so this is how we store it to prevent very strange errors with less\n                // verbose ways of binary <-> string data storage.\n                var BASE_CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n                var BLOB_TYPE_PREFIX = \"~~local_forage_type~\";\n                var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n                var SERIALIZED_MARKER = \"__lfsc__:\";\n                var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n                // OMG the serializations!\n                var TYPE_ARRAYBUFFER = \"arbf\";\n                var TYPE_BLOB = \"blob\";\n                var TYPE_INT8ARRAY = \"si08\";\n                var TYPE_UINT8ARRAY = \"ui08\";\n                var TYPE_UINT8CLAMPEDARRAY = \"uic8\";\n                var TYPE_INT16ARRAY = \"si16\";\n                var TYPE_INT32ARRAY = \"si32\";\n                var TYPE_UINT16ARRAY = \"ur16\";\n                var TYPE_UINT32ARRAY = \"ui32\";\n                var TYPE_FLOAT32ARRAY = \"fl32\";\n                var TYPE_FLOAT64ARRAY = \"fl64\";\n                var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n                var toString$1 = Object.prototype.toString;\n                function stringToBuffer(serializedString) {\n                    // Fill the string into a ArrayBuffer.\n                    var bufferLength = serializedString.length * 0.75;\n                    var len = serializedString.length;\n                    var i;\n                    var p = 0;\n                    var encoded1, encoded2, encoded3, encoded4;\n                    if (serializedString[serializedString.length - 1] === \"=\") {\n                        bufferLength--;\n                        if (serializedString[serializedString.length - 2] === \"=\") {\n                            bufferLength--;\n                        }\n                    }\n                    var buffer = new ArrayBuffer(bufferLength);\n                    var bytes = new Uint8Array(buffer);\n                    for(i = 0; i < len; i += 4){\n                        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n                        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n                        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n                        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n                        /*jslint bitwise: true */ bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n                        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n                        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n                    }\n                    return buffer;\n                }\n                // Converts a buffer to a string to store, serialized, in the backend\n                // storage library.\n                function bufferToString(buffer) {\n                    // base64-arraybuffer\n                    var bytes = new Uint8Array(buffer);\n                    var base64String = \"\";\n                    var i;\n                    for(i = 0; i < bytes.length; i += 3){\n                        /*jslint bitwise: true */ base64String += BASE_CHARS[bytes[i] >> 2];\n                        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n                        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n                        base64String += BASE_CHARS[bytes[i + 2] & 63];\n                    }\n                    if (bytes.length % 3 === 2) {\n                        base64String = base64String.substring(0, base64String.length - 1) + \"=\";\n                    } else if (bytes.length % 3 === 1) {\n                        base64String = base64String.substring(0, base64String.length - 2) + \"==\";\n                    }\n                    return base64String;\n                }\n                // Serialize a value, afterwards executing a callback (which usually\n                // instructs the `setItem()` callback/promise to be executed). This is how\n                // we store binary data with localStorage.\n                function serialize(value, callback) {\n                    var valueType = \"\";\n                    if (value) {\n                        valueType = toString$1.call(value);\n                    }\n                    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n                    // checks fail when running the tests using casper.js...\n                    //\n                    // TODO: See why those tests fail and use a better solution.\n                    if (value && (valueType === \"[object ArrayBuffer]\" || value.buffer && toString$1.call(value.buffer) === \"[object ArrayBuffer]\")) {\n                        // Convert binary arrays to a string and prefix the string with\n                        // a special marker.\n                        var buffer;\n                        var marker = SERIALIZED_MARKER;\n                        if (value instanceof ArrayBuffer) {\n                            buffer = value;\n                            marker += TYPE_ARRAYBUFFER;\n                        } else {\n                            buffer = value.buffer;\n                            if (valueType === \"[object Int8Array]\") {\n                                marker += TYPE_INT8ARRAY;\n                            } else if (valueType === \"[object Uint8Array]\") {\n                                marker += TYPE_UINT8ARRAY;\n                            } else if (valueType === \"[object Uint8ClampedArray]\") {\n                                marker += TYPE_UINT8CLAMPEDARRAY;\n                            } else if (valueType === \"[object Int16Array]\") {\n                                marker += TYPE_INT16ARRAY;\n                            } else if (valueType === \"[object Uint16Array]\") {\n                                marker += TYPE_UINT16ARRAY;\n                            } else if (valueType === \"[object Int32Array]\") {\n                                marker += TYPE_INT32ARRAY;\n                            } else if (valueType === \"[object Uint32Array]\") {\n                                marker += TYPE_UINT32ARRAY;\n                            } else if (valueType === \"[object Float32Array]\") {\n                                marker += TYPE_FLOAT32ARRAY;\n                            } else if (valueType === \"[object Float64Array]\") {\n                                marker += TYPE_FLOAT64ARRAY;\n                            } else {\n                                callback(new Error(\"Failed to get type for BinaryArray\"));\n                            }\n                        }\n                        callback(marker + bufferToString(buffer));\n                    } else if (valueType === \"[object Blob]\") {\n                        // Conver the blob to a binaryArray and then to a string.\n                        var fileReader = new FileReader();\n                        fileReader.onload = function() {\n                            // Backwards-compatible prefix for the blob type.\n                            var str = BLOB_TYPE_PREFIX + value.type + \"~\" + bufferToString(this.result);\n                            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n                        };\n                        fileReader.readAsArrayBuffer(value);\n                    } else {\n                        try {\n                            callback(JSON.stringify(value));\n                        } catch (e) {\n                            console.error(\"Couldn't convert value into a JSON string: \", value);\n                            callback(null, e);\n                        }\n                    }\n                }\n                // Deserialize data we've inserted into a value column/field. We place\n                // special markers into our strings to mark them as encoded; this isn't\n                // as nice as a meta field, but it's the only sane thing we can do whilst\n                // keeping localStorage support intact.\n                //\n                // Oftentimes this will just deserialize JSON content, but if we have a\n                // special marker (SERIALIZED_MARKER, defined above), we will extract\n                // some kind of arraybuffer/binary data/typed array out of the string.\n                function deserialize(value) {\n                    // If we haven't marked this string as being specially serialized (i.e.\n                    // something other than serialized JSON), we can just return it and be\n                    // done with it.\n                    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n                        return JSON.parse(value);\n                    }\n                    // The following code deals with deserializing some kind of Blob or\n                    // TypedArray. First we separate out the type of data we're dealing\n                    // with from the data itself.\n                    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n                    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n                    var blobType;\n                    // Backwards-compatible blob type serialization strategy.\n                    // DBs created with older versions of localForage will simply not have the blob type.\n                    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n                        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n                        blobType = matcher[1];\n                        serializedString = serializedString.substring(matcher[0].length);\n                    }\n                    var buffer = stringToBuffer(serializedString);\n                    // Return the right type based on the code/type set during\n                    // serialization.\n                    switch(type){\n                        case TYPE_ARRAYBUFFER:\n                            return buffer;\n                        case TYPE_BLOB:\n                            return createBlob([\n                                buffer\n                            ], {\n                                type: blobType\n                            });\n                        case TYPE_INT8ARRAY:\n                            return new Int8Array(buffer);\n                        case TYPE_UINT8ARRAY:\n                            return new Uint8Array(buffer);\n                        case TYPE_UINT8CLAMPEDARRAY:\n                            return new Uint8ClampedArray(buffer);\n                        case TYPE_INT16ARRAY:\n                            return new Int16Array(buffer);\n                        case TYPE_UINT16ARRAY:\n                            return new Uint16Array(buffer);\n                        case TYPE_INT32ARRAY:\n                            return new Int32Array(buffer);\n                        case TYPE_UINT32ARRAY:\n                            return new Uint32Array(buffer);\n                        case TYPE_FLOAT32ARRAY:\n                            return new Float32Array(buffer);\n                        case TYPE_FLOAT64ARRAY:\n                            return new Float64Array(buffer);\n                        default:\n                            throw new Error(\"Unkown type: \" + type);\n                    }\n                }\n                var localforageSerializer = {\n                    serialize: serialize,\n                    deserialize: deserialize,\n                    stringToBuffer: stringToBuffer,\n                    bufferToString: bufferToString\n                };\n                /*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */ function createDbTable(t, dbInfo, callback, errorCallback) {\n                    t.executeSql(\"CREATE TABLE IF NOT EXISTS \" + dbInfo.storeName + \" \" + \"(id INTEGER PRIMARY KEY, key unique, value)\", [], callback, errorCallback);\n                }\n                // Open the WebSQL database (automatically creates one if one didn't\n                // previously exist), using any options set in the config.\n                function _initStorage$1(options) {\n                    var self1 = this;\n                    var dbInfo = {\n                        db: null\n                    };\n                    if (options) {\n                        for(var i in options){\n                            dbInfo[i] = typeof options[i] !== \"string\" ? options[i].toString() : options[i];\n                        }\n                    }\n                    var dbInfoPromise = new Promise$1(function(resolve, reject) {\n                        // Open the database; the openDatabase API will automatically\n                        // create it for us if it doesn't exist.\n                        try {\n                            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n                        } catch (e) {\n                            return reject(e);\n                        }\n                        // Create our key/value table if it doesn't exist.\n                        dbInfo.db.transaction(function(t) {\n                            createDbTable(t, dbInfo, function() {\n                                self1._dbInfo = dbInfo;\n                                resolve();\n                            }, function(t, error) {\n                                reject(error);\n                            });\n                        }, reject);\n                    });\n                    dbInfo.serializer = localforageSerializer;\n                    return dbInfoPromise;\n                }\n                function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {\n                    t.executeSql(sqlStatement, args, callback, function(t, error) {\n                        if (error.code === error.SYNTAX_ERR) {\n                            t.executeSql(\"SELECT name FROM sqlite_master \" + \"WHERE type='table' AND name = ?\", [\n                                dbInfo.storeName\n                            ], function(t, results) {\n                                if (!results.rows.length) {\n                                    // if the table is missing (was deleted)\n                                    // re-create it table and retry\n                                    createDbTable(t, dbInfo, function() {\n                                        t.executeSql(sqlStatement, args, callback, errorCallback);\n                                    }, errorCallback);\n                                } else {\n                                    errorCallback(t, error);\n                                }\n                            }, errorCallback);\n                        } else {\n                            errorCallback(t, error);\n                        }\n                    }, errorCallback);\n                }\n                function getItem$1(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"SELECT * FROM \" + dbInfo.storeName + \" WHERE key = ? LIMIT 1\", [\n                                    key\n                                ], function(t, results) {\n                                    var result = results.rows.length ? results.rows.item(0).value : null;\n                                    // Check to see if this is serialized content we need to\n                                    // unpack.\n                                    if (result) {\n                                        result = dbInfo.serializer.deserialize(result);\n                                    }\n                                    resolve(result);\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function iterate$1(iterator, callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"SELECT * FROM \" + dbInfo.storeName, [], function(t, results) {\n                                    var rows = results.rows;\n                                    var length = rows.length;\n                                    for(var i = 0; i < length; i++){\n                                        var item = rows.item(i);\n                                        var result = item.value;\n                                        // Check to see if this is serialized content\n                                        // we need to unpack.\n                                        if (result) {\n                                            result = dbInfo.serializer.deserialize(result);\n                                        }\n                                        result = iterator(result, item.key, i + 1);\n                                        // void(0) prevents problems with redefinition\n                                        // of `undefined`.\n                                        if (result !== void 0) {\n                                            resolve(result);\n                                            return;\n                                        }\n                                    }\n                                    resolve();\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function _setItem(key, value, callback, retriesLeft) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            // The localStorage API doesn't return undefined values in an\n                            // \"expected\" way, so undefined is always cast to null in all\n                            // drivers. See: https://github.com/mozilla/localForage/pull/42\n                            if (value === undefined) {\n                                value = null;\n                            }\n                            // Save the original value to pass to the callback.\n                            var originalValue = value;\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.serializer.serialize(value, function(value, error) {\n                                if (error) {\n                                    reject(error);\n                                } else {\n                                    dbInfo.db.transaction(function(t) {\n                                        tryExecuteSql(t, dbInfo, \"INSERT OR REPLACE INTO \" + dbInfo.storeName + \" \" + \"(key, value) VALUES (?, ?)\", [\n                                            key,\n                                            value\n                                        ], function() {\n                                            resolve(originalValue);\n                                        }, function(t, error) {\n                                            reject(error);\n                                        });\n                                    }, function(sqlError) {\n                                        // The transaction failed; check\n                                        // to see if it's a quota error.\n                                        if (sqlError.code === sqlError.QUOTA_ERR) {\n                                            // We reject the callback outright for now, but\n                                            // it's worth trying to re-run the transaction.\n                                            // Even if the user accepts the prompt to use\n                                            // more storage on Safari, this error will\n                                            // be called.\n                                            //\n                                            // Try to re-run the transaction.\n                                            if (retriesLeft > 0) {\n                                                resolve(_setItem.apply(self1, [\n                                                    key,\n                                                    originalValue,\n                                                    callback,\n                                                    retriesLeft - 1\n                                                ]));\n                                                return;\n                                            }\n                                            reject(sqlError);\n                                        }\n                                    });\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function setItem$1(key, value, callback) {\n                    return _setItem.apply(this, [\n                        key,\n                        value,\n                        callback,\n                        1\n                    ]);\n                }\n                function removeItem$1(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"DELETE FROM \" + dbInfo.storeName + \" WHERE key = ?\", [\n                                    key\n                                ], function() {\n                                    resolve();\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Deletes every item in the table.\n                // TODO: Find out if this resets the AUTO_INCREMENT number.\n                function clear$1(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"DELETE FROM \" + dbInfo.storeName, [], function() {\n                                    resolve();\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Does a simple `COUNT(key)` to get the number of items stored in\n                // localForage.\n                function length$1(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                // Ahhh, SQL makes this one soooooo easy.\n                                tryExecuteSql(t, dbInfo, \"SELECT COUNT(key) as c FROM \" + dbInfo.storeName, [], function(t, results) {\n                                    var result = results.rows.item(0).c;\n                                    resolve(result);\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Return the key located at key index X; essentially gets the key from a\n                // `WHERE id = ?`. This is the most efficient way I can think to implement\n                // this rarely-used (in my experience) part of the API, but it can seem\n                // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n                // the ID of each key will change every time it's updated. Perhaps a stored\n                // procedure for the `setItem()` SQL would solve this problem?\n                // TODO: Don't change ID on `setItem()`.\n                function key$1(n, callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"SELECT key FROM \" + dbInfo.storeName + \" WHERE id = ? LIMIT 1\", [\n                                    n + 1\n                                ], function(t, results) {\n                                    var result = results.rows.length ? results.rows.item(0).key : null;\n                                    resolve(result);\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function keys$1(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"SELECT key FROM \" + dbInfo.storeName, [], function(t, results) {\n                                    var keys = [];\n                                    for(var i = 0; i < results.rows.length; i++){\n                                        keys.push(results.rows.item(i).key);\n                                    }\n                                    resolve(keys);\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // https://www.w3.org/TR/webdatabase/#databases\n                // > There is no way to enumerate or delete the databases available for an origin from this API.\n                function getAllStoreNames(db) {\n                    return new Promise$1(function(resolve, reject) {\n                        db.transaction(function(t) {\n                            t.executeSql(\"SELECT name FROM sqlite_master \" + \"WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'\", [], function(t, results) {\n                                var storeNames = [];\n                                for(var i = 0; i < results.rows.length; i++){\n                                    storeNames.push(results.rows.item(i).name);\n                                }\n                                resolve({\n                                    db: db,\n                                    storeNames: storeNames\n                                });\n                            }, function(t, error) {\n                                reject(error);\n                            });\n                        }, function(sqlError) {\n                            reject(sqlError);\n                        });\n                    });\n                }\n                function dropInstance$1(options, callback) {\n                    callback = getCallback.apply(this, arguments);\n                    var currentConfig = this.config();\n                    options = typeof options !== \"function\" && options || {};\n                    if (!options.name) {\n                        options.name = options.name || currentConfig.name;\n                        options.storeName = options.storeName || currentConfig.storeName;\n                    }\n                    var self1 = this;\n                    var promise;\n                    if (!options.name) {\n                        promise = Promise$1.reject(\"Invalid arguments\");\n                    } else {\n                        promise = new Promise$1(function(resolve) {\n                            var db;\n                            if (options.name === currentConfig.name) {\n                                // use the db reference of the current instance\n                                db = self1._dbInfo.db;\n                            } else {\n                                db = openDatabase(options.name, \"\", \"\", 0);\n                            }\n                            if (!options.storeName) {\n                                // drop all database tables\n                                resolve(getAllStoreNames(db));\n                            } else {\n                                resolve({\n                                    db: db,\n                                    storeNames: [\n                                        options.storeName\n                                    ]\n                                });\n                            }\n                        }).then(function(operationInfo) {\n                            return new Promise$1(function(resolve, reject) {\n                                operationInfo.db.transaction(function(t) {\n                                    function dropTable(storeName) {\n                                        return new Promise$1(function(resolve, reject) {\n                                            t.executeSql(\"DROP TABLE IF EXISTS \" + storeName, [], function() {\n                                                resolve();\n                                            }, function(t, error) {\n                                                reject(error);\n                                            });\n                                        });\n                                    }\n                                    var operations = [];\n                                    for(var i = 0, len = operationInfo.storeNames.length; i < len; i++){\n                                        operations.push(dropTable(operationInfo.storeNames[i]));\n                                    }\n                                    Promise$1.all(operations).then(function() {\n                                        resolve();\n                                    })[\"catch\"](function(e) {\n                                        reject(e);\n                                    });\n                                }, function(sqlError) {\n                                    reject(sqlError);\n                                });\n                            });\n                        });\n                    }\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                var webSQLStorage = {\n                    _driver: \"webSQLStorage\",\n                    _initStorage: _initStorage$1,\n                    _support: isWebSQLValid(),\n                    iterate: iterate$1,\n                    getItem: getItem$1,\n                    setItem: setItem$1,\n                    removeItem: removeItem$1,\n                    clear: clear$1,\n                    length: length$1,\n                    key: key$1,\n                    keys: keys$1,\n                    dropInstance: dropInstance$1\n                };\n                function isLocalStorageValid() {\n                    try {\n                        return typeof localStorage !== \"undefined\" && \"setItem\" in localStorage && // in IE8 typeof localStorage.setItem === 'object'\n                        !!localStorage.setItem;\n                    } catch (e) {\n                        return false;\n                    }\n                }\n                function _getKeyPrefix(options, defaultConfig) {\n                    var keyPrefix = options.name + \"/\";\n                    if (options.storeName !== defaultConfig.storeName) {\n                        keyPrefix += options.storeName + \"/\";\n                    }\n                    return keyPrefix;\n                }\n                // Check if localStorage throws when saving an item\n                function checkIfLocalStorageThrows() {\n                    var localStorageTestKey = \"_localforage_support_test\";\n                    try {\n                        localStorage.setItem(localStorageTestKey, true);\n                        localStorage.removeItem(localStorageTestKey);\n                        return false;\n                    } catch (e) {\n                        return true;\n                    }\n                }\n                // Check if localStorage is usable and allows to save an item\n                // This method checks if localStorage is usable in Safari Private Browsing\n                // mode, or in any other case where the available quota for localStorage\n                // is 0 and there wasn't any saved items yet.\n                function _isLocalStorageUsable() {\n                    return !checkIfLocalStorageThrows() || localStorage.length > 0;\n                }\n                // Config the localStorage backend, using options set in the config.\n                function _initStorage$2(options) {\n                    var self1 = this;\n                    var dbInfo = {};\n                    if (options) {\n                        for(var i in options){\n                            dbInfo[i] = options[i];\n                        }\n                    }\n                    dbInfo.keyPrefix = _getKeyPrefix(options, self1._defaultConfig);\n                    if (!_isLocalStorageUsable()) {\n                        return Promise$1.reject();\n                    }\n                    self1._dbInfo = dbInfo;\n                    dbInfo.serializer = localforageSerializer;\n                    return Promise$1.resolve();\n                }\n                // Remove all keys from the datastore, effectively destroying all data in\n                // the app's key/value store!\n                function clear$2(callback) {\n                    var self1 = this;\n                    var promise = self1.ready().then(function() {\n                        var keyPrefix = self1._dbInfo.keyPrefix;\n                        for(var i = localStorage.length - 1; i >= 0; i--){\n                            var key = localStorage.key(i);\n                            if (key.indexOf(keyPrefix) === 0) {\n                                localStorage.removeItem(key);\n                            }\n                        }\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Retrieve an item from the store. Unlike the original async_storage\n                // library in Gaia, we don't modify return values at all. If a key's value\n                // is `undefined`, we pass that value to the callback function.\n                function getItem$2(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n                        // If a result was found, parse it from the serialized\n                        // string into a JS object. If result isn't truthy, the key\n                        // is likely undefined and we'll pass it straight to the\n                        // callback.\n                        if (result) {\n                            result = dbInfo.serializer.deserialize(result);\n                        }\n                        return result;\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Iterate over all items in the store.\n                function iterate$2(iterator, callback) {\n                    var self1 = this;\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        var keyPrefix = dbInfo.keyPrefix;\n                        var keyPrefixLength = keyPrefix.length;\n                        var length = localStorage.length;\n                        // We use a dedicated iterator instead of the `i` variable below\n                        // so other keys we fetch in localStorage aren't counted in\n                        // the `iterationNumber` argument passed to the `iterate()`\n                        // callback.\n                        //\n                        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n                        var iterationNumber = 1;\n                        for(var i = 0; i < length; i++){\n                            var key = localStorage.key(i);\n                            if (key.indexOf(keyPrefix) !== 0) {\n                                continue;\n                            }\n                            var value = localStorage.getItem(key);\n                            // If a result was found, parse it from the serialized\n                            // string into a JS object. If result isn't truthy, the\n                            // key is likely undefined and we'll pass it straight\n                            // to the iterator.\n                            if (value) {\n                                value = dbInfo.serializer.deserialize(value);\n                            }\n                            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n                            if (value !== void 0) {\n                                return value;\n                            }\n                        }\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Same as localStorage's key() method, except takes a callback.\n                function key$2(n, callback) {\n                    var self1 = this;\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        var result;\n                        try {\n                            result = localStorage.key(n);\n                        } catch (error) {\n                            result = null;\n                        }\n                        // Remove the prefix from the key, if a key is found.\n                        if (result) {\n                            result = result.substring(dbInfo.keyPrefix.length);\n                        }\n                        return result;\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function keys$2(callback) {\n                    var self1 = this;\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        var length = localStorage.length;\n                        var keys = [];\n                        for(var i = 0; i < length; i++){\n                            var itemKey = localStorage.key(i);\n                            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {\n                                keys.push(itemKey.substring(dbInfo.keyPrefix.length));\n                            }\n                        }\n                        return keys;\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Supply the number of keys in the datastore to the callback function.\n                function length$2(callback) {\n                    var self1 = this;\n                    var promise = self1.keys().then(function(keys) {\n                        return keys.length;\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Remove an item from the store, nice and simple.\n                function removeItem$2(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        localStorage.removeItem(dbInfo.keyPrefix + key);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Set a key's value and run an optional callback once the value is set.\n                // Unlike Gaia's implementation, the callback function is passed the value,\n                // in case you want to operate on that value only after you're sure it\n                // saved, or something like that.\n                function setItem$2(key, value, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = self1.ready().then(function() {\n                        // Convert undefined values to null.\n                        // https://github.com/mozilla/localForage/pull/42\n                        if (value === undefined) {\n                            value = null;\n                        }\n                        // Save the original value to pass to the callback.\n                        var originalValue = value;\n                        return new Promise$1(function(resolve, reject) {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.serializer.serialize(value, function(value, error) {\n                                if (error) {\n                                    reject(error);\n                                } else {\n                                    try {\n                                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n                                        resolve(originalValue);\n                                    } catch (e) {\n                                        // localStorage capacity exceeded.\n                                        // TODO: Make this a specific error/event.\n                                        if (e.name === \"QuotaExceededError\" || e.name === \"NS_ERROR_DOM_QUOTA_REACHED\") {\n                                            reject(e);\n                                        }\n                                        reject(e);\n                                    }\n                                }\n                            });\n                        });\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function dropInstance$2(options, callback) {\n                    callback = getCallback.apply(this, arguments);\n                    options = typeof options !== \"function\" && options || {};\n                    if (!options.name) {\n                        var currentConfig = this.config();\n                        options.name = options.name || currentConfig.name;\n                        options.storeName = options.storeName || currentConfig.storeName;\n                    }\n                    var self1 = this;\n                    var promise;\n                    if (!options.name) {\n                        promise = Promise$1.reject(\"Invalid arguments\");\n                    } else {\n                        promise = new Promise$1(function(resolve) {\n                            if (!options.storeName) {\n                                resolve(options.name + \"/\");\n                            } else {\n                                resolve(_getKeyPrefix(options, self1._defaultConfig));\n                            }\n                        }).then(function(keyPrefix) {\n                            for(var i = localStorage.length - 1; i >= 0; i--){\n                                var key = localStorage.key(i);\n                                if (key.indexOf(keyPrefix) === 0) {\n                                    localStorage.removeItem(key);\n                                }\n                            }\n                        });\n                    }\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                var localStorageWrapper = {\n                    _driver: \"localStorageWrapper\",\n                    _initStorage: _initStorage$2,\n                    _support: isLocalStorageValid(),\n                    iterate: iterate$2,\n                    getItem: getItem$2,\n                    setItem: setItem$2,\n                    removeItem: removeItem$2,\n                    clear: clear$2,\n                    length: length$2,\n                    key: key$2,\n                    keys: keys$2,\n                    dropInstance: dropInstance$2\n                };\n                var sameValue = function sameValue(x, y) {\n                    return x === y || typeof x === \"number\" && typeof y === \"number\" && isNaN(x) && isNaN(y);\n                };\n                var includes = function includes(array, searchElement) {\n                    var len = array.length;\n                    var i = 0;\n                    while(i < len){\n                        if (sameValue(array[i], searchElement)) {\n                            return true;\n                        }\n                        i++;\n                    }\n                    return false;\n                };\n                var isArray = Array.isArray || function(arg) {\n                    return Object.prototype.toString.call(arg) === \"[object Array]\";\n                };\n                // Drivers are stored here when `defineDriver()` is called.\n                // They are shared across all instances of localForage.\n                var DefinedDrivers = {};\n                var DriverSupport = {};\n                var DefaultDrivers = {\n                    INDEXEDDB: asyncStorage,\n                    WEBSQL: webSQLStorage,\n                    LOCALSTORAGE: localStorageWrapper\n                };\n                var DefaultDriverOrder = [\n                    DefaultDrivers.INDEXEDDB._driver,\n                    DefaultDrivers.WEBSQL._driver,\n                    DefaultDrivers.LOCALSTORAGE._driver\n                ];\n                var OptionalDriverMethods = [\n                    \"dropInstance\"\n                ];\n                var LibraryMethods = [\n                    \"clear\",\n                    \"getItem\",\n                    \"iterate\",\n                    \"key\",\n                    \"keys\",\n                    \"length\",\n                    \"removeItem\",\n                    \"setItem\"\n                ].concat(OptionalDriverMethods);\n                var DefaultConfig = {\n                    description: \"\",\n                    driver: DefaultDriverOrder.slice(),\n                    name: \"localforage\",\n                    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n                    // we can use without a prompt.\n                    size: 4980736,\n                    storeName: \"keyvaluepairs\",\n                    version: 1.0\n                };\n                function callWhenReady(localForageInstance, libraryMethod) {\n                    localForageInstance[libraryMethod] = function() {\n                        var _args = arguments;\n                        return localForageInstance.ready().then(function() {\n                            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n                        });\n                    };\n                }\n                function extend() {\n                    for(var i = 1; i < arguments.length; i++){\n                        var arg = arguments[i];\n                        if (arg) {\n                            for(var _key in arg){\n                                if (arg.hasOwnProperty(_key)) {\n                                    if (isArray(arg[_key])) {\n                                        arguments[0][_key] = arg[_key].slice();\n                                    } else {\n                                        arguments[0][_key] = arg[_key];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return arguments[0];\n                }\n                var LocalForage = function() {\n                    function LocalForage(options) {\n                        _classCallCheck(this, LocalForage);\n                        for(var driverTypeKey in DefaultDrivers){\n                            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\n                                var driver = DefaultDrivers[driverTypeKey];\n                                var driverName = driver._driver;\n                                this[driverTypeKey] = driverName;\n                                if (!DefinedDrivers[driverName]) {\n                                    // we don't need to wait for the promise,\n                                    // since the default drivers can be defined\n                                    // in a blocking manner\n                                    this.defineDriver(driver);\n                                }\n                            }\n                        }\n                        this._defaultConfig = extend({}, DefaultConfig);\n                        this._config = extend({}, this._defaultConfig, options);\n                        this._driverSet = null;\n                        this._initDriver = null;\n                        this._ready = false;\n                        this._dbInfo = null;\n                        this._wrapLibraryMethodsWithReady();\n                        this.setDriver(this._config.driver)[\"catch\"](function() {});\n                    }\n                    // Set any config values for localForage; can be called anytime before\n                    // the first API call (e.g. `getItem`, `setItem`).\n                    // We loop through options so we don't overwrite existing config\n                    // values.\n                    LocalForage.prototype.config = function config(options) {\n                        // If the options argument is an object, we use it to set values.\n                        // Otherwise, we return either a specified config value or all\n                        // config values.\n                        if ((typeof options === \"undefined\" ? \"undefined\" : _typeof(options)) === \"object\") {\n                            // If localforage is ready and fully initialized, we can't set\n                            // any new configuration values. Instead, we return an error.\n                            if (this._ready) {\n                                return new Error(\"Can't call config() after localforage \" + \"has been used.\");\n                            }\n                            for(var i in options){\n                                if (i === \"storeName\") {\n                                    options[i] = options[i].replace(/\\W/g, \"_\");\n                                }\n                                if (i === \"version\" && typeof options[i] !== \"number\") {\n                                    return new Error(\"Database version must be a number.\");\n                                }\n                                this._config[i] = options[i];\n                            }\n                            // after all config options are set and\n                            // the driver option is used, try setting it\n                            if (\"driver\" in options && options.driver) {\n                                return this.setDriver(this._config.driver);\n                            }\n                            return true;\n                        } else if (typeof options === \"string\") {\n                            return this._config[options];\n                        } else {\n                            return this._config;\n                        }\n                    };\n                    // Used to define a custom driver, shared across all instances of\n                    // localForage.\n                    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n                        var promise = new Promise$1(function(resolve, reject) {\n                            try {\n                                var driverName = driverObject._driver;\n                                var complianceError = new Error(\"Custom driver not compliant; see \" + \"https://mozilla.github.io/localForage/#definedriver\");\n                                // A driver name should be defined and not overlap with the\n                                // library-defined, default drivers.\n                                if (!driverObject._driver) {\n                                    reject(complianceError);\n                                    return;\n                                }\n                                var driverMethods = LibraryMethods.concat(\"_initStorage\");\n                                for(var i = 0, len = driverMethods.length; i < len; i++){\n                                    var driverMethodName = driverMethods[i];\n                                    // when the property is there,\n                                    // it should be a method even when optional\n                                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);\n                                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== \"function\") {\n                                        reject(complianceError);\n                                        return;\n                                    }\n                                }\n                                var configureMissingMethods = function configureMissingMethods() {\n                                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {\n                                        return function() {\n                                            var error = new Error(\"Method \" + methodName + \" is not implemented by the current driver\");\n                                            var promise = Promise$1.reject(error);\n                                            executeCallback(promise, arguments[arguments.length - 1]);\n                                            return promise;\n                                        };\n                                    };\n                                    for(var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++){\n                                        var optionalDriverMethod = OptionalDriverMethods[_i];\n                                        if (!driverObject[optionalDriverMethod]) {\n                                            driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);\n                                        }\n                                    }\n                                };\n                                configureMissingMethods();\n                                var setDriverSupport = function setDriverSupport(support) {\n                                    if (DefinedDrivers[driverName]) {\n                                        console.info(\"Redefining LocalForage driver: \" + driverName);\n                                    }\n                                    DefinedDrivers[driverName] = driverObject;\n                                    DriverSupport[driverName] = support;\n                                    // don't use a then, so that we can define\n                                    // drivers that have simple _support methods\n                                    // in a blocking manner\n                                    resolve();\n                                };\n                                if (\"_support\" in driverObject) {\n                                    if (driverObject._support && typeof driverObject._support === \"function\") {\n                                        driverObject._support().then(setDriverSupport, reject);\n                                    } else {\n                                        setDriverSupport(!!driverObject._support);\n                                    }\n                                } else {\n                                    setDriverSupport(true);\n                                }\n                            } catch (e) {\n                                reject(e);\n                            }\n                        });\n                        executeTwoCallbacks(promise, callback, errorCallback);\n                        return promise;\n                    };\n                    LocalForage.prototype.driver = function driver() {\n                        return this._driver || null;\n                    };\n                    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n                        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error(\"Driver not found.\"));\n                        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n                        return getDriverPromise;\n                    };\n                    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n                        var serializerPromise = Promise$1.resolve(localforageSerializer);\n                        executeTwoCallbacks(serializerPromise, callback);\n                        return serializerPromise;\n                    };\n                    LocalForage.prototype.ready = function ready(callback) {\n                        var self1 = this;\n                        var promise = self1._driverSet.then(function() {\n                            if (self1._ready === null) {\n                                self1._ready = self1._initDriver();\n                            }\n                            return self1._ready;\n                        });\n                        executeTwoCallbacks(promise, callback, callback);\n                        return promise;\n                    };\n                    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n                        var self1 = this;\n                        if (!isArray(drivers)) {\n                            drivers = [\n                                drivers\n                            ];\n                        }\n                        var supportedDrivers = this._getSupportedDrivers(drivers);\n                        function setDriverToConfig() {\n                            self1._config.driver = self1.driver();\n                        }\n                        function extendSelfWithDriver(driver) {\n                            self1._extend(driver);\n                            setDriverToConfig();\n                            self1._ready = self1._initStorage(self1._config);\n                            return self1._ready;\n                        }\n                        function initDriver(supportedDrivers) {\n                            return function() {\n                                var currentDriverIndex = 0;\n                                function driverPromiseLoop() {\n                                    while(currentDriverIndex < supportedDrivers.length){\n                                        var driverName = supportedDrivers[currentDriverIndex];\n                                        currentDriverIndex++;\n                                        self1._dbInfo = null;\n                                        self1._ready = null;\n                                        return self1.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                                    }\n                                    setDriverToConfig();\n                                    var error = new Error(\"No available storage method found.\");\n                                    self1._driverSet = Promise$1.reject(error);\n                                    return self1._driverSet;\n                                }\n                                return driverPromiseLoop();\n                            };\n                        }\n                        // There might be a driver initialization in progress\n                        // so wait for it to finish in order to avoid a possible\n                        // race condition to set _dbInfo\n                        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function() {\n                            return Promise$1.resolve();\n                        }) : Promise$1.resolve();\n                        this._driverSet = oldDriverSetDone.then(function() {\n                            var driverName = supportedDrivers[0];\n                            self1._dbInfo = null;\n                            self1._ready = null;\n                            return self1.getDriver(driverName).then(function(driver) {\n                                self1._driver = driver._driver;\n                                setDriverToConfig();\n                                self1._wrapLibraryMethodsWithReady();\n                                self1._initDriver = initDriver(supportedDrivers);\n                            });\n                        })[\"catch\"](function() {\n                            setDriverToConfig();\n                            var error = new Error(\"No available storage method found.\");\n                            self1._driverSet = Promise$1.reject(error);\n                            return self1._driverSet;\n                        });\n                        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n                        return this._driverSet;\n                    };\n                    LocalForage.prototype.supports = function supports(driverName) {\n                        return !!DriverSupport[driverName];\n                    };\n                    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n                        extend(this, libraryMethodsAndProperties);\n                    };\n                    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n                        var supportedDrivers = [];\n                        for(var i = 0, len = drivers.length; i < len; i++){\n                            var driverName = drivers[i];\n                            if (this.supports(driverName)) {\n                                supportedDrivers.push(driverName);\n                            }\n                        }\n                        return supportedDrivers;\n                    };\n                    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n                        // Add a stub for each driver API method that delays the call to the\n                        // corresponding driver method until localForage is ready. These stubs\n                        // will be replaced by the driver methods as soon as the driver is\n                        // loaded, so there is no performance impact.\n                        for(var i = 0, len = LibraryMethods.length; i < len; i++){\n                            callWhenReady(this, LibraryMethods[i]);\n                        }\n                    };\n                    LocalForage.prototype.createInstance = function createInstance(options) {\n                        return new LocalForage(options);\n                    };\n                    return LocalForage;\n                }();\n                // The actual localForage object that we expose as a module or via a\n                // global. It's extended by pulling in one of our other libraries.\n                var localforage_js = new LocalForage();\n                module1.exports = localforage_js;\n            },\n            {\n                \"3\": 3\n            }\n        ]\n    }, {}, [\n        4\n    ])(4);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbG9jYWxmb3JhZ2UvZGlzdC9sb2NhbGZvcmFnZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7QUFLQSxHQUNDLFVBQVNBLENBQUM7SUFBRSxJQUFHLElBQXNELEVBQUM7UUFBQ0UsT0FBT0QsT0FBTyxHQUFDRDtJQUFHLE9BQU0sVUFBb087QUFBQSxHQUFHO0lBQVcsSUFBSUcsU0FBT0QsU0FBT0Q7SUFBUSxPQUFPLENBQUMsU0FBU1MsRUFBRUMsQ0FBQyxFQUFDQyxDQUFDLEVBQUNDLENBQUM7UUFBRSxTQUFTQyxFQUFFQyxDQUFDLEVBQUNDLENBQUM7WUFBRSxJQUFHLENBQUNKLENBQUMsQ0FBQ0csRUFBRSxFQUFDO2dCQUFDLElBQUcsQ0FBQ0osQ0FBQyxDQUFDSSxFQUFFLEVBQUM7b0JBQUMsSUFBSUUsSUFBRSxTQUFtQ0M7b0JBQUMsSUFBRyxDQUFDRixLQUFHQyxHQUFFLE9BQU9BLE9BQUNBLENBQUNGLEdBQUUsQ0FBQztvQkFBRyxJQUFHSSxHQUFFLE9BQU9BLEVBQUVKLEdBQUUsQ0FBQztvQkFBRyxJQUFJZixJQUFFLElBQUlvQixNQUFNLHlCQUF1QkwsSUFBRTtvQkFBSyxNQUFPZixFQUFFcUIsSUFBSSxHQUFDLG9CQUFvQnJCO2dCQUFFO2dCQUFDLElBQUlzQixJQUFFVixDQUFDLENBQUNHLEVBQUUsR0FBQztvQkFBQ2QsU0FBUSxDQUFDO2dCQUFDO2dCQUFFVSxDQUFDLENBQUNJLEVBQUUsQ0FBQyxFQUFFLENBQUNRLElBQUksQ0FBQ0QsRUFBRXJCLE9BQU8sRUFBQyxTQUFTUyxDQUFDO29CQUFFLElBQUlFLElBQUVELENBQUMsQ0FBQ0ksRUFBRSxDQUFDLEVBQUUsQ0FBQ0wsRUFBRTtvQkFBQyxPQUFPSSxFQUFFRixJQUFFQSxJQUFFRjtnQkFBRSxHQUFFWSxHQUFFQSxFQUFFckIsT0FBTyxFQUFDUyxHQUFFQyxHQUFFQyxHQUFFQztZQUFFO1lBQUMsT0FBT0QsQ0FBQyxDQUFDRyxFQUFFLENBQUNkLE9BQU87UUFBQTtRQUFDLElBQUlrQixJQUFFLFNBQW1DRDtRQUFDLElBQUksSUFBSUgsSUFBRSxHQUFFQSxJQUFFRixFQUFFVyxNQUFNLEVBQUNULElBQUlELEVBQUVELENBQUMsQ0FBQ0UsRUFBRTtRQUFFLE9BQU9EO0lBQUMsR0FBRztRQUFDLEdBQUU7WUFBQyxTQUFTVyxPQUFPLEVBQUN2QixPQUFNLEVBQUNELFFBQU87Z0JBQ24xQixVQUFVTSxPQUFNO29CQUNqQjtvQkFDQSxJQUFJbUIsV0FBV25CLFFBQU9vQixnQkFBZ0IsSUFBSXBCLFFBQU9xQixzQkFBc0I7b0JBRXZFLElBQUlDO29CQUVKO3dCQUNFLElBQUlILFVBQVU7NEJBQ1osSUFBSUksU0FBUzs0QkFDYixJQUFJQyxXQUFXLElBQUlMLFNBQVNNOzRCQUM1QixJQUFJQyxVQUFVMUIsUUFBTzJCLFFBQVEsQ0FBQ0MsY0FBYyxDQUFDOzRCQUM3Q0osU0FBU0ssT0FBTyxDQUFDSCxTQUFTO2dDQUN4QkksZUFBZTs0QkFDakI7NEJBQ0FSLGdCQUFnQjtnQ0FDZEksUUFBUUssSUFBSSxHQUFJUixTQUFTLEVBQUVBLFNBQVM7NEJBQ3RDO3dCQUNGLE9BQU8sSUFBSSxDQUFDdkIsUUFBT2dDLFlBQVksSUFBSSxPQUFPaEMsUUFBT2lDLGNBQWMsS0FBSyxhQUFhOzRCQUMvRSxJQUFJQyxVQUFVLElBQUlsQyxRQUFPaUMsY0FBYzs0QkFDdkNDLFFBQVFDLEtBQUssQ0FBQ0MsU0FBUyxHQUFHWDs0QkFDMUJILGdCQUFnQjtnQ0FDZFksUUFBUUcsS0FBSyxDQUFDQyxXQUFXLENBQUM7NEJBQzVCO3dCQUNGLE9BQU8sSUFBSSxjQUFjdEMsV0FBVSx3QkFBd0JBLFFBQU8yQixRQUFRLENBQUNZLGFBQWEsQ0FBQyxXQUFXOzRCQUNsR2pCLGdCQUFnQjtnQ0FFZCx5R0FBeUc7Z0NBQ3pHLGtHQUFrRztnQ0FDbEcsSUFBSWtCLFdBQVd4QyxRQUFPMkIsUUFBUSxDQUFDWSxhQUFhLENBQUM7Z0NBQzdDQyxTQUFTQyxrQkFBa0IsR0FBRztvQ0FDNUJoQjtvQ0FFQWUsU0FBU0Msa0JBQWtCLEdBQUc7b0NBQzlCRCxTQUFTRSxVQUFVLENBQUNDLFdBQVcsQ0FBQ0g7b0NBQ2hDQSxXQUFXO2dDQUNiO2dDQUNBeEMsUUFBTzJCLFFBQVEsQ0FBQ2lCLGVBQWUsQ0FBQ0MsV0FBVyxDQUFDTDs0QkFDOUM7d0JBQ0YsT0FBTzs0QkFDTGxCLGdCQUFnQjtnQ0FDZHdCLFdBQVdyQixVQUFVOzRCQUN2Qjt3QkFDRjtvQkFDRjtvQkFFQSxJQUFJc0I7b0JBQ0osSUFBSUMsUUFBUSxFQUFFO29CQUNkLGdEQUFnRDtvQkFDaEQsU0FBU3ZCO3dCQUNQc0IsV0FBVzt3QkFDWCxJQUFJbkMsR0FBR3FDO3dCQUNQLElBQUlDLE1BQU1GLE1BQU0vQixNQUFNO3dCQUN0QixNQUFPaUMsSUFBSzs0QkFDVkQsV0FBV0Q7NEJBQ1hBLFFBQVEsRUFBRTs0QkFDVnBDLElBQUksQ0FBQzs0QkFDTCxNQUFPLEVBQUVBLElBQUlzQyxJQUFLO2dDQUNoQkQsUUFBUSxDQUFDckMsRUFBRTs0QkFDYjs0QkFDQXNDLE1BQU1GLE1BQU0vQixNQUFNO3dCQUNwQjt3QkFDQThCLFdBQVc7b0JBQ2I7b0JBRUFwRCxRQUFPRCxPQUFPLEdBQUd5RDtvQkFDakIsU0FBU0EsVUFBVUMsSUFBSTt3QkFDckIsSUFBSUosTUFBTUssSUFBSSxDQUFDRCxVQUFVLEtBQUssQ0FBQ0wsVUFBVTs0QkFDdkN6Qjt3QkFDRjtvQkFDRjtnQkFFQSxHQUFHTixJQUFJLENBQUMsSUFBSSxFQUFDLE9BQU9oQixXQUFXLGNBQWNBLFNBQVMsT0FBT0MsU0FBUyxjQUFjQSxPQUFPLE1BQTZCLEdBQUdGLENBQU1BLEdBQUcsQ0FBQztZQUNySTtZQUFFLENBQUM7U0FBRTtRQUFDLEdBQUU7WUFBQyxTQUFTbUIsT0FBTyxFQUFDdkIsT0FBTSxFQUFDRCxRQUFPO2dCQUN4QztnQkFDQSxJQUFJeUQsWUFBWWpDLFFBQVE7Z0JBRXhCLHdCQUF3QixHQUN4QixTQUFTb0MsWUFBWTtnQkFFckIsSUFBSUMsV0FBVyxDQUFDO2dCQUVoQixJQUFJQyxXQUFXO29CQUFDO2lCQUFXO2dCQUMzQixJQUFJQyxZQUFZO29CQUFDO2lCQUFZO2dCQUM3QixJQUFJQyxVQUFVO29CQUFDO2lCQUFVO2dCQUV6Qi9ELFFBQU9ELE9BQU8sR0FBR2lFO2dCQUVqQixTQUFTQSxTQUFRQyxRQUFRO29CQUN2QixJQUFJLE9BQU9BLGFBQWEsWUFBWTt3QkFDbEMsTUFBTSxJQUFJQyxVQUFVO29CQUN0QjtvQkFDQSxJQUFJLENBQUNDLEtBQUssR0FBR0o7b0JBQ2IsSUFBSSxDQUFDVixLQUFLLEdBQUcsRUFBRTtvQkFDZixJQUFJLENBQUNlLE9BQU8sR0FBRyxLQUFLO29CQUNwQixJQUFJSCxhQUFhTixVQUFVO3dCQUN6QlUsc0JBQXNCLElBQUksRUFBRUo7b0JBQzlCO2dCQUNGO2dCQUVBRCxTQUFRTSxTQUFTLENBQUMsUUFBUSxHQUFHLFNBQVVDLFVBQVU7b0JBQy9DLE9BQU8sSUFBSSxDQUFDQyxJQUFJLENBQUMsTUFBTUQ7Z0JBQ3pCO2dCQUNBUCxTQUFRTSxTQUFTLENBQUNFLElBQUksR0FBRyxTQUFVQyxXQUFXLEVBQUVGLFVBQVU7b0JBQ3hELElBQUksT0FBT0UsZ0JBQWdCLGNBQWMsSUFBSSxDQUFDTixLQUFLLEtBQUtMLGFBQ3RELE9BQU9TLGVBQWUsY0FBYyxJQUFJLENBQUNKLEtBQUssS0FBS04sVUFBVTt3QkFDN0QsT0FBTyxJQUFJO29CQUNiO29CQUNBLElBQUlhLFVBQVUsSUFBSSxJQUFJLENBQUNDLFdBQVcsQ0FBQ2hCO29CQUNuQyxJQUFJLElBQUksQ0FBQ1EsS0FBSyxLQUFLSixTQUFTO3dCQUMxQixJQUFJRSxXQUFXLElBQUksQ0FBQ0UsS0FBSyxLQUFLTCxZQUFZVyxjQUFjRjt3QkFDeERLLE9BQU9GLFNBQVNULFVBQVUsSUFBSSxDQUFDRyxPQUFPO29CQUN4QyxPQUFPO3dCQUNMLElBQUksQ0FBQ2YsS0FBSyxDQUFDSyxJQUFJLENBQUMsSUFBSW1CLFVBQVVILFNBQVNELGFBQWFGO29CQUN0RDtvQkFFQSxPQUFPRztnQkFDVDtnQkFDQSxTQUFTRyxVQUFVSCxPQUFPLEVBQUVELFdBQVcsRUFBRUYsVUFBVTtvQkFDakQsSUFBSSxDQUFDRyxPQUFPLEdBQUdBO29CQUNmLElBQUksT0FBT0QsZ0JBQWdCLFlBQVk7d0JBQ3JDLElBQUksQ0FBQ0EsV0FBVyxHQUFHQTt3QkFDbkIsSUFBSSxDQUFDSyxhQUFhLEdBQUcsSUFBSSxDQUFDQyxrQkFBa0I7b0JBQzlDO29CQUNBLElBQUksT0FBT1IsZUFBZSxZQUFZO3dCQUNwQyxJQUFJLENBQUNBLFVBQVUsR0FBR0E7d0JBQ2xCLElBQUksQ0FBQ1MsWUFBWSxHQUFHLElBQUksQ0FBQ0MsaUJBQWlCO29CQUM1QztnQkFDRjtnQkFDQUosVUFBVVAsU0FBUyxDQUFDUSxhQUFhLEdBQUcsU0FBVUksS0FBSztvQkFDakR0QixTQUFTdUIsT0FBTyxDQUFDLElBQUksQ0FBQ1QsT0FBTyxFQUFFUTtnQkFDakM7Z0JBQ0FMLFVBQVVQLFNBQVMsQ0FBQ1Msa0JBQWtCLEdBQUcsU0FBVUcsS0FBSztvQkFDdEROLE9BQU8sSUFBSSxDQUFDRixPQUFPLEVBQUUsSUFBSSxDQUFDRCxXQUFXLEVBQUVTO2dCQUN6QztnQkFDQUwsVUFBVVAsU0FBUyxDQUFDVSxZQUFZLEdBQUcsU0FBVUUsS0FBSztvQkFDaER0QixTQUFTd0IsTUFBTSxDQUFDLElBQUksQ0FBQ1YsT0FBTyxFQUFFUTtnQkFDaEM7Z0JBQ0FMLFVBQVVQLFNBQVMsQ0FBQ1csaUJBQWlCLEdBQUcsU0FBVUMsS0FBSztvQkFDckROLE9BQU8sSUFBSSxDQUFDRixPQUFPLEVBQUUsSUFBSSxDQUFDSCxVQUFVLEVBQUVXO2dCQUN4QztnQkFFQSxTQUFTTixPQUFPRixPQUFPLEVBQUVXLElBQUksRUFBRUgsS0FBSztvQkFDbEMxQixVQUFVO3dCQUNSLElBQUk4Qjt3QkFDSixJQUFJOzRCQUNGQSxjQUFjRCxLQUFLSDt3QkFDckIsRUFBRSxPQUFPMUUsR0FBRzs0QkFDVixPQUFPb0QsU0FBU3dCLE1BQU0sQ0FBQ1YsU0FBU2xFO3dCQUNsQzt3QkFDQSxJQUFJOEUsZ0JBQWdCWixTQUFTOzRCQUMzQmQsU0FBU3dCLE1BQU0sQ0FBQ1YsU0FBUyxJQUFJUixVQUFVO3dCQUN6QyxPQUFPOzRCQUNMTixTQUFTdUIsT0FBTyxDQUFDVCxTQUFTWTt3QkFDNUI7b0JBQ0Y7Z0JBQ0Y7Z0JBRUExQixTQUFTdUIsT0FBTyxHQUFHLFNBQVU3RSxLQUFJLEVBQUU0RSxLQUFLO29CQUN0QyxJQUFJSyxTQUFTQyxTQUFTQyxTQUFTUDtvQkFDL0IsSUFBSUssT0FBT0csTUFBTSxLQUFLLFNBQVM7d0JBQzdCLE9BQU85QixTQUFTd0IsTUFBTSxDQUFDOUUsT0FBTWlGLE9BQU9MLEtBQUs7b0JBQzNDO29CQUNBLElBQUlTLFdBQVdKLE9BQU9MLEtBQUs7b0JBRTNCLElBQUlTLFVBQVU7d0JBQ1p0QixzQkFBc0IvRCxPQUFNcUY7b0JBQzlCLE9BQU87d0JBQ0xyRixNQUFLNkQsS0FBSyxHQUFHTDt3QkFDYnhELE1BQUs4RCxPQUFPLEdBQUdjO3dCQUNmLElBQUlqRSxJQUFJLENBQUM7d0JBQ1QsSUFBSXNDLE1BQU1qRCxNQUFLK0MsS0FBSyxDQUFDL0IsTUFBTTt3QkFDM0IsTUFBTyxFQUFFTCxJQUFJc0MsSUFBSzs0QkFDaEJqRCxNQUFLK0MsS0FBSyxDQUFDcEMsRUFBRSxDQUFDNkQsYUFBYSxDQUFDSTt3QkFDOUI7b0JBQ0Y7b0JBQ0EsT0FBTzVFO2dCQUNUO2dCQUNBc0QsU0FBU3dCLE1BQU0sR0FBRyxTQUFVOUUsS0FBSSxFQUFFc0YsS0FBSztvQkFDckN0RixNQUFLNkQsS0FBSyxHQUFHTjtvQkFDYnZELE1BQUs4RCxPQUFPLEdBQUd3QjtvQkFDZixJQUFJM0UsSUFBSSxDQUFDO29CQUNULElBQUlzQyxNQUFNakQsTUFBSytDLEtBQUssQ0FBQy9CLE1BQU07b0JBQzNCLE1BQU8sRUFBRUwsSUFBSXNDLElBQUs7d0JBQ2hCakQsTUFBSytDLEtBQUssQ0FBQ3BDLEVBQUUsQ0FBQytELFlBQVksQ0FBQ1k7b0JBQzdCO29CQUNBLE9BQU90RjtnQkFDVDtnQkFFQSxTQUFTbUYsUUFBUUksR0FBRztvQkFDbEIscUVBQXFFO29CQUNyRSxJQUFJckIsT0FBT3FCLE9BQU9BLElBQUlyQixJQUFJO29CQUMxQixJQUFJcUIsT0FBUSxRQUFPQSxRQUFRLFlBQVksT0FBT0EsUUFBUSxVQUFTLEtBQU0sT0FBT3JCLFNBQVMsWUFBWTt3QkFDL0YsT0FBTyxTQUFTc0I7NEJBQ2R0QixLQUFLdUIsS0FBSyxDQUFDRixLQUFLRzt3QkFDbEI7b0JBQ0Y7Z0JBQ0Y7Z0JBRUEsU0FBUzNCLHNCQUFzQi9ELEtBQUksRUFBRXFGLFFBQVE7b0JBQzNDLDhDQUE4QztvQkFDOUMsSUFBSS9ELFNBQVM7b0JBQ2IsU0FBU3FFLFFBQVFmLEtBQUs7d0JBQ3BCLElBQUl0RCxRQUFROzRCQUNWO3dCQUNGO3dCQUNBQSxTQUFTO3dCQUNUZ0MsU0FBU3dCLE1BQU0sQ0FBQzlFLE9BQU00RTtvQkFDeEI7b0JBRUEsU0FBU2dCLFVBQVVoQixLQUFLO3dCQUN0QixJQUFJdEQsUUFBUTs0QkFDVjt3QkFDRjt3QkFDQUEsU0FBUzt3QkFDVGdDLFNBQVN1QixPQUFPLENBQUM3RSxPQUFNNEU7b0JBQ3pCO29CQUVBLFNBQVNpQjt3QkFDUFIsU0FBU08sV0FBV0Q7b0JBQ3RCO29CQUVBLElBQUlWLFNBQVNDLFNBQVNXO29CQUN0QixJQUFJWixPQUFPRyxNQUFNLEtBQUssU0FBUzt3QkFDN0JPLFFBQVFWLE9BQU9MLEtBQUs7b0JBQ3RCO2dCQUNGO2dCQUVBLFNBQVNNLFNBQVNILElBQUksRUFBRUgsS0FBSztvQkFDM0IsSUFBSWtCLE1BQU0sQ0FBQztvQkFDWCxJQUFJO3dCQUNGQSxJQUFJbEIsS0FBSyxHQUFHRyxLQUFLSDt3QkFDakJrQixJQUFJVixNQUFNLEdBQUc7b0JBQ2YsRUFBRSxPQUFPbEYsR0FBRzt3QkFDVjRGLElBQUlWLE1BQU0sR0FBRzt3QkFDYlUsSUFBSWxCLEtBQUssR0FBRzFFO29CQUNkO29CQUNBLE9BQU80RjtnQkFDVDtnQkFFQXBDLFNBQVFtQixPQUFPLEdBQUdBO2dCQUNsQixTQUFTQSxRQUFRRCxLQUFLO29CQUNwQixJQUFJQSxpQkFBaUIsSUFBSSxFQUFFO3dCQUN6QixPQUFPQTtvQkFDVDtvQkFDQSxPQUFPdEIsU0FBU3VCLE9BQU8sQ0FBQyxJQUFJLElBQUksQ0FBQ3hCLFdBQVd1QjtnQkFDOUM7Z0JBRUFsQixTQUFRb0IsTUFBTSxHQUFHQTtnQkFDakIsU0FBU0EsT0FBT2lCLE1BQU07b0JBQ3BCLElBQUkzQixVQUFVLElBQUksSUFBSSxDQUFDZjtvQkFDdkIsT0FBT0MsU0FBU3dCLE1BQU0sQ0FBQ1YsU0FBUzJCO2dCQUNsQztnQkFFQXJDLFNBQVFzQyxHQUFHLEdBQUdBO2dCQUNkLFNBQVNBLElBQUlDLFFBQVE7b0JBQ25CLElBQUlqRyxRQUFPLElBQUk7b0JBQ2YsSUFBSWtHLE9BQU9sQyxTQUFTLENBQUNtQyxRQUFRLENBQUNwRixJQUFJLENBQUNrRixjQUFjLGtCQUFrQjt3QkFDakUsT0FBTyxJQUFJLENBQUNuQixNQUFNLENBQUMsSUFBSWxCLFVBQVU7b0JBQ25DO29CQUVBLElBQUlYLE1BQU1nRCxTQUFTakYsTUFBTTtvQkFDekIsSUFBSU0sU0FBUztvQkFDYixJQUFJLENBQUMyQixLQUFLO3dCQUNSLE9BQU8sSUFBSSxDQUFDNEIsT0FBTyxDQUFDLEVBQUU7b0JBQ3hCO29CQUVBLElBQUl1QixTQUFTLElBQUlDLE1BQU1wRDtvQkFDdkIsSUFBSXFELFdBQVc7b0JBQ2YsSUFBSTNGLElBQUksQ0FBQztvQkFDVCxJQUFJeUQsVUFBVSxJQUFJLElBQUksQ0FBQ2Y7b0JBRXZCLE1BQU8sRUFBRTFDLElBQUlzQyxJQUFLO3dCQUNoQnNELFlBQVlOLFFBQVEsQ0FBQ3RGLEVBQUUsRUFBRUE7b0JBQzNCO29CQUNBLE9BQU95RDtvQkFDUCxTQUFTbUMsWUFBWTNCLEtBQUssRUFBRWpFLENBQUM7d0JBQzNCWCxNQUFLNkUsT0FBTyxDQUFDRCxPQUFPVixJQUFJLENBQUNzQyxnQkFBZ0IsU0FBVWxCLEtBQUs7NEJBQ3RELElBQUksQ0FBQ2hFLFFBQVE7Z0NBQ1hBLFNBQVM7Z0NBQ1RnQyxTQUFTd0IsTUFBTSxDQUFDVixTQUFTa0I7NEJBQzNCO3dCQUNGO3dCQUNBLFNBQVNrQixlQUFlQyxRQUFROzRCQUM5QkwsTUFBTSxDQUFDekYsRUFBRSxHQUFHOEY7NEJBQ1osSUFBSSxFQUFFSCxhQUFhckQsT0FBTyxDQUFDM0IsUUFBUTtnQ0FDakNBLFNBQVM7Z0NBQ1RnQyxTQUFTdUIsT0FBTyxDQUFDVCxTQUFTZ0M7NEJBQzVCO3dCQUNGO29CQUNGO2dCQUNGO2dCQUVBMUMsU0FBUWdELElBQUksR0FBR0E7Z0JBQ2YsU0FBU0EsS0FBS1QsUUFBUTtvQkFDcEIsSUFBSWpHLFFBQU8sSUFBSTtvQkFDZixJQUFJa0csT0FBT2xDLFNBQVMsQ0FBQ21DLFFBQVEsQ0FBQ3BGLElBQUksQ0FBQ2tGLGNBQWMsa0JBQWtCO3dCQUNqRSxPQUFPLElBQUksQ0FBQ25CLE1BQU0sQ0FBQyxJQUFJbEIsVUFBVTtvQkFDbkM7b0JBRUEsSUFBSVgsTUFBTWdELFNBQVNqRixNQUFNO29CQUN6QixJQUFJTSxTQUFTO29CQUNiLElBQUksQ0FBQzJCLEtBQUs7d0JBQ1IsT0FBTyxJQUFJLENBQUM0QixPQUFPLENBQUMsRUFBRTtvQkFDeEI7b0JBRUEsSUFBSWxFLElBQUksQ0FBQztvQkFDVCxJQUFJeUQsVUFBVSxJQUFJLElBQUksQ0FBQ2Y7b0JBRXZCLE1BQU8sRUFBRTFDLElBQUlzQyxJQUFLO3dCQUNoQlUsU0FBU3NDLFFBQVEsQ0FBQ3RGLEVBQUU7b0JBQ3RCO29CQUNBLE9BQU95RDtvQkFDUCxTQUFTVCxTQUFTaUIsS0FBSzt3QkFDckI1RSxNQUFLNkUsT0FBTyxDQUFDRCxPQUFPVixJQUFJLENBQUMsU0FBVXlDLFFBQVE7NEJBQ3pDLElBQUksQ0FBQ3JGLFFBQVE7Z0NBQ1hBLFNBQVM7Z0NBQ1RnQyxTQUFTdUIsT0FBTyxDQUFDVCxTQUFTdUM7NEJBQzVCO3dCQUNGLEdBQUcsU0FBVXJCLEtBQUs7NEJBQ2hCLElBQUksQ0FBQ2hFLFFBQVE7Z0NBQ1hBLFNBQVM7Z0NBQ1RnQyxTQUFTd0IsTUFBTSxDQUFDVixTQUFTa0I7NEJBQzNCO3dCQUNGO29CQUNGO2dCQUNGO1lBRUE7WUFBRTtnQkFBQyxLQUFJO1lBQUM7U0FBRTtRQUFDLEdBQUU7WUFBQyxTQUFTckUsT0FBTyxFQUFDdkIsT0FBTSxFQUFDRCxRQUFPO2dCQUM1QyxVQUFVTSxPQUFNO29CQUNqQjtvQkFDQSxJQUFJLE9BQU9BLFFBQU8yRCxPQUFPLEtBQUssWUFBWTt3QkFDeEMzRCxRQUFPMkQsT0FBTyxHQUFHekMsUUFBUTtvQkFDM0I7Z0JBRUEsR0FBR0YsSUFBSSxDQUFDLElBQUksRUFBQyxPQUFPaEIsV0FBVyxjQUFjQSxTQUFTLE9BQU9DLFNBQVMsY0FBY0EsT0FBTyxNQUE2QixHQUFHRixDQUFNQSxHQUFHLENBQUM7WUFDckk7WUFBRTtnQkFBQyxLQUFJO1lBQUM7U0FBRTtRQUFDLEdBQUU7WUFBQyxTQUFTbUIsT0FBTyxFQUFDdkIsT0FBTSxFQUFDRCxRQUFPO2dCQUM3QztnQkFFQSxJQUFJbUgsVUFBVSxPQUFPQyxXQUFXLGNBQWMsT0FBT0EsT0FBT0MsUUFBUSxLQUFLLFdBQVcsU0FBVXZCLEdBQUc7b0JBQUksT0FBTyxPQUFPQTtnQkFBSyxJQUFJLFNBQVVBLEdBQUc7b0JBQUksT0FBT0EsT0FBTyxPQUFPc0IsV0FBVyxjQUFjdEIsSUFBSWxCLFdBQVcsS0FBS3dDLFVBQVV0QixRQUFRc0IsT0FBTzdDLFNBQVMsR0FBRyxXQUFXLE9BQU91QjtnQkFBSztnQkFFM1EsU0FBU3dCLGdCQUFnQkMsUUFBUSxFQUFFQyxXQUFXO29CQUFJLElBQUksQ0FBRUQsQ0FBQUEsb0JBQW9CQyxXQUFVLEdBQUk7d0JBQUUsTUFBTSxJQUFJckQsVUFBVTtvQkFBc0M7Z0JBQUU7Z0JBRXhKLFNBQVNzRDtvQkFDTCx3RUFBd0UsR0FDeEUsSUFBSTt3QkFDQSxJQUFJLE9BQU9DLGNBQWMsYUFBYTs0QkFDbEMsT0FBT0E7d0JBQ1g7d0JBQ0EsSUFBSSxPQUFPQyxvQkFBb0IsYUFBYTs0QkFDeEMsT0FBT0E7d0JBQ1g7d0JBQ0EsSUFBSSxPQUFPQyxpQkFBaUIsYUFBYTs0QkFDckMsT0FBT0E7d0JBQ1g7d0JBQ0EsSUFBSSxPQUFPQyxlQUFlLGFBQWE7NEJBQ25DLE9BQU9BO3dCQUNYO3dCQUNBLElBQUksT0FBT0MsZ0JBQWdCLGFBQWE7NEJBQ3BDLE9BQU9BO3dCQUNYO29CQUNKLEVBQUUsT0FBT3JILEdBQUc7d0JBQ1I7b0JBQ0o7Z0JBQ0o7Z0JBRUEsSUFBSXNILE1BQU1OO2dCQUVWLFNBQVNPO29CQUNMLElBQUk7d0JBQ0EsOERBQThEO3dCQUM5RCxhQUFhO3dCQUNiLElBQUksQ0FBQ0QsT0FBTyxDQUFDQSxJQUFJRSxJQUFJLEVBQUU7NEJBQ25CLE9BQU87d0JBQ1g7d0JBQ0EseUJBQXlCO3dCQUN6QixFQUFFO3dCQUNGLCtEQUErRDt3QkFDL0QsNEJBQTRCO3dCQUM1QixJQUFJQyxXQUFXLE9BQU9DLGlCQUFpQixlQUFlLDRCQUE0QkMsSUFBSSxDQUFDQyxVQUFVQyxTQUFTLEtBQUssQ0FBQyxTQUFTRixJQUFJLENBQUNDLFVBQVVDLFNBQVMsS0FBSyxDQUFDLGFBQWFGLElBQUksQ0FBQ0MsVUFBVUUsUUFBUTt3QkFFM0wsSUFBSUMsV0FBVyxPQUFPQyxVQUFVLGNBQWNBLE1BQU0vQixRQUFRLEdBQUdnQyxPQUFPLENBQUMsb0JBQW9CLENBQUM7d0JBRTVGLDhEQUE4RDt3QkFDOUQseURBQXlEO3dCQUN6RCxnRUFBZ0U7d0JBQ2hFLDhEQUE4RDt3QkFDOUQsa0JBQWtCO3dCQUNsQix3REFBd0Q7d0JBQ3hELE9BQU8sQ0FBQyxDQUFDUixZQUFZTSxRQUFPLEtBQU0sT0FBT2QsY0FBYyxlQUN2RCw4REFBOEQ7d0JBQzlELHVEQUF1RDt3QkFDdkQseURBQXlEO3dCQUN6RCx5REFBeUQ7d0JBQ3pELE9BQU9pQixnQkFBZ0I7b0JBQzNCLEVBQUUsT0FBT2xJLEdBQUc7d0JBQ1IsT0FBTztvQkFDWDtnQkFDSjtnQkFFQSxrRUFBa0U7Z0JBQ2xFLGlFQUFpRTtnQkFDakUsb0NBQW9DO2dCQUNwQyxrRUFBa0U7Z0JBQ2xFLGlFQUFpRTtnQkFDakUsb0NBQW9DO2dCQUNwQyxTQUFTbUksV0FBV0MsS0FBSyxFQUFFQyxVQUFVO29CQUNqQyxxRUFBcUUsR0FDckVELFFBQVFBLFNBQVMsRUFBRTtvQkFDbkJDLGFBQWFBLGNBQWMsQ0FBQztvQkFDNUIsSUFBSTt3QkFDQSxPQUFPLElBQUlDLEtBQUtGLE9BQU9DO29CQUMzQixFQUFFLE9BQU9ySSxHQUFHO3dCQUNSLElBQUlBLEVBQUV1SSxJQUFJLEtBQUssYUFBYTs0QkFDeEIsTUFBTXZJO3dCQUNWO3dCQUNBLElBQUl3SSxVQUFVLE9BQU9DLGdCQUFnQixjQUFjQSxjQUFjLE9BQU9DLGtCQUFrQixjQUFjQSxnQkFBZ0IsT0FBT0MsbUJBQW1CLGNBQWNBLGlCQUFpQkM7d0JBQ2pMLElBQUlDLFVBQVUsSUFBSUw7d0JBQ2xCLElBQUssSUFBSS9ILElBQUksR0FBR0EsSUFBSTJILE1BQU10SCxNQUFNLEVBQUVMLEtBQUssRUFBRzs0QkFDdENvSSxRQUFRQyxNQUFNLENBQUNWLEtBQUssQ0FBQzNILEVBQUU7d0JBQzNCO3dCQUNBLE9BQU9vSSxRQUFRRSxPQUFPLENBQUNWLFdBQVdXLElBQUk7b0JBQzFDO2dCQUNKO2dCQUVBLG9FQUFvRTtnQkFDcEUsc0JBQXNCO2dCQUN0QixJQUFJLE9BQU94RixZQUFZLGFBQWE7b0JBQ2hDLG1FQUFtRTtvQkFDbkUsNERBQTREO29CQUM1RHpDLFFBQVE7Z0JBQ1o7Z0JBQ0EsSUFBSWtJLFlBQVl6RjtnQkFFaEIsU0FBUzBGLGdCQUFnQmhGLE9BQU8sRUFBRWlGLFFBQVE7b0JBQ3RDLElBQUlBLFVBQVU7d0JBQ1ZqRixRQUFRRixJQUFJLENBQUMsU0FBVWUsTUFBTTs0QkFDekJvRSxTQUFTLE1BQU1wRTt3QkFDbkIsR0FBRyxTQUFVSyxLQUFLOzRCQUNkK0QsU0FBUy9EO3dCQUNiO29CQUNKO2dCQUNKO2dCQUVBLFNBQVNnRSxvQkFBb0JsRixPQUFPLEVBQUVpRixRQUFRLEVBQUVFLGFBQWE7b0JBQ3pELElBQUksT0FBT0YsYUFBYSxZQUFZO3dCQUNoQ2pGLFFBQVFGLElBQUksQ0FBQ21GO29CQUNqQjtvQkFFQSxJQUFJLE9BQU9FLGtCQUFrQixZQUFZO3dCQUNyQ25GLE9BQU8sQ0FBQyxRQUFRLENBQUNtRjtvQkFDckI7Z0JBQ0o7Z0JBRUEsU0FBU0MsYUFBYUMsR0FBRztvQkFDckIsK0RBQStEO29CQUMvRCxJQUFJLE9BQU9BLFFBQVEsVUFBVTt3QkFDekJDLFFBQVFDLElBQUksQ0FBQ0YsTUFBTTt3QkFDbkJBLE1BQU1HLE9BQU9IO29CQUNqQjtvQkFFQSxPQUFPQTtnQkFDWDtnQkFFQSxTQUFTSTtvQkFDTCxJQUFJbkUsVUFBVTFFLE1BQU0sSUFBSSxPQUFPMEUsU0FBUyxDQUFDQSxVQUFVMUUsTUFBTSxHQUFHLEVBQUUsS0FBSyxZQUFZO3dCQUMzRSxPQUFPMEUsU0FBUyxDQUFDQSxVQUFVMUUsTUFBTSxHQUFHLEVBQUU7b0JBQzFDO2dCQUNKO2dCQUVBLGdEQUFnRDtnQkFDaEQsK0NBQStDO2dCQUUvQyxJQUFJOEksNEJBQTRCO2dCQUNoQyxJQUFJQyxnQkFBZ0IsS0FBSztnQkFDekIsSUFBSUMsYUFBYSxDQUFDO2dCQUNsQixJQUFJN0QsV0FBV0QsT0FBT2xDLFNBQVMsQ0FBQ21DLFFBQVE7Z0JBRXhDLG9CQUFvQjtnQkFDcEIsSUFBSThELFlBQVk7Z0JBQ2hCLElBQUlDLGFBQWE7Z0JBRWpCLGtFQUFrRTtnQkFDbEUsNEVBQTRFO2dCQUM1RSxlQUFlO2dCQUNmLDZFQUE2RTtnQkFDN0UsNERBQTREO2dCQUM1RCxTQUFTQyx3QkFBd0JDLEdBQUc7b0JBQ2hDLElBQUlwSixTQUFTb0osSUFBSXBKLE1BQU07b0JBQ3ZCLElBQUlxSixNQUFNLElBQUlDLFlBQVl0SjtvQkFDMUIsSUFBSXVKLE1BQU0sSUFBSUMsV0FBV0g7b0JBQ3pCLElBQUssSUFBSTFKLElBQUksR0FBR0EsSUFBSUssUUFBUUwsSUFBSzt3QkFDN0I0SixHQUFHLENBQUM1SixFQUFFLEdBQUd5SixJQUFJSyxVQUFVLENBQUM5SjtvQkFDNUI7b0JBQ0EsT0FBTzBKO2dCQUNYO2dCQUVBLEVBQUU7Z0JBQ0YsZ0VBQWdFO2dCQUNoRSwyRUFBMkU7Z0JBQzNFLEVBQUU7Z0JBQ0YsOERBQThEO2dCQUM5RCx1RUFBdUU7Z0JBQ3ZFLDRFQUE0RTtnQkFDNUUsRUFBRTtnQkFDRiwrRUFBK0U7Z0JBQy9FLHNFQUFzRTtnQkFDdEUsNkVBQTZFO2dCQUM3RSxFQUFFO2dCQUNGLG1DQUFtQztnQkFDbkMsOEdBQThHO2dCQUM5RyxFQUFFO2dCQUNGLFNBQVNLLGdDQUFnQ2xELEdBQUc7b0JBQ3hDLE9BQU8sSUFBSTJCLFVBQVUsU0FBVXRFLE9BQU87d0JBQ2xDLElBQUk4RixNQUFNbkQsSUFBSW9ELFdBQVcsQ0FBQ2QsMkJBQTJCSTt3QkFDckQsSUFBSVcsT0FBT3hDLFdBQVc7NEJBQUM7eUJBQUc7d0JBQzFCc0MsSUFBSUcsV0FBVyxDQUFDaEIsMkJBQTJCaUIsR0FBRyxDQUFDRixNQUFNO3dCQUVyREYsSUFBSUssT0FBTyxHQUFHLFNBQVU5SyxDQUFDOzRCQUNyQiw2REFBNkQ7NEJBQzdELDJEQUEyRDs0QkFDM0RBLEVBQUUrSyxjQUFjOzRCQUNoQi9LLEVBQUVnTCxlQUFlOzRCQUNqQnJHLFFBQVE7d0JBQ1o7d0JBRUE4RixJQUFJUSxVQUFVLEdBQUc7NEJBQ2IsSUFBSUMsZ0JBQWdCdEQsVUFBVUMsU0FBUyxDQUFDc0QsS0FBSyxDQUFDOzRCQUM5QyxJQUFJQyxjQUFjeEQsVUFBVUMsU0FBUyxDQUFDc0QsS0FBSyxDQUFDOzRCQUM1QyxvQ0FBb0M7NEJBQ3BDLHNFQUFzRTs0QkFDdEV4RyxRQUFReUcsZUFBZSxDQUFDRixpQkFBaUJHLFNBQVNILGFBQWEsQ0FBQyxFQUFFLEVBQUUsT0FBTzt3QkFDL0U7b0JBQ0osRUFBRSxDQUFDLFFBQVEsQ0FBQzt3QkFDUixPQUFPLE9BQU8sK0JBQStCO29CQUNqRDtnQkFDSjtnQkFFQSxTQUFTSSxrQkFBa0JoRSxHQUFHO29CQUMxQixJQUFJLE9BQU91QyxrQkFBa0IsV0FBVzt3QkFDcEMsT0FBT1osVUFBVXRFLE9BQU8sQ0FBQ2tGO29CQUM3QjtvQkFDQSxPQUFPVyxnQ0FBZ0NsRCxLQUFLdEQsSUFBSSxDQUFDLFNBQVVVLEtBQUs7d0JBQzVEbUYsZ0JBQWdCbkY7d0JBQ2hCLE9BQU9tRjtvQkFDWDtnQkFDSjtnQkFFQSxTQUFTMEIsZ0JBQWdCQyxNQUFNO29CQUMzQixJQUFJQyxZQUFZM0IsVUFBVSxDQUFDMEIsT0FBT2pELElBQUksQ0FBQztvQkFFdkMsd0VBQXdFO29CQUN4RSxJQUFJbUQsb0JBQW9CLENBQUM7b0JBRXpCQSxrQkFBa0J4SCxPQUFPLEdBQUcsSUFBSStFLFVBQVUsU0FBVXRFLE9BQU8sRUFBRUMsTUFBTTt3QkFDL0Q4RyxrQkFBa0IvRyxPQUFPLEdBQUdBO3dCQUM1QitHLGtCQUFrQjlHLE1BQU0sR0FBR0E7b0JBQy9CO29CQUVBLGtDQUFrQztvQkFDbEM2RyxVQUFVRSxrQkFBa0IsQ0FBQ3pJLElBQUksQ0FBQ3dJO29CQUVsQywrQ0FBK0M7b0JBQy9DLElBQUksQ0FBQ0QsVUFBVUcsT0FBTyxFQUFFO3dCQUNwQkgsVUFBVUcsT0FBTyxHQUFHRixrQkFBa0J4SCxPQUFPO29CQUNqRCxPQUFPO3dCQUNIdUgsVUFBVUcsT0FBTyxHQUFHSCxVQUFVRyxPQUFPLENBQUM1SCxJQUFJLENBQUM7NEJBQ3ZDLE9BQU8wSCxrQkFBa0J4SCxPQUFPO3dCQUNwQztvQkFDSjtnQkFDSjtnQkFFQSxTQUFTMkgsa0JBQWtCTCxNQUFNO29CQUM3QixJQUFJQyxZQUFZM0IsVUFBVSxDQUFDMEIsT0FBT2pELElBQUksQ0FBQztvQkFFdkMsZ0NBQWdDO29CQUNoQyxJQUFJbUQsb0JBQW9CRCxVQUFVRSxrQkFBa0IsQ0FBQ0csR0FBRztvQkFFeEQsK0RBQStEO29CQUMvRCxzQkFBc0I7b0JBQ3RCLElBQUlKLG1CQUFtQjt3QkFDbkJBLGtCQUFrQi9HLE9BQU87d0JBQ3pCLE9BQU8rRyxrQkFBa0J4SCxPQUFPO29CQUNwQztnQkFDSjtnQkFFQSxTQUFTNkgsaUJBQWlCUCxNQUFNLEVBQUVRLEdBQUc7b0JBQ2pDLElBQUlQLFlBQVkzQixVQUFVLENBQUMwQixPQUFPakQsSUFBSSxDQUFDO29CQUV2QyxnQ0FBZ0M7b0JBQ2hDLElBQUltRCxvQkFBb0JELFVBQVVFLGtCQUFrQixDQUFDRyxHQUFHO29CQUV4RCw4REFBOEQ7b0JBQzlELHNCQUFzQjtvQkFDdEIsSUFBSUosbUJBQW1CO3dCQUNuQkEsa0JBQWtCOUcsTUFBTSxDQUFDb0g7d0JBQ3pCLE9BQU9OLGtCQUFrQnhILE9BQU87b0JBQ3BDO2dCQUNKO2dCQUVBLFNBQVMrSCxlQUFlVCxNQUFNLEVBQUVVLGFBQWE7b0JBQ3pDLE9BQU8sSUFBSWpELFVBQVUsU0FBVXRFLE9BQU8sRUFBRUMsTUFBTTt3QkFDMUNrRixVQUFVLENBQUMwQixPQUFPakQsSUFBSSxDQUFDLEdBQUd1QixVQUFVLENBQUMwQixPQUFPakQsSUFBSSxDQUFDLElBQUk0RDt3QkFFckQsSUFBSVgsT0FBT1ksRUFBRSxFQUFFOzRCQUNYLElBQUlGLGVBQWU7Z0NBQ2ZYLGdCQUFnQkM7Z0NBQ2hCQSxPQUFPWSxFQUFFLENBQUNDLEtBQUs7NEJBQ25CLE9BQU87Z0NBQ0gsT0FBTzFILFFBQVE2RyxPQUFPWSxFQUFFOzRCQUM1Qjt3QkFDSjt3QkFFQSxJQUFJRSxTQUFTOzRCQUFDZCxPQUFPakQsSUFBSTt5QkFBQzt3QkFFMUIsSUFBSTJELGVBQWU7NEJBQ2ZJLE9BQU9wSixJQUFJLENBQUNzSSxPQUFPZSxPQUFPO3dCQUM5Qjt3QkFFQSxJQUFJQyxVQUFVbEYsSUFBSUUsSUFBSSxDQUFDakMsS0FBSyxDQUFDK0IsS0FBS2dGO3dCQUVsQyxJQUFJSixlQUFlOzRCQUNmTSxRQUFRQyxlQUFlLEdBQUcsU0FBVXpNLENBQUM7Z0NBQ2pDLElBQUlvTSxLQUFLSSxRQUFRekgsTUFBTTtnQ0FDdkIsSUFBSTtvQ0FDQXFILEdBQUdNLGlCQUFpQixDQUFDbEIsT0FBT21CLFNBQVM7b0NBQ3JDLElBQUkzTSxFQUFFNE0sVUFBVSxJQUFJLEdBQUc7d0NBQ25CLDhDQUE4Qzt3Q0FDOUNSLEdBQUdNLGlCQUFpQixDQUFDOUM7b0NBQ3pCO2dDQUNKLEVBQUUsT0FBT2lELElBQUk7b0NBQ1QsSUFBSUEsR0FBR3RFLElBQUksS0FBSyxtQkFBbUI7d0NBQy9CaUIsUUFBUUMsSUFBSSxDQUFDLG1CQUFtQitCLE9BQU9qRCxJQUFJLEdBQUcsTUFBTSxxQ0FBcUN2SSxFQUFFNE0sVUFBVSxHQUFHLGlCQUFpQjVNLEVBQUU4TSxVQUFVLEdBQUcsd0JBQXdCdEIsT0FBT21CLFNBQVMsR0FBRztvQ0FDdkwsT0FBTzt3Q0FDSCxNQUFNRTtvQ0FDVjtnQ0FDSjs0QkFDSjt3QkFDSjt3QkFFQUwsUUFBUU8sT0FBTyxHQUFHLFNBQVUvTSxDQUFDOzRCQUN6QkEsRUFBRStLLGNBQWM7NEJBQ2hCbkcsT0FBTzRILFFBQVFwSCxLQUFLO3dCQUN4Qjt3QkFFQW9ILFFBQVFRLFNBQVMsR0FBRzs0QkFDaEIsSUFBSVosS0FBS0ksUUFBUXpILE1BQU07NEJBQ3ZCcUgsR0FBR2EsZUFBZSxHQUFHLFNBQVVqTixDQUFDO2dDQUM1QiwwRUFBMEU7Z0NBQzFFLHFFQUFxRTtnQ0FDckUsNEVBQTRFO2dDQUM1RSwyRUFBMkU7Z0NBQzNFLHdEQUF3RDtnQ0FDeERBLEVBQUVrTixNQUFNLENBQUNiLEtBQUs7NEJBQ2xCOzRCQUNBMUgsUUFBUXlIOzRCQUNSUCxrQkFBa0JMO3dCQUN0QjtvQkFDSjtnQkFDSjtnQkFFQSxTQUFTMkIsdUJBQXVCM0IsTUFBTTtvQkFDbEMsT0FBT1MsZUFBZVQsUUFBUTtnQkFDbEM7Z0JBRUEsU0FBUzRCLHVCQUF1QjVCLE1BQU07b0JBQ2xDLE9BQU9TLGVBQWVULFFBQVE7Z0JBQ2xDO2dCQUVBLFNBQVM2QixpQkFBaUI3QixNQUFNLEVBQUU4QixjQUFjO29CQUM1QyxJQUFJLENBQUM5QixPQUFPWSxFQUFFLEVBQUU7d0JBQ1osT0FBTztvQkFDWDtvQkFFQSxJQUFJbUIsYUFBYSxDQUFDL0IsT0FBT1ksRUFBRSxDQUFDb0IsZ0JBQWdCLENBQUNDLFFBQVEsQ0FBQ2pDLE9BQU9tQixTQUFTO29CQUN0RSxJQUFJZSxjQUFjbEMsT0FBT2UsT0FBTyxHQUFHZixPQUFPWSxFQUFFLENBQUNHLE9BQU87b0JBQ3BELElBQUlvQixZQUFZbkMsT0FBT2UsT0FBTyxHQUFHZixPQUFPWSxFQUFFLENBQUNHLE9BQU87b0JBRWxELElBQUltQixhQUFhO3dCQUNiLHdDQUF3Qzt3QkFDeEMsc0NBQXNDO3dCQUN0QyxJQUFJbEMsT0FBT2UsT0FBTyxLQUFLZSxnQkFBZ0I7NEJBQ25DOUQsUUFBUUMsSUFBSSxDQUFDLG1CQUFtQitCLE9BQU9qRCxJQUFJLEdBQUcsTUFBTSx1Q0FBdUNpRCxPQUFPWSxFQUFFLENBQUNHLE9BQU8sR0FBRyxpQkFBaUJmLE9BQU9lLE9BQU8sR0FBRzt3QkFDcko7d0JBQ0Esd0NBQXdDO3dCQUN4Q2YsT0FBT2UsT0FBTyxHQUFHZixPQUFPWSxFQUFFLENBQUNHLE9BQU87b0JBQ3RDO29CQUVBLElBQUlvQixhQUFhSixZQUFZO3dCQUN6Qiw4REFBOEQ7d0JBQzlELCtEQUErRDt3QkFDL0Qsd0JBQXdCO3dCQUN4QixJQUFJQSxZQUFZOzRCQUNaLElBQUlLLGFBQWFwQyxPQUFPWSxFQUFFLENBQUNHLE9BQU8sR0FBRzs0QkFDckMsSUFBSXFCLGFBQWFwQyxPQUFPZSxPQUFPLEVBQUU7Z0NBQzdCZixPQUFPZSxPQUFPLEdBQUdxQjs0QkFDckI7d0JBQ0o7d0JBRUEsT0FBTztvQkFDWDtvQkFFQSxPQUFPO2dCQUNYO2dCQUVBLCtEQUErRDtnQkFDL0QsU0FBU0MsWUFBWWxELElBQUk7b0JBQ3JCLE9BQU8sSUFBSTFCLFVBQVUsU0FBVXRFLE9BQU8sRUFBRUMsTUFBTTt3QkFDMUMsSUFBSWtKLFNBQVMsSUFBSUM7d0JBQ2pCRCxPQUFPZixPQUFPLEdBQUduSTt3QkFDakJrSixPQUFPRSxTQUFTLEdBQUcsU0FBVWhPLENBQUM7NEJBQzFCLElBQUlpTyxTQUFTQyxLQUFLbE8sRUFBRWtOLE1BQU0sQ0FBQ25JLE1BQU0sSUFBSTs0QkFDckNKLFFBQVE7Z0NBQ0p3Siw2QkFBNkI7Z0NBQzdCdk0sTUFBTXFNO2dDQUNOakYsTUFBTTJCLEtBQUszQixJQUFJOzRCQUNuQjt3QkFDSjt3QkFDQThFLE9BQU9NLGtCQUFrQixDQUFDekQ7b0JBQzlCO2dCQUNKO2dCQUVBLHlCQUF5QjtnQkFDekIsU0FBUzBELFlBQVlDLFdBQVc7b0JBQzVCLElBQUlDLFlBQVl0RSx3QkFBd0J1RSxLQUFLRixZQUFZMU0sSUFBSTtvQkFDN0QsT0FBT3VHLFdBQVc7d0JBQUNvRztxQkFBVSxFQUFFO3dCQUFFdkYsTUFBTXNGLFlBQVl0RixJQUFJO29CQUFDO2dCQUM1RDtnQkFFQSwwQ0FBMEM7Z0JBQzFDLFNBQVN5RixlQUFlL0osS0FBSztvQkFDekIsT0FBT0EsU0FBU0EsTUFBTXlKLDJCQUEyQjtnQkFDckQ7Z0JBRUEsbUVBQW1FO2dCQUNuRSx3RUFBd0U7Z0JBQ3hFLHdFQUF3RTtnQkFDeEUsa0VBQWtFO2dCQUNsRSxTQUFTTyxZQUFZdkYsUUFBUTtvQkFDekIsSUFBSXJKLFFBQU8sSUFBSTtvQkFFZixJQUFJb0UsVUFBVXBFLE1BQUs2TyxVQUFVLEdBQUczSyxJQUFJLENBQUM7d0JBQ2pDLElBQUl5SCxZQUFZM0IsVUFBVSxDQUFDaEssTUFBSzhPLE9BQU8sQ0FBQ3JHLElBQUksQ0FBQzt3QkFFN0MsSUFBSWtELGFBQWFBLFVBQVVHLE9BQU8sRUFBRTs0QkFDaEMsT0FBT0gsVUFBVUcsT0FBTzt3QkFDNUI7b0JBQ0o7b0JBRUF4QyxvQkFBb0JsRixTQUFTaUYsVUFBVUE7b0JBQ3ZDLE9BQU9qRjtnQkFDWDtnQkFFQSxzREFBc0Q7Z0JBQ3RELGlEQUFpRDtnQkFDakQsbURBQW1EO2dCQUNuRCxTQUFTMkssY0FBY3JELE1BQU07b0JBQ3pCRCxnQkFBZ0JDO29CQUVoQixJQUFJQyxZQUFZM0IsVUFBVSxDQUFDMEIsT0FBT2pELElBQUksQ0FBQztvQkFDdkMsSUFBSXVHLFVBQVVyRCxVQUFVcUQsT0FBTztvQkFFL0IsSUFBSyxJQUFJck8sSUFBSSxHQUFHQSxJQUFJcU8sUUFBUWhPLE1BQU0sRUFBRUwsSUFBSzt3QkFDckMsSUFBSXNPLFNBQVNELE9BQU8sQ0FBQ3JPLEVBQUU7d0JBQ3ZCLElBQUlzTyxPQUFPSCxPQUFPLENBQUN4QyxFQUFFLEVBQUU7NEJBQ25CMkMsT0FBT0gsT0FBTyxDQUFDeEMsRUFBRSxDQUFDQyxLQUFLOzRCQUN2QjBDLE9BQU9ILE9BQU8sQ0FBQ3hDLEVBQUUsR0FBRzt3QkFDeEI7b0JBQ0o7b0JBQ0FaLE9BQU9ZLEVBQUUsR0FBRztvQkFFWixPQUFPZSx1QkFBdUIzQixRQUFReEgsSUFBSSxDQUFDLFNBQVVvSSxFQUFFO3dCQUNuRFosT0FBT1ksRUFBRSxHQUFHQTt3QkFDWixJQUFJaUIsaUJBQWlCN0IsU0FBUzs0QkFDMUIscUNBQXFDOzRCQUNyQyxPQUFPNEIsdUJBQXVCNUI7d0JBQ2xDO3dCQUNBLE9BQU9ZO29CQUNYLEdBQUdwSSxJQUFJLENBQUMsU0FBVW9JLEVBQUU7d0JBQ2hCLGdDQUFnQzt3QkFDaEMsOEJBQThCO3dCQUM5QlosT0FBT1ksRUFBRSxHQUFHWCxVQUFVVyxFQUFFLEdBQUdBO3dCQUMzQixJQUFLLElBQUkzTCxJQUFJLEdBQUdBLElBQUlxTyxRQUFRaE8sTUFBTSxFQUFFTCxJQUFLOzRCQUNyQ3FPLE9BQU8sQ0FBQ3JPLEVBQUUsQ0FBQ21PLE9BQU8sQ0FBQ3hDLEVBQUUsR0FBR0E7d0JBQzVCO29CQUNKLEVBQUUsQ0FBQyxRQUFRLENBQUMsU0FBVUosR0FBRzt3QkFDckJELGlCQUFpQlAsUUFBUVE7d0JBQ3pCLE1BQU1BO29CQUNWO2dCQUNKO2dCQUVBLG9FQUFvRTtnQkFDcEUscUNBQXFDO2dCQUNyQyxTQUFTZ0Qsa0JBQWtCeEQsTUFBTSxFQUFFeUQsSUFBSSxFQUFFOUYsUUFBUSxFQUFFK0YsT0FBTztvQkFDdEQsSUFBSUEsWUFBWUMsV0FBVzt3QkFDdkJELFVBQVU7b0JBQ2Q7b0JBRUEsSUFBSTt3QkFDQSxJQUFJRSxLQUFLNUQsT0FBT1ksRUFBRSxDQUFDMUIsV0FBVyxDQUFDYyxPQUFPbUIsU0FBUyxFQUFFc0M7d0JBQ2pEOUYsU0FBUyxNQUFNaUc7b0JBQ25CLEVBQUUsT0FBT3BELEtBQUs7d0JBQ1YsSUFBSWtELFVBQVUsS0FBTSxFQUFDMUQsT0FBT1ksRUFBRSxJQUFJSixJQUFJekQsSUFBSSxLQUFLLHVCQUF1QnlELElBQUl6RCxJQUFJLEtBQUssZUFBYyxHQUFJOzRCQUNqRyxPQUFPVSxVQUFVdEUsT0FBTyxHQUFHWCxJQUFJLENBQUM7Z0NBQzVCLElBQUksQ0FBQ3dILE9BQU9ZLEVBQUUsSUFBSUosSUFBSXpELElBQUksS0FBSyxtQkFBbUIsQ0FBQ2lELE9BQU9ZLEVBQUUsQ0FBQ29CLGdCQUFnQixDQUFDQyxRQUFRLENBQUNqQyxPQUFPbUIsU0FBUyxLQUFLbkIsT0FBT2UsT0FBTyxJQUFJZixPQUFPWSxFQUFFLENBQUNHLE9BQU8sRUFBRTtvQ0FDN0kseURBQXlEO29DQUN6RCxJQUFJZixPQUFPWSxFQUFFLEVBQUU7d0NBQ1haLE9BQU9lLE9BQU8sR0FBR2YsT0FBT1ksRUFBRSxDQUFDRyxPQUFPLEdBQUc7b0NBQ3pDO29DQUNBLHFDQUFxQztvQ0FDckMsT0FBT2EsdUJBQXVCNUI7Z0NBQ2xDOzRCQUNKLEdBQUd4SCxJQUFJLENBQUM7Z0NBQ0osT0FBTzZLLGNBQWNyRCxRQUFReEgsSUFBSSxDQUFDO29DQUM5QmdMLGtCQUFrQnhELFFBQVF5RCxNQUFNOUYsVUFBVStGLFVBQVU7Z0NBQ3hEOzRCQUNKLEVBQUUsQ0FBQyxRQUFRLENBQUMvRjt3QkFDaEI7d0JBRUFBLFNBQVM2QztvQkFDYjtnQkFDSjtnQkFFQSxTQUFTRztvQkFDTCxPQUFPO3dCQUNILDJDQUEyQzt3QkFDM0MyQyxTQUFTLEVBQUU7d0JBQ1gsbUJBQW1CO3dCQUNuQjFDLElBQUk7d0JBQ0osZ0NBQWdDO3dCQUNoQ1IsU0FBUzt3QkFDVCx1Q0FBdUM7d0JBQ3ZDRCxvQkFBb0IsRUFBRTtvQkFDMUI7Z0JBQ0o7Z0JBRUEsdUVBQXVFO2dCQUN2RSwwREFBMEQ7Z0JBQzFELFNBQVMwRCxhQUFhQyxPQUFPO29CQUN6QixJQUFJeFAsUUFBTyxJQUFJO29CQUNmLElBQUkwTCxTQUFTO3dCQUNUWSxJQUFJO29CQUNSO29CQUVBLElBQUlrRCxTQUFTO3dCQUNULElBQUssSUFBSTdPLEtBQUs2TyxRQUFTOzRCQUNuQjlELE1BQU0sQ0FBQy9LLEVBQUUsR0FBRzZPLE9BQU8sQ0FBQzdPLEVBQUU7d0JBQzFCO29CQUNKO29CQUVBLDJDQUEyQztvQkFDM0MsSUFBSWdMLFlBQVkzQixVQUFVLENBQUMwQixPQUFPakQsSUFBSSxDQUFDO29CQUV2Qyw4QkFBOEI7b0JBQzlCLElBQUksQ0FBQ2tELFdBQVc7d0JBQ1pBLFlBQVlVO3dCQUNaLG9EQUFvRDt3QkFDcERyQyxVQUFVLENBQUMwQixPQUFPakQsSUFBSSxDQUFDLEdBQUdrRDtvQkFDOUI7b0JBRUEsbUVBQW1FO29CQUNuRUEsVUFBVXFELE9BQU8sQ0FBQzVMLElBQUksQ0FBQ3BEO29CQUV2QixtRUFBbUU7b0JBQ25FLElBQUksQ0FBQ0EsTUFBSzZPLFVBQVUsRUFBRTt3QkFDbEI3TyxNQUFLNk8sVUFBVSxHQUFHN08sTUFBS3lQLEtBQUs7d0JBQzVCelAsTUFBS3lQLEtBQUssR0FBR2I7b0JBQ2pCO29CQUVBLHdFQUF3RTtvQkFDeEUsSUFBSWMsZUFBZSxFQUFFO29CQUVyQixTQUFTQzt3QkFDTCw0QkFBNEI7d0JBQzVCLHVEQUF1RDt3QkFDdkQsT0FBT3hHLFVBQVV0RSxPQUFPO29CQUM1QjtvQkFFQSxJQUFLLElBQUkrSyxJQUFJLEdBQUdBLElBQUlqRSxVQUFVcUQsT0FBTyxDQUFDaE8sTUFBTSxFQUFFNE8sSUFBSzt3QkFDL0MsSUFBSVgsU0FBU3RELFVBQVVxRCxPQUFPLENBQUNZLEVBQUU7d0JBQ2pDLElBQUlYLFdBQVdqUCxPQUFNOzRCQUNqQiwyQkFBMkI7NEJBQzNCMFAsYUFBYXRNLElBQUksQ0FBQzZMLE9BQU9KLFVBQVUsRUFBRSxDQUFDLFFBQVEsQ0FBQ2M7d0JBQ25EO29CQUNKO29CQUVBLCtDQUErQztvQkFDL0MsSUFBSVgsVUFBVXJELFVBQVVxRCxPQUFPLENBQUNhLEtBQUssQ0FBQztvQkFFdEMsOENBQThDO29CQUM5QywrQ0FBK0M7b0JBQy9DLE9BQU8xRyxVQUFVbkQsR0FBRyxDQUFDMEosY0FBY3hMLElBQUksQ0FBQzt3QkFDcEN3SCxPQUFPWSxFQUFFLEdBQUdYLFVBQVVXLEVBQUU7d0JBQ3hCLHdEQUF3RDt3QkFDeEQsT0FBT2UsdUJBQXVCM0I7b0JBQ2xDLEdBQUd4SCxJQUFJLENBQUMsU0FBVW9JLEVBQUU7d0JBQ2hCWixPQUFPWSxFQUFFLEdBQUdBO3dCQUNaLElBQUlpQixpQkFBaUI3QixRQUFRMUwsTUFBSzhQLGNBQWMsQ0FBQ3JELE9BQU8sR0FBRzs0QkFDdkQscUNBQXFDOzRCQUNyQyxPQUFPYSx1QkFBdUI1Qjt3QkFDbEM7d0JBQ0EsT0FBT1k7b0JBQ1gsR0FBR3BJLElBQUksQ0FBQyxTQUFVb0ksRUFBRTt3QkFDaEJaLE9BQU9ZLEVBQUUsR0FBR1gsVUFBVVcsRUFBRSxHQUFHQTt3QkFDM0J0TSxNQUFLOE8sT0FBTyxHQUFHcEQ7d0JBQ2YsMkRBQTJEO3dCQUMzRCxJQUFLLElBQUlxRSxJQUFJLEdBQUdBLElBQUlmLFFBQVFoTyxNQUFNLEVBQUUrTyxJQUFLOzRCQUNyQyxJQUFJZCxTQUFTRCxPQUFPLENBQUNlLEVBQUU7NEJBQ3ZCLElBQUlkLFdBQVdqUCxPQUFNO2dDQUNqQiw4QkFBOEI7Z0NBQzlCaVAsT0FBT0gsT0FBTyxDQUFDeEMsRUFBRSxHQUFHWixPQUFPWSxFQUFFO2dDQUM3QjJDLE9BQU9ILE9BQU8sQ0FBQ3JDLE9BQU8sR0FBR2YsT0FBT2UsT0FBTzs0QkFDM0M7d0JBQ0o7b0JBQ0o7Z0JBQ0o7Z0JBRUEsU0FBU3VELFFBQVF2RyxHQUFHLEVBQUVKLFFBQVE7b0JBQzFCLElBQUlySixRQUFPLElBQUk7b0JBRWZ5SixNQUFNRCxhQUFhQztvQkFFbkIsSUFBSXJGLFVBQVUsSUFBSStFLFVBQVUsU0FBVXRFLE9BQU8sRUFBRUMsTUFBTTt3QkFDakQ5RSxNQUFLeVAsS0FBSyxHQUFHdkwsSUFBSSxDQUFDOzRCQUNkZ0wsa0JBQWtCbFAsTUFBSzhPLE9BQU8sRUFBRTdFLFdBQVcsU0FBVWlDLEdBQUcsRUFBRXRCLFdBQVc7Z0NBQ2pFLElBQUlzQixLQUFLO29DQUNMLE9BQU9wSCxPQUFPb0g7Z0NBQ2xCO2dDQUVBLElBQUk7b0NBQ0EsSUFBSStELFFBQVFyRixZQUFZRSxXQUFXLENBQUM5SyxNQUFLOE8sT0FBTyxDQUFDakMsU0FBUztvQ0FDMUQsSUFBSXFELE1BQU1ELE1BQU1FLEdBQUcsQ0FBQzFHO29DQUVwQnlHLElBQUloRCxTQUFTLEdBQUc7d0NBQ1osSUFBSXRJLFFBQVFzTCxJQUFJakwsTUFBTTt3Q0FDdEIsSUFBSUwsVUFBVXlLLFdBQVc7NENBQ3JCekssUUFBUTt3Q0FDWjt3Q0FDQSxJQUFJK0osZUFBZS9KLFFBQVE7NENBQ3ZCQSxRQUFRMkosWUFBWTNKO3dDQUN4Qjt3Q0FDQUMsUUFBUUQ7b0NBQ1o7b0NBRUFzTCxJQUFJakQsT0FBTyxHQUFHO3dDQUNWbkksT0FBT29MLElBQUk1SyxLQUFLO29DQUNwQjtnQ0FDSixFQUFFLE9BQU9wRixHQUFHO29DQUNSNEUsT0FBTzVFO2dDQUNYOzRCQUNKO3dCQUNKLEVBQUUsQ0FBQyxRQUFRLENBQUM0RTtvQkFDaEI7b0JBRUFzRSxnQkFBZ0JoRixTQUFTaUY7b0JBQ3pCLE9BQU9qRjtnQkFDWDtnQkFFQSw2Q0FBNkM7Z0JBQzdDLFNBQVNnTSxRQUFRdEosUUFBUSxFQUFFdUMsUUFBUTtvQkFDL0IsSUFBSXJKLFFBQU8sSUFBSTtvQkFFZixJQUFJb0UsVUFBVSxJQUFJK0UsVUFBVSxTQUFVdEUsT0FBTyxFQUFFQyxNQUFNO3dCQUNqRDlFLE1BQUt5UCxLQUFLLEdBQUd2TCxJQUFJLENBQUM7NEJBQ2RnTCxrQkFBa0JsUCxNQUFLOE8sT0FBTyxFQUFFN0UsV0FBVyxTQUFVaUMsR0FBRyxFQUFFdEIsV0FBVztnQ0FDakUsSUFBSXNCLEtBQUs7b0NBQ0wsT0FBT3BILE9BQU9vSDtnQ0FDbEI7Z0NBRUEsSUFBSTtvQ0FDQSxJQUFJK0QsUUFBUXJGLFlBQVlFLFdBQVcsQ0FBQzlLLE1BQUs4TyxPQUFPLENBQUNqQyxTQUFTO29DQUMxRCxJQUFJcUQsTUFBTUQsTUFBTUksVUFBVTtvQ0FDMUIsSUFBSUMsa0JBQWtCO29DQUV0QkosSUFBSWhELFNBQVMsR0FBRzt3Q0FDWixJQUFJcUQsU0FBU0wsSUFBSWpMLE1BQU07d0NBRXZCLElBQUlzTCxRQUFROzRDQUNSLElBQUkzTCxRQUFRMkwsT0FBTzNMLEtBQUs7NENBQ3hCLElBQUkrSixlQUFlL0osUUFBUTtnREFDdkJBLFFBQVEySixZQUFZM0o7NENBQ3hCOzRDQUNBLElBQUlLLFNBQVM2QixTQUFTbEMsT0FBTzJMLE9BQU85RyxHQUFHLEVBQUU2Rzs0Q0FFekMseUNBQXlDOzRDQUN6Qyx3Q0FBd0M7NENBQ3hDLDRCQUE0Qjs0Q0FDNUIsSUFBSXJMLFdBQVcsS0FBSyxHQUFHO2dEQUNuQkosUUFBUUk7NENBQ1osT0FBTztnREFDSHNMLE1BQU0sQ0FBQyxXQUFXOzRDQUN0Qjt3Q0FDSixPQUFPOzRDQUNIMUw7d0NBQ0o7b0NBQ0o7b0NBRUFxTCxJQUFJakQsT0FBTyxHQUFHO3dDQUNWbkksT0FBT29MLElBQUk1SyxLQUFLO29DQUNwQjtnQ0FDSixFQUFFLE9BQU9wRixHQUFHO29DQUNSNEUsT0FBTzVFO2dDQUNYOzRCQUNKO3dCQUNKLEVBQUUsQ0FBQyxRQUFRLENBQUM0RTtvQkFDaEI7b0JBRUFzRSxnQkFBZ0JoRixTQUFTaUY7b0JBRXpCLE9BQU9qRjtnQkFDWDtnQkFFQSxTQUFTb00sUUFBUS9HLEdBQUcsRUFBRTdFLEtBQUssRUFBRXlFLFFBQVE7b0JBQ2pDLElBQUlySixRQUFPLElBQUk7b0JBRWZ5SixNQUFNRCxhQUFhQztvQkFFbkIsSUFBSXJGLFVBQVUsSUFBSStFLFVBQVUsU0FBVXRFLE9BQU8sRUFBRUMsTUFBTTt3QkFDakQsSUFBSTRHO3dCQUNKMUwsTUFBS3lQLEtBQUssR0FBR3ZMLElBQUksQ0FBQzs0QkFDZHdILFNBQVMxTCxNQUFLOE8sT0FBTzs0QkFDckIsSUFBSTNJLFNBQVNwRixJQUFJLENBQUM2RCxXQUFXLGlCQUFpQjtnQ0FDMUMsT0FBTzRHLGtCQUFrQkUsT0FBT1ksRUFBRSxFQUFFcEksSUFBSSxDQUFDLFNBQVV1TSxXQUFXO29DQUMxRCxJQUFJQSxhQUFhO3dDQUNiLE9BQU83TDtvQ0FDWDtvQ0FDQSxPQUFPbUosWUFBWW5KO2dDQUN2Qjs0QkFDSjs0QkFDQSxPQUFPQTt3QkFDWCxHQUFHVixJQUFJLENBQUMsU0FBVVUsS0FBSzs0QkFDbkJzSyxrQkFBa0JsUCxNQUFLOE8sT0FBTyxFQUFFNUUsWUFBWSxTQUFVZ0MsR0FBRyxFQUFFdEIsV0FBVztnQ0FDbEUsSUFBSXNCLEtBQUs7b0NBQ0wsT0FBT3BILE9BQU9vSDtnQ0FDbEI7Z0NBRUEsSUFBSTtvQ0FDQSxJQUFJK0QsUUFBUXJGLFlBQVlFLFdBQVcsQ0FBQzlLLE1BQUs4TyxPQUFPLENBQUNqQyxTQUFTO29DQUUxRCx3REFBd0Q7b0NBQ3hELHVEQUF1RDtvQ0FDdkQsK0JBQStCO29DQUMvQix5REFBeUQ7b0NBQ3pELElBQUlqSSxVQUFVLE1BQU07d0NBQ2hCQSxRQUFReUs7b0NBQ1o7b0NBRUEsSUFBSWEsTUFBTUQsTUFBTWxGLEdBQUcsQ0FBQ25HLE9BQU82RTtvQ0FFM0JtQixZQUFZTyxVQUFVLEdBQUc7d0NBQ3JCLDJDQUEyQzt3Q0FDM0MseURBQXlEO3dDQUN6RCxxREFBcUQ7d0NBQ3JELHNEQUFzRDt3Q0FDdEQsMERBQTBEO3dDQUMxRCxjQUFjO3dDQUNkLElBQUl2RyxVQUFVeUssV0FBVzs0Q0FDckJ6SyxRQUFRO3dDQUNaO3dDQUVBQyxRQUFRRDtvQ0FDWjtvQ0FDQWdHLFlBQVlJLE9BQU8sR0FBR0osWUFBWXFDLE9BQU8sR0FBRzt3Q0FDeEMsSUFBSWYsTUFBTWdFLElBQUk1SyxLQUFLLEdBQUc0SyxJQUFJNUssS0FBSyxHQUFHNEssSUFBSXRGLFdBQVcsQ0FBQ3RGLEtBQUs7d0NBQ3ZEUixPQUFPb0g7b0NBQ1g7Z0NBQ0osRUFBRSxPQUFPaE0sR0FBRztvQ0FDUjRFLE9BQU81RTtnQ0FDWDs0QkFDSjt3QkFDSixFQUFFLENBQUMsUUFBUSxDQUFDNEU7b0JBQ2hCO29CQUVBc0UsZ0JBQWdCaEYsU0FBU2lGO29CQUN6QixPQUFPakY7Z0JBQ1g7Z0JBRUEsU0FBU3NNLFdBQVdqSCxHQUFHLEVBQUVKLFFBQVE7b0JBQzdCLElBQUlySixRQUFPLElBQUk7b0JBRWZ5SixNQUFNRCxhQUFhQztvQkFFbkIsSUFBSXJGLFVBQVUsSUFBSStFLFVBQVUsU0FBVXRFLE9BQU8sRUFBRUMsTUFBTTt3QkFDakQ5RSxNQUFLeVAsS0FBSyxHQUFHdkwsSUFBSSxDQUFDOzRCQUNkZ0wsa0JBQWtCbFAsTUFBSzhPLE9BQU8sRUFBRTVFLFlBQVksU0FBVWdDLEdBQUcsRUFBRXRCLFdBQVc7Z0NBQ2xFLElBQUlzQixLQUFLO29DQUNMLE9BQU9wSCxPQUFPb0g7Z0NBQ2xCO2dDQUVBLElBQUk7b0NBQ0EsSUFBSStELFFBQVFyRixZQUFZRSxXQUFXLENBQUM5SyxNQUFLOE8sT0FBTyxDQUFDakMsU0FBUztvQ0FDMUQsd0RBQXdEO29DQUN4RCx5REFBeUQ7b0NBQ3pELHdEQUF3RDtvQ0FDeEQsc0RBQXNEO29DQUN0RCx5QkFBeUI7b0NBQ3pCLElBQUlxRCxNQUFNRCxLQUFLLENBQUMsU0FBUyxDQUFDeEc7b0NBQzFCbUIsWUFBWU8sVUFBVSxHQUFHO3dDQUNyQnRHO29DQUNKO29DQUVBK0YsWUFBWXFDLE9BQU8sR0FBRzt3Q0FDbEJuSSxPQUFPb0wsSUFBSTVLLEtBQUs7b0NBQ3BCO29DQUVBLG9FQUFvRTtvQ0FDcEUsU0FBUztvQ0FDVHNGLFlBQVlJLE9BQU8sR0FBRzt3Q0FDbEIsSUFBSWtCLE1BQU1nRSxJQUFJNUssS0FBSyxHQUFHNEssSUFBSTVLLEtBQUssR0FBRzRLLElBQUl0RixXQUFXLENBQUN0RixLQUFLO3dDQUN2RFIsT0FBT29IO29DQUNYO2dDQUNKLEVBQUUsT0FBT2hNLEdBQUc7b0NBQ1I0RSxPQUFPNUU7Z0NBQ1g7NEJBQ0o7d0JBQ0osRUFBRSxDQUFDLFFBQVEsQ0FBQzRFO29CQUNoQjtvQkFFQXNFLGdCQUFnQmhGLFNBQVNpRjtvQkFDekIsT0FBT2pGO2dCQUNYO2dCQUVBLFNBQVN1TSxNQUFNdEgsUUFBUTtvQkFDbkIsSUFBSXJKLFFBQU8sSUFBSTtvQkFFZixJQUFJb0UsVUFBVSxJQUFJK0UsVUFBVSxTQUFVdEUsT0FBTyxFQUFFQyxNQUFNO3dCQUNqRDlFLE1BQUt5UCxLQUFLLEdBQUd2TCxJQUFJLENBQUM7NEJBQ2RnTCxrQkFBa0JsUCxNQUFLOE8sT0FBTyxFQUFFNUUsWUFBWSxTQUFVZ0MsR0FBRyxFQUFFdEIsV0FBVztnQ0FDbEUsSUFBSXNCLEtBQUs7b0NBQ0wsT0FBT3BILE9BQU9vSDtnQ0FDbEI7Z0NBRUEsSUFBSTtvQ0FDQSxJQUFJK0QsUUFBUXJGLFlBQVlFLFdBQVcsQ0FBQzlLLE1BQUs4TyxPQUFPLENBQUNqQyxTQUFTO29DQUMxRCxJQUFJcUQsTUFBTUQsTUFBTVUsS0FBSztvQ0FFckIvRixZQUFZTyxVQUFVLEdBQUc7d0NBQ3JCdEc7b0NBQ0o7b0NBRUErRixZQUFZSSxPQUFPLEdBQUdKLFlBQVlxQyxPQUFPLEdBQUc7d0NBQ3hDLElBQUlmLE1BQU1nRSxJQUFJNUssS0FBSyxHQUFHNEssSUFBSTVLLEtBQUssR0FBRzRLLElBQUl0RixXQUFXLENBQUN0RixLQUFLO3dDQUN2RFIsT0FBT29IO29DQUNYO2dDQUNKLEVBQUUsT0FBT2hNLEdBQUc7b0NBQ1I0RSxPQUFPNUU7Z0NBQ1g7NEJBQ0o7d0JBQ0osRUFBRSxDQUFDLFFBQVEsQ0FBQzRFO29CQUNoQjtvQkFFQXNFLGdCQUFnQmhGLFNBQVNpRjtvQkFDekIsT0FBT2pGO2dCQUNYO2dCQUVBLFNBQVNwRCxPQUFPcUksUUFBUTtvQkFDcEIsSUFBSXJKLFFBQU8sSUFBSTtvQkFFZixJQUFJb0UsVUFBVSxJQUFJK0UsVUFBVSxTQUFVdEUsT0FBTyxFQUFFQyxNQUFNO3dCQUNqRDlFLE1BQUt5UCxLQUFLLEdBQUd2TCxJQUFJLENBQUM7NEJBQ2RnTCxrQkFBa0JsUCxNQUFLOE8sT0FBTyxFQUFFN0UsV0FBVyxTQUFVaUMsR0FBRyxFQUFFdEIsV0FBVztnQ0FDakUsSUFBSXNCLEtBQUs7b0NBQ0wsT0FBT3BILE9BQU9vSDtnQ0FDbEI7Z0NBRUEsSUFBSTtvQ0FDQSxJQUFJK0QsUUFBUXJGLFlBQVlFLFdBQVcsQ0FBQzlLLE1BQUs4TyxPQUFPLENBQUNqQyxTQUFTO29DQUMxRCxJQUFJcUQsTUFBTUQsTUFBTVcsS0FBSztvQ0FFckJWLElBQUloRCxTQUFTLEdBQUc7d0NBQ1pySSxRQUFRcUwsSUFBSWpMLE1BQU07b0NBQ3RCO29DQUVBaUwsSUFBSWpELE9BQU8sR0FBRzt3Q0FDVm5JLE9BQU9vTCxJQUFJNUssS0FBSztvQ0FDcEI7Z0NBQ0osRUFBRSxPQUFPcEYsR0FBRztvQ0FDUjRFLE9BQU81RTtnQ0FDWDs0QkFDSjt3QkFDSixFQUFFLENBQUMsUUFBUSxDQUFDNEU7b0JBQ2hCO29CQUVBc0UsZ0JBQWdCaEYsU0FBU2lGO29CQUN6QixPQUFPakY7Z0JBQ1g7Z0JBRUEsU0FBU3FGLElBQUlySixDQUFDLEVBQUVpSixRQUFRO29CQUNwQixJQUFJckosUUFBTyxJQUFJO29CQUVmLElBQUlvRSxVQUFVLElBQUkrRSxVQUFVLFNBQVV0RSxPQUFPLEVBQUVDLE1BQU07d0JBQ2pELElBQUkxRSxJQUFJLEdBQUc7NEJBQ1B5RSxRQUFROzRCQUVSO3dCQUNKO3dCQUVBN0UsTUFBS3lQLEtBQUssR0FBR3ZMLElBQUksQ0FBQzs0QkFDZGdMLGtCQUFrQmxQLE1BQUs4TyxPQUFPLEVBQUU3RSxXQUFXLFNBQVVpQyxHQUFHLEVBQUV0QixXQUFXO2dDQUNqRSxJQUFJc0IsS0FBSztvQ0FDTCxPQUFPcEgsT0FBT29IO2dDQUNsQjtnQ0FFQSxJQUFJO29DQUNBLElBQUkrRCxRQUFRckYsWUFBWUUsV0FBVyxDQUFDOUssTUFBSzhPLE9BQU8sQ0FBQ2pDLFNBQVM7b0NBQzFELElBQUlnRSxXQUFXO29DQUNmLElBQUlYLE1BQU1ELE1BQU1hLGFBQWE7b0NBRTdCWixJQUFJaEQsU0FBUyxHQUFHO3dDQUNaLElBQUlxRCxTQUFTTCxJQUFJakwsTUFBTTt3Q0FDdkIsSUFBSSxDQUFDc0wsUUFBUTs0Q0FDVCx1Q0FBdUM7NENBQ3ZDMUwsUUFBUTs0Q0FFUjt3Q0FDSjt3Q0FFQSxJQUFJekUsTUFBTSxHQUFHOzRDQUNULHVEQUF1RDs0Q0FDdkQsVUFBVTs0Q0FDVnlFLFFBQVEwTCxPQUFPOUcsR0FBRzt3Q0FDdEIsT0FBTzs0Q0FDSCxJQUFJLENBQUNvSCxVQUFVO2dEQUNYLDRDQUE0QztnREFDNUMsV0FBVztnREFDWEEsV0FBVztnREFDWE4sT0FBT1EsT0FBTyxDQUFDM1E7NENBQ25CLE9BQU87Z0RBQ0gsMkNBQTJDO2dEQUMzQ3lFLFFBQVEwTCxPQUFPOUcsR0FBRzs0Q0FDdEI7d0NBQ0o7b0NBQ0o7b0NBRUF5RyxJQUFJakQsT0FBTyxHQUFHO3dDQUNWbkksT0FBT29MLElBQUk1SyxLQUFLO29DQUNwQjtnQ0FDSixFQUFFLE9BQU9wRixHQUFHO29DQUNSNEUsT0FBTzVFO2dDQUNYOzRCQUNKO3dCQUNKLEVBQUUsQ0FBQyxRQUFRLENBQUM0RTtvQkFDaEI7b0JBRUFzRSxnQkFBZ0JoRixTQUFTaUY7b0JBQ3pCLE9BQU9qRjtnQkFDWDtnQkFFQSxTQUFTNE0sS0FBSzNILFFBQVE7b0JBQ2xCLElBQUlySixRQUFPLElBQUk7b0JBRWYsSUFBSW9FLFVBQVUsSUFBSStFLFVBQVUsU0FBVXRFLE9BQU8sRUFBRUMsTUFBTTt3QkFDakQ5RSxNQUFLeVAsS0FBSyxHQUFHdkwsSUFBSSxDQUFDOzRCQUNkZ0wsa0JBQWtCbFAsTUFBSzhPLE9BQU8sRUFBRTdFLFdBQVcsU0FBVWlDLEdBQUcsRUFBRXRCLFdBQVc7Z0NBQ2pFLElBQUlzQixLQUFLO29DQUNMLE9BQU9wSCxPQUFPb0g7Z0NBQ2xCO2dDQUVBLElBQUk7b0NBQ0EsSUFBSStELFFBQVFyRixZQUFZRSxXQUFXLENBQUM5SyxNQUFLOE8sT0FBTyxDQUFDakMsU0FBUztvQ0FDMUQsSUFBSXFELE1BQU1ELE1BQU1hLGFBQWE7b0NBQzdCLElBQUlFLE9BQU8sRUFBRTtvQ0FFYmQsSUFBSWhELFNBQVMsR0FBRzt3Q0FDWixJQUFJcUQsU0FBU0wsSUFBSWpMLE1BQU07d0NBRXZCLElBQUksQ0FBQ3NMLFFBQVE7NENBQ1QxTCxRQUFRbU07NENBQ1I7d0NBQ0o7d0NBRUFBLEtBQUs1TixJQUFJLENBQUNtTixPQUFPOUcsR0FBRzt3Q0FDcEI4RyxNQUFNLENBQUMsV0FBVztvQ0FDdEI7b0NBRUFMLElBQUlqRCxPQUFPLEdBQUc7d0NBQ1ZuSSxPQUFPb0wsSUFBSTVLLEtBQUs7b0NBQ3BCO2dDQUNKLEVBQUUsT0FBT3BGLEdBQUc7b0NBQ1I0RSxPQUFPNUU7Z0NBQ1g7NEJBQ0o7d0JBQ0osRUFBRSxDQUFDLFFBQVEsQ0FBQzRFO29CQUNoQjtvQkFFQXNFLGdCQUFnQmhGLFNBQVNpRjtvQkFDekIsT0FBT2pGO2dCQUNYO2dCQUVBLFNBQVM2TSxhQUFhekIsT0FBTyxFQUFFbkcsUUFBUTtvQkFDbkNBLFdBQVdRLFlBQVlwRSxLQUFLLENBQUMsSUFBSSxFQUFFQztvQkFFbkMsSUFBSXdMLGdCQUFnQixJQUFJLENBQUNDLE1BQU07b0JBQy9CM0IsVUFBVSxPQUFPQSxZQUFZLGNBQWNBLFdBQVcsQ0FBQztvQkFDdkQsSUFBSSxDQUFDQSxRQUFRL0csSUFBSSxFQUFFO3dCQUNmK0csUUFBUS9HLElBQUksR0FBRytHLFFBQVEvRyxJQUFJLElBQUl5SSxjQUFjekksSUFBSTt3QkFDakQrRyxRQUFRM0MsU0FBUyxHQUFHMkMsUUFBUTNDLFNBQVMsSUFBSXFFLGNBQWNyRSxTQUFTO29CQUNwRTtvQkFFQSxJQUFJN00sUUFBTyxJQUFJO29CQUNmLElBQUlvRTtvQkFDSixJQUFJLENBQUNvTCxRQUFRL0csSUFBSSxFQUFFO3dCQUNmckUsVUFBVStFLFVBQVVyRSxNQUFNLENBQUM7b0JBQy9CLE9BQU87d0JBQ0gsSUFBSXNNLGNBQWM1QixRQUFRL0csSUFBSSxLQUFLeUksY0FBY3pJLElBQUksSUFBSXpJLE1BQUs4TyxPQUFPLENBQUN4QyxFQUFFO3dCQUV4RSxJQUFJK0UsWUFBWUQsY0FBY2pJLFVBQVV0RSxPQUFPLENBQUM3RSxNQUFLOE8sT0FBTyxDQUFDeEMsRUFBRSxJQUFJZSx1QkFBdUJtQyxTQUFTdEwsSUFBSSxDQUFDLFNBQVVvSSxFQUFFOzRCQUNoSCxJQUFJWCxZQUFZM0IsVUFBVSxDQUFDd0YsUUFBUS9HLElBQUksQ0FBQzs0QkFDeEMsSUFBSXVHLFVBQVVyRCxVQUFVcUQsT0FBTzs0QkFDL0JyRCxVQUFVVyxFQUFFLEdBQUdBOzRCQUNmLElBQUssSUFBSTNMLElBQUksR0FBR0EsSUFBSXFPLFFBQVFoTyxNQUFNLEVBQUVMLElBQUs7Z0NBQ3JDcU8sT0FBTyxDQUFDck8sRUFBRSxDQUFDbU8sT0FBTyxDQUFDeEMsRUFBRSxHQUFHQTs0QkFDNUI7NEJBQ0EsT0FBT0E7d0JBQ1g7d0JBRUEsSUFBSSxDQUFDa0QsUUFBUTNDLFNBQVMsRUFBRTs0QkFDcEJ6SSxVQUFVaU4sVUFBVW5OLElBQUksQ0FBQyxTQUFVb0ksRUFBRTtnQ0FDakNiLGdCQUFnQitEO2dDQUVoQixJQUFJN0QsWUFBWTNCLFVBQVUsQ0FBQ3dGLFFBQVEvRyxJQUFJLENBQUM7Z0NBQ3hDLElBQUl1RyxVQUFVckQsVUFBVXFELE9BQU87Z0NBRS9CMUMsR0FBR0MsS0FBSztnQ0FDUixJQUFLLElBQUk1TCxJQUFJLEdBQUdBLElBQUlxTyxRQUFRaE8sTUFBTSxFQUFFTCxJQUFLO29DQUNyQyxJQUFJc08sU0FBU0QsT0FBTyxDQUFDck8sRUFBRTtvQ0FDdkJzTyxPQUFPSCxPQUFPLENBQUN4QyxFQUFFLEdBQUc7Z0NBQ3hCO2dDQUVBLElBQUlnRixnQkFBZ0IsSUFBSW5JLFVBQVUsU0FBVXRFLE9BQU8sRUFBRUMsTUFBTTtvQ0FDdkQsSUFBSW9MLE1BQU0xSSxJQUFJK0osY0FBYyxDQUFDL0IsUUFBUS9HLElBQUk7b0NBRXpDeUgsSUFBSWpELE9BQU8sR0FBRzt3Q0FDVixJQUFJWCxLQUFLNEQsSUFBSWpMLE1BQU07d0NBQ25CLElBQUlxSCxJQUFJOzRDQUNKQSxHQUFHQyxLQUFLO3dDQUNaO3dDQUNBekgsT0FBT29MLElBQUk1SyxLQUFLO29DQUNwQjtvQ0FFQTRLLElBQUlzQixTQUFTLEdBQUc7d0NBQ1osZ0dBQWdHO3dDQUNoRyxrR0FBa0c7d0NBQ2xHOUgsUUFBUUMsSUFBSSxDQUFDLHdDQUF3QzZGLFFBQVEvRyxJQUFJLEdBQUc7b0NBQ3hFO29DQUVBeUgsSUFBSWhELFNBQVMsR0FBRzt3Q0FDWixJQUFJWixLQUFLNEQsSUFBSWpMLE1BQU07d0NBQ25CLElBQUlxSCxJQUFJOzRDQUNKQSxHQUFHQyxLQUFLO3dDQUNaO3dDQUNBMUgsUUFBUXlIO29DQUNaO2dDQUNKO2dDQUVBLE9BQU9nRixjQUFjcE4sSUFBSSxDQUFDLFNBQVVvSSxFQUFFO29DQUNsQ1gsVUFBVVcsRUFBRSxHQUFHQTtvQ0FDZixJQUFLLElBQUkzTCxJQUFJLEdBQUdBLElBQUlxTyxRQUFRaE8sTUFBTSxFQUFFTCxJQUFLO3dDQUNyQyxJQUFJOFEsVUFBVXpDLE9BQU8sQ0FBQ3JPLEVBQUU7d0NBQ3hCb0wsa0JBQWtCMEYsUUFBUTNDLE9BQU87b0NBQ3JDO2dDQUNKLEVBQUUsQ0FBQyxRQUFRLENBQUMsU0FBVTVDLEdBQUc7b0NBQ3BCRCxDQUFBQSxpQkFBaUJ1RCxTQUFTdEQsUUFBUS9DLFVBQVV0RSxPQUFPLEVBQUMsQ0FBRSxDQUFDLFFBQVEsQ0FBQyxZQUFhO29DQUM5RSxNQUFNcUg7Z0NBQ1Y7NEJBQ0o7d0JBQ0osT0FBTzs0QkFDSDlILFVBQVVpTixVQUFVbk4sSUFBSSxDQUFDLFNBQVVvSSxFQUFFO2dDQUNqQyxJQUFJLENBQUNBLEdBQUdvQixnQkFBZ0IsQ0FBQ0MsUUFBUSxDQUFDNkIsUUFBUTNDLFNBQVMsR0FBRztvQ0FDbEQ7Z0NBQ0o7Z0NBRUEsSUFBSUcsYUFBYVYsR0FBR0csT0FBTyxHQUFHO2dDQUU5QmhCLGdCQUFnQitEO2dDQUVoQixJQUFJN0QsWUFBWTNCLFVBQVUsQ0FBQ3dGLFFBQVEvRyxJQUFJLENBQUM7Z0NBQ3hDLElBQUl1RyxVQUFVckQsVUFBVXFELE9BQU87Z0NBRS9CMUMsR0FBR0MsS0FBSztnQ0FDUixJQUFLLElBQUk1TCxJQUFJLEdBQUdBLElBQUlxTyxRQUFRaE8sTUFBTSxFQUFFTCxJQUFLO29DQUNyQyxJQUFJc08sU0FBU0QsT0FBTyxDQUFDck8sRUFBRTtvQ0FDdkJzTyxPQUFPSCxPQUFPLENBQUN4QyxFQUFFLEdBQUc7b0NBQ3BCMkMsT0FBT0gsT0FBTyxDQUFDckMsT0FBTyxHQUFHTztnQ0FDN0I7Z0NBRUEsSUFBSTBFLG9CQUFvQixJQUFJdkksVUFBVSxTQUFVdEUsT0FBTyxFQUFFQyxNQUFNO29DQUMzRCxJQUFJb0wsTUFBTTFJLElBQUlFLElBQUksQ0FBQzhILFFBQVEvRyxJQUFJLEVBQUV1RTtvQ0FFakNrRCxJQUFJakQsT0FBTyxHQUFHLFNBQVVmLEdBQUc7d0NBQ3ZCLElBQUlJLEtBQUs0RCxJQUFJakwsTUFBTTt3Q0FDbkJxSCxHQUFHQyxLQUFLO3dDQUNSekgsT0FBT29IO29DQUNYO29DQUVBZ0UsSUFBSXZELGVBQWUsR0FBRzt3Q0FDbEIsSUFBSUwsS0FBSzRELElBQUlqTCxNQUFNO3dDQUNuQnFILEdBQUdxRixpQkFBaUIsQ0FBQ25DLFFBQVEzQyxTQUFTO29DQUMxQztvQ0FFQXFELElBQUloRCxTQUFTLEdBQUc7d0NBQ1osSUFBSVosS0FBSzRELElBQUlqTCxNQUFNO3dDQUNuQnFILEdBQUdDLEtBQUs7d0NBQ1IxSCxRQUFReUg7b0NBQ1o7Z0NBQ0o7Z0NBRUEsT0FBT29GLGtCQUFrQnhOLElBQUksQ0FBQyxTQUFVb0ksRUFBRTtvQ0FDdENYLFVBQVVXLEVBQUUsR0FBR0E7b0NBQ2YsSUFBSyxJQUFJc0QsSUFBSSxHQUFHQSxJQUFJWixRQUFRaE8sTUFBTSxFQUFFNE8sSUFBSzt3Q0FDckMsSUFBSWdDLFdBQVc1QyxPQUFPLENBQUNZLEVBQUU7d0NBQ3pCZ0MsU0FBUzlDLE9BQU8sQ0FBQ3hDLEVBQUUsR0FBR0E7d0NBQ3RCUCxrQkFBa0I2RixTQUFTOUMsT0FBTztvQ0FDdEM7Z0NBQ0osRUFBRSxDQUFDLFFBQVEsQ0FBQyxTQUFVNUMsR0FBRztvQ0FDcEJELENBQUFBLGlCQUFpQnVELFNBQVN0RCxRQUFRL0MsVUFBVXRFLE9BQU8sRUFBQyxDQUFFLENBQUMsUUFBUSxDQUFDLFlBQWE7b0NBQzlFLE1BQU1xSDtnQ0FDVjs0QkFDSjt3QkFDSjtvQkFDSjtvQkFFQTlDLGdCQUFnQmhGLFNBQVNpRjtvQkFDekIsT0FBT2pGO2dCQUNYO2dCQUVBLElBQUl5TixlQUFlO29CQUNmQyxTQUFTO29CQUNUdkMsY0FBY0E7b0JBQ2R3QyxVQUFVdEs7b0JBQ1YySSxTQUFTQTtvQkFDVEosU0FBU0E7b0JBQ1RRLFNBQVNBO29CQUNURSxZQUFZQTtvQkFDWkMsT0FBT0E7b0JBQ1AzUCxRQUFRQTtvQkFDUnlJLEtBQUtBO29CQUNMdUgsTUFBTUE7b0JBQ05DLGNBQWNBO2dCQUNsQjtnQkFFQSxTQUFTZTtvQkFDTCxPQUFPLE9BQU9wSyxpQkFBaUI7Z0JBQ25DO2dCQUVBLGdGQUFnRjtnQkFDaEYsb0ZBQW9GO2dCQUNwRixrREFBa0Q7Z0JBQ2xELElBQUlxSyxhQUFhO2dCQUVqQixJQUFJQyxtQkFBbUI7Z0JBQ3ZCLElBQUlDLHlCQUF5QjtnQkFFN0IsSUFBSUMsb0JBQW9CO2dCQUN4QixJQUFJQywyQkFBMkJELGtCQUFrQnBSLE1BQU07Z0JBRXZELDBCQUEwQjtnQkFDMUIsSUFBSXNSLG1CQUFtQjtnQkFDdkIsSUFBSUMsWUFBWTtnQkFDaEIsSUFBSUMsaUJBQWlCO2dCQUNyQixJQUFJQyxrQkFBa0I7Z0JBQ3RCLElBQUlDLHlCQUF5QjtnQkFDN0IsSUFBSUMsa0JBQWtCO2dCQUN0QixJQUFJQyxrQkFBa0I7Z0JBQ3RCLElBQUlDLG1CQUFtQjtnQkFDdkIsSUFBSUMsbUJBQW1CO2dCQUN2QixJQUFJQyxvQkFBb0I7Z0JBQ3hCLElBQUlDLG9CQUFvQjtnQkFDeEIsSUFBSUMsZ0NBQWdDWiwyQkFBMkJDLGlCQUFpQnRSLE1BQU07Z0JBRXRGLElBQUlrUyxhQUFhaE4sT0FBT2xDLFNBQVMsQ0FBQ21DLFFBQVE7Z0JBRTFDLFNBQVNnTixlQUFlQyxnQkFBZ0I7b0JBQ3BDLHNDQUFzQztvQkFDdEMsSUFBSUMsZUFBZUQsaUJBQWlCcFMsTUFBTSxHQUFHO29CQUM3QyxJQUFJaUMsTUFBTW1RLGlCQUFpQnBTLE1BQU07b0JBQ2pDLElBQUlMO29CQUNKLElBQUkyUyxJQUFJO29CQUNSLElBQUlDLFVBQVVDLFVBQVVDLFVBQVVDO29CQUVsQyxJQUFJTixnQkFBZ0IsQ0FBQ0EsaUJBQWlCcFMsTUFBTSxHQUFHLEVBQUUsS0FBSyxLQUFLO3dCQUN2RHFTO3dCQUNBLElBQUlELGdCQUFnQixDQUFDQSxpQkFBaUJwUyxNQUFNLEdBQUcsRUFBRSxLQUFLLEtBQUs7NEJBQ3ZEcVM7d0JBQ0o7b0JBQ0o7b0JBRUEsSUFBSU0sU0FBUyxJQUFJckosWUFBWStJO29CQUM3QixJQUFJTyxRQUFRLElBQUlwSixXQUFXbUo7b0JBRTNCLElBQUtoVCxJQUFJLEdBQUdBLElBQUlzQyxLQUFLdEMsS0FBSyxFQUFHO3dCQUN6QjRTLFdBQVd0QixXQUFXOUosT0FBTyxDQUFDaUwsZ0JBQWdCLENBQUN6UyxFQUFFO3dCQUNqRDZTLFdBQVd2QixXQUFXOUosT0FBTyxDQUFDaUwsZ0JBQWdCLENBQUN6UyxJQUFJLEVBQUU7d0JBQ3JEOFMsV0FBV3hCLFdBQVc5SixPQUFPLENBQUNpTCxnQkFBZ0IsQ0FBQ3pTLElBQUksRUFBRTt3QkFDckQrUyxXQUFXekIsV0FBVzlKLE9BQU8sQ0FBQ2lMLGdCQUFnQixDQUFDelMsSUFBSSxFQUFFO3dCQUVyRCx1QkFBdUIsR0FDdkJpVCxLQUFLLENBQUNOLElBQUksR0FBR0MsWUFBWSxJQUFJQyxZQUFZO3dCQUN6Q0ksS0FBSyxDQUFDTixJQUFJLEdBQUcsQ0FBQ0UsV0FBVyxFQUFDLEtBQU0sSUFBSUMsWUFBWTt3QkFDaERHLEtBQUssQ0FBQ04sSUFBSSxHQUFHLENBQUNHLFdBQVcsTUFBTSxJQUFJQyxXQUFXO29CQUNsRDtvQkFDQSxPQUFPQztnQkFDWDtnQkFFQSxxRUFBcUU7Z0JBQ3JFLG1CQUFtQjtnQkFDbkIsU0FBU0UsZUFBZUYsTUFBTTtvQkFDMUIscUJBQXFCO29CQUNyQixJQUFJQyxRQUFRLElBQUlwSixXQUFXbUo7b0JBQzNCLElBQUlHLGVBQWU7b0JBQ25CLElBQUluVDtvQkFFSixJQUFLQSxJQUFJLEdBQUdBLElBQUlpVCxNQUFNNVMsTUFBTSxFQUFFTCxLQUFLLEVBQUc7d0JBQ2xDLHVCQUF1QixHQUN2Qm1ULGdCQUFnQjdCLFVBQVUsQ0FBQzJCLEtBQUssQ0FBQ2pULEVBQUUsSUFBSSxFQUFFO3dCQUN6Q21ULGdCQUFnQjdCLFVBQVUsQ0FBQyxDQUFDMkIsS0FBSyxDQUFDalQsRUFBRSxHQUFHLE1BQU0sSUFBSWlULEtBQUssQ0FBQ2pULElBQUksRUFBRSxJQUFJLEVBQUU7d0JBQ25FbVQsZ0JBQWdCN0IsVUFBVSxDQUFDLENBQUMyQixLQUFLLENBQUNqVCxJQUFJLEVBQUUsR0FBRyxFQUFDLEtBQU0sSUFBSWlULEtBQUssQ0FBQ2pULElBQUksRUFBRSxJQUFJLEVBQUU7d0JBQ3hFbVQsZ0JBQWdCN0IsVUFBVSxDQUFDMkIsS0FBSyxDQUFDalQsSUFBSSxFQUFFLEdBQUcsR0FBRztvQkFDakQ7b0JBRUEsSUFBSWlULE1BQU01UyxNQUFNLEdBQUcsTUFBTSxHQUFHO3dCQUN4QjhTLGVBQWVBLGFBQWFDLFNBQVMsQ0FBQyxHQUFHRCxhQUFhOVMsTUFBTSxHQUFHLEtBQUs7b0JBQ3hFLE9BQU8sSUFBSTRTLE1BQU01UyxNQUFNLEdBQUcsTUFBTSxHQUFHO3dCQUMvQjhTLGVBQWVBLGFBQWFDLFNBQVMsQ0FBQyxHQUFHRCxhQUFhOVMsTUFBTSxHQUFHLEtBQUs7b0JBQ3hFO29CQUVBLE9BQU84UztnQkFDWDtnQkFFQSxvRUFBb0U7Z0JBQ3BFLDBFQUEwRTtnQkFDMUUsMENBQTBDO2dCQUMxQyxTQUFTRSxVQUFVcFAsS0FBSyxFQUFFeUUsUUFBUTtvQkFDOUIsSUFBSTRLLFlBQVk7b0JBQ2hCLElBQUlyUCxPQUFPO3dCQUNQcVAsWUFBWWYsV0FBV25TLElBQUksQ0FBQzZEO29CQUNoQztvQkFFQSxtRUFBbUU7b0JBQ25FLHdEQUF3RDtvQkFDeEQsRUFBRTtvQkFDRiw0REFBNEQ7b0JBQzVELElBQUlBLFNBQVVxUCxDQUFBQSxjQUFjLDBCQUEwQnJQLE1BQU0rTyxNQUFNLElBQUlULFdBQVduUyxJQUFJLENBQUM2RCxNQUFNK08sTUFBTSxNQUFNLHNCQUFxQixHQUFJO3dCQUM3SCwrREFBK0Q7d0JBQy9ELG9CQUFvQjt3QkFDcEIsSUFBSUE7d0JBQ0osSUFBSU8sU0FBUzlCO3dCQUViLElBQUl4TixpQkFBaUIwRixhQUFhOzRCQUM5QnFKLFNBQVMvTzs0QkFDVHNQLFVBQVU1Qjt3QkFDZCxPQUFPOzRCQUNIcUIsU0FBUy9PLE1BQU0rTyxNQUFNOzRCQUVyQixJQUFJTSxjQUFjLHNCQUFzQjtnQ0FDcENDLFVBQVUxQjs0QkFDZCxPQUFPLElBQUl5QixjQUFjLHVCQUF1QjtnQ0FDNUNDLFVBQVV6Qjs0QkFDZCxPQUFPLElBQUl3QixjQUFjLDhCQUE4QjtnQ0FDbkRDLFVBQVV4Qjs0QkFDZCxPQUFPLElBQUl1QixjQUFjLHVCQUF1QjtnQ0FDNUNDLFVBQVV2Qjs0QkFDZCxPQUFPLElBQUlzQixjQUFjLHdCQUF3QjtnQ0FDN0NDLFVBQVVyQjs0QkFDZCxPQUFPLElBQUlvQixjQUFjLHVCQUF1QjtnQ0FDNUNDLFVBQVV0Qjs0QkFDZCxPQUFPLElBQUlxQixjQUFjLHdCQUF3QjtnQ0FDN0NDLFVBQVVwQjs0QkFDZCxPQUFPLElBQUltQixjQUFjLHlCQUF5QjtnQ0FDOUNDLFVBQVVuQjs0QkFDZCxPQUFPLElBQUlrQixjQUFjLHlCQUF5QjtnQ0FDOUNDLFVBQVVsQjs0QkFDZCxPQUFPO2dDQUNIM0osU0FBUyxJQUFJekksTUFBTTs0QkFDdkI7d0JBQ0o7d0JBRUF5SSxTQUFTNkssU0FBU0wsZUFBZUY7b0JBQ3JDLE9BQU8sSUFBSU0sY0FBYyxpQkFBaUI7d0JBQ3RDLHlEQUF5RDt3QkFDekQsSUFBSUUsYUFBYSxJQUFJbEc7d0JBRXJCa0csV0FBV0MsTUFBTSxHQUFHOzRCQUNoQixpREFBaUQ7NEJBQ2pELElBQUlDLE1BQU1uQyxtQkFBbUJ0TixNQUFNc0UsSUFBSSxHQUFHLE1BQU0ySyxlQUFlLElBQUksQ0FBQzVPLE1BQU07NEJBRTFFb0UsU0FBUytJLG9CQUFvQkcsWUFBWThCO3dCQUM3Qzt3QkFFQUYsV0FBV0csaUJBQWlCLENBQUMxUDtvQkFDakMsT0FBTzt3QkFDSCxJQUFJOzRCQUNBeUUsU0FBU2tMLEtBQUtDLFNBQVMsQ0FBQzVQO3dCQUM1QixFQUFFLE9BQU8xRSxHQUFHOzRCQUNSd0osUUFBUXBFLEtBQUssQ0FBQywrQ0FBK0NWOzRCQUU3RHlFLFNBQVMsTUFBTW5KO3dCQUNuQjtvQkFDSjtnQkFDSjtnQkFFQSxzRUFBc0U7Z0JBQ3RFLHVFQUF1RTtnQkFDdkUseUVBQXlFO2dCQUN6RSx1Q0FBdUM7Z0JBQ3ZDLEVBQUU7Z0JBQ0YsdUVBQXVFO2dCQUN2RSxxRUFBcUU7Z0JBQ3JFLHNFQUFzRTtnQkFDdEUsU0FBU3VVLFlBQVk3UCxLQUFLO29CQUN0Qix1RUFBdUU7b0JBQ3ZFLHNFQUFzRTtvQkFDdEUsZ0JBQWdCO29CQUNoQixJQUFJQSxNQUFNbVAsU0FBUyxDQUFDLEdBQUcxQiw4QkFBOEJELG1CQUFtQjt3QkFDcEUsT0FBT21DLEtBQUtHLEtBQUssQ0FBQzlQO29CQUN0QjtvQkFFQSxtRUFBbUU7b0JBQ25FLG1FQUFtRTtvQkFDbkUsNkJBQTZCO29CQUM3QixJQUFJd08sbUJBQW1CeE8sTUFBTW1QLFNBQVMsQ0FBQ2Q7b0JBQ3ZDLElBQUkvSixPQUFPdEUsTUFBTW1QLFNBQVMsQ0FBQzFCLDBCQUEwQlk7b0JBRXJELElBQUkwQjtvQkFDSix5REFBeUQ7b0JBQ3pELHFGQUFxRjtvQkFDckYsSUFBSXpMLFNBQVNxSixhQUFhSix1QkFBdUJ0SyxJQUFJLENBQUN1TCxtQkFBbUI7d0JBQ3JFLElBQUl3QixVQUFVeEIsaUJBQWlCL0gsS0FBSyxDQUFDOEc7d0JBQ3JDd0MsV0FBV0MsT0FBTyxDQUFDLEVBQUU7d0JBQ3JCeEIsbUJBQW1CQSxpQkFBaUJXLFNBQVMsQ0FBQ2EsT0FBTyxDQUFDLEVBQUUsQ0FBQzVULE1BQU07b0JBQ25FO29CQUNBLElBQUkyUyxTQUFTUixlQUFlQztvQkFFNUIsMERBQTBEO29CQUMxRCxpQkFBaUI7b0JBQ2pCLE9BQVFsSzt3QkFDSixLQUFLb0o7NEJBQ0QsT0FBT3FCO3dCQUNYLEtBQUtwQjs0QkFDRCxPQUFPbEssV0FBVztnQ0FBQ3NMOzZCQUFPLEVBQUU7Z0NBQUV6SyxNQUFNeUw7NEJBQVM7d0JBQ2pELEtBQUtuQzs0QkFDRCxPQUFPLElBQUlxQyxVQUFVbEI7d0JBQ3pCLEtBQUtsQjs0QkFDRCxPQUFPLElBQUlqSSxXQUFXbUo7d0JBQzFCLEtBQUtqQjs0QkFDRCxPQUFPLElBQUlvQyxrQkFBa0JuQjt3QkFDakMsS0FBS2hCOzRCQUNELE9BQU8sSUFBSW9DLFdBQVdwQjt3QkFDMUIsS0FBS2Q7NEJBQ0QsT0FBTyxJQUFJbUMsWUFBWXJCO3dCQUMzQixLQUFLZjs0QkFDRCxPQUFPLElBQUlxQyxXQUFXdEI7d0JBQzFCLEtBQUtiOzRCQUNELE9BQU8sSUFBSW9DLFlBQVl2Qjt3QkFDM0IsS0FBS1o7NEJBQ0QsT0FBTyxJQUFJb0MsYUFBYXhCO3dCQUM1QixLQUFLWDs0QkFDRCxPQUFPLElBQUlvQyxhQUFhekI7d0JBQzVCOzRCQUNJLE1BQU0sSUFBSS9TLE1BQU0sa0JBQWtCc0k7b0JBQzFDO2dCQUNKO2dCQUVBLElBQUltTSx3QkFBd0I7b0JBQ3hCckIsV0FBV0E7b0JBQ1hTLGFBQWFBO29CQUNidEIsZ0JBQWdCQTtvQkFDaEJVLGdCQUFnQkE7Z0JBQ3BCO2dCQUVBOzs7Ozs7OztDQVFDLEdBRUQsU0FBU3lCLGNBQWNuVixDQUFDLEVBQUV1TCxNQUFNLEVBQUVyQyxRQUFRLEVBQUVFLGFBQWE7b0JBQ3JEcEosRUFBRW9WLFVBQVUsQ0FBQyxnQ0FBZ0M3SixPQUFPbUIsU0FBUyxHQUFHLE1BQU0sK0NBQStDLEVBQUUsRUFBRXhELFVBQVVFO2dCQUN2STtnQkFFQSxvRUFBb0U7Z0JBQ3BFLDBEQUEwRDtnQkFDMUQsU0FBU2lNLGVBQWVoRyxPQUFPO29CQUMzQixJQUFJeFAsUUFBTyxJQUFJO29CQUNmLElBQUkwTCxTQUFTO3dCQUNUWSxJQUFJO29CQUNSO29CQUVBLElBQUlrRCxTQUFTO3dCQUNULElBQUssSUFBSTdPLEtBQUs2TyxRQUFTOzRCQUNuQjlELE1BQU0sQ0FBQy9LLEVBQUUsR0FBRyxPQUFPNk8sT0FBTyxDQUFDN08sRUFBRSxLQUFLLFdBQVc2TyxPQUFPLENBQUM3TyxFQUFFLENBQUN3RixRQUFRLEtBQUtxSixPQUFPLENBQUM3TyxFQUFFO3dCQUNuRjtvQkFDSjtvQkFFQSxJQUFJOFUsZ0JBQWdCLElBQUl0TSxVQUFVLFNBQVV0RSxPQUFPLEVBQUVDLE1BQU07d0JBQ3ZELDZEQUE2RDt3QkFDN0Qsd0NBQXdDO3dCQUN4QyxJQUFJOzRCQUNBNEcsT0FBT1ksRUFBRSxHQUFHMUUsYUFBYThELE9BQU9qRCxJQUFJLEVBQUVtQixPQUFPOEIsT0FBT2UsT0FBTyxHQUFHZixPQUFPZ0ssV0FBVyxFQUFFaEssT0FBT2lLLElBQUk7d0JBQ2pHLEVBQUUsT0FBT3pWLEdBQUc7NEJBQ1IsT0FBTzRFLE9BQU81RTt3QkFDbEI7d0JBRUEsa0RBQWtEO3dCQUNsRHdMLE9BQU9ZLEVBQUUsQ0FBQzFCLFdBQVcsQ0FBQyxTQUFVekssQ0FBQzs0QkFDN0JtVixjQUFjblYsR0FBR3VMLFFBQVE7Z0NBQ3JCMUwsTUFBSzhPLE9BQU8sR0FBR3BEO2dDQUNmN0c7NEJBQ0osR0FBRyxTQUFVMUUsQ0FBQyxFQUFFbUYsS0FBSztnQ0FDakJSLE9BQU9ROzRCQUNYO3dCQUNKLEdBQUdSO29CQUNQO29CQUVBNEcsT0FBT2tLLFVBQVUsR0FBR1A7b0JBQ3BCLE9BQU9JO2dCQUNYO2dCQUVBLFNBQVNJLGNBQWMxVixDQUFDLEVBQUV1TCxNQUFNLEVBQUVvSyxZQUFZLEVBQUVDLElBQUksRUFBRTFNLFFBQVEsRUFBRUUsYUFBYTtvQkFDekVwSixFQUFFb1YsVUFBVSxDQUFDTyxjQUFjQyxNQUFNMU0sVUFBVSxTQUFVbEosQ0FBQyxFQUFFbUYsS0FBSzt3QkFDekQsSUFBSUEsTUFBTXpFLElBQUksS0FBS3lFLE1BQU0wUSxVQUFVLEVBQUU7NEJBQ2pDN1YsRUFBRW9WLFVBQVUsQ0FBQyxvQ0FBb0MsbUNBQW1DO2dDQUFDN0osT0FBT21CLFNBQVM7NkJBQUMsRUFBRSxTQUFVMU0sQ0FBQyxFQUFFOFYsT0FBTztnQ0FDeEgsSUFBSSxDQUFDQSxRQUFRQyxJQUFJLENBQUNsVixNQUFNLEVBQUU7b0NBQ3RCLHdDQUF3QztvQ0FDeEMsK0JBQStCO29DQUMvQnNVLGNBQWNuVixHQUFHdUwsUUFBUTt3Q0FDckJ2TCxFQUFFb1YsVUFBVSxDQUFDTyxjQUFjQyxNQUFNMU0sVUFBVUU7b0NBQy9DLEdBQUdBO2dDQUNQLE9BQU87b0NBQ0hBLGNBQWNwSixHQUFHbUY7Z0NBQ3JCOzRCQUNKLEdBQUdpRTt3QkFDUCxPQUFPOzRCQUNIQSxjQUFjcEosR0FBR21GO3dCQUNyQjtvQkFDSixHQUFHaUU7Z0JBQ1A7Z0JBRUEsU0FBUzRNLFVBQVUxTSxHQUFHLEVBQUVKLFFBQVE7b0JBQzVCLElBQUlySixRQUFPLElBQUk7b0JBRWZ5SixNQUFNRCxhQUFhQztvQkFFbkIsSUFBSXJGLFVBQVUsSUFBSStFLFVBQVUsU0FBVXRFLE9BQU8sRUFBRUMsTUFBTTt3QkFDakQ5RSxNQUFLeVAsS0FBSyxHQUFHdkwsSUFBSSxDQUFDOzRCQUNkLElBQUl3SCxTQUFTMUwsTUFBSzhPLE9BQU87NEJBQ3pCcEQsT0FBT1ksRUFBRSxDQUFDMUIsV0FBVyxDQUFDLFNBQVV6SyxDQUFDO2dDQUM3QjBWLGNBQWMxVixHQUFHdUwsUUFBUSxtQkFBbUJBLE9BQU9tQixTQUFTLEdBQUcsMEJBQTBCO29DQUFDcEQ7aUNBQUksRUFBRSxTQUFVdEosQ0FBQyxFQUFFOFYsT0FBTztvQ0FDaEgsSUFBSWhSLFNBQVNnUixRQUFRQyxJQUFJLENBQUNsVixNQUFNLEdBQUdpVixRQUFRQyxJQUFJLENBQUNFLElBQUksQ0FBQyxHQUFHeFIsS0FBSyxHQUFHO29DQUVoRSx3REFBd0Q7b0NBQ3hELFVBQVU7b0NBQ1YsSUFBSUssUUFBUTt3Q0FDUkEsU0FBU3lHLE9BQU9rSyxVQUFVLENBQUNuQixXQUFXLENBQUN4UDtvQ0FDM0M7b0NBRUFKLFFBQVFJO2dDQUNaLEdBQUcsU0FBVTlFLENBQUMsRUFBRW1GLEtBQUs7b0NBQ2pCUixPQUFPUTtnQ0FDWDs0QkFDSjt3QkFDSixFQUFFLENBQUMsUUFBUSxDQUFDUjtvQkFDaEI7b0JBRUFzRSxnQkFBZ0JoRixTQUFTaUY7b0JBQ3pCLE9BQU9qRjtnQkFDWDtnQkFFQSxTQUFTaVMsVUFBVXZQLFFBQVEsRUFBRXVDLFFBQVE7b0JBQ2pDLElBQUlySixRQUFPLElBQUk7b0JBRWYsSUFBSW9FLFVBQVUsSUFBSStFLFVBQVUsU0FBVXRFLE9BQU8sRUFBRUMsTUFBTTt3QkFDakQ5RSxNQUFLeVAsS0FBSyxHQUFHdkwsSUFBSSxDQUFDOzRCQUNkLElBQUl3SCxTQUFTMUwsTUFBSzhPLE9BQU87NEJBRXpCcEQsT0FBT1ksRUFBRSxDQUFDMUIsV0FBVyxDQUFDLFNBQVV6SyxDQUFDO2dDQUM3QjBWLGNBQWMxVixHQUFHdUwsUUFBUSxtQkFBbUJBLE9BQU9tQixTQUFTLEVBQUUsRUFBRSxFQUFFLFNBQVUxTSxDQUFDLEVBQUU4VixPQUFPO29DQUNsRixJQUFJQyxPQUFPRCxRQUFRQyxJQUFJO29DQUN2QixJQUFJbFYsU0FBU2tWLEtBQUtsVixNQUFNO29DQUV4QixJQUFLLElBQUlMLElBQUksR0FBR0EsSUFBSUssUUFBUUwsSUFBSzt3Q0FDN0IsSUFBSXlWLE9BQU9GLEtBQUtFLElBQUksQ0FBQ3pWO3dDQUNyQixJQUFJc0UsU0FBU21SLEtBQUt4UixLQUFLO3dDQUV2Qiw2Q0FBNkM7d0NBQzdDLHFCQUFxQjt3Q0FDckIsSUFBSUssUUFBUTs0Q0FDUkEsU0FBU3lHLE9BQU9rSyxVQUFVLENBQUNuQixXQUFXLENBQUN4UDt3Q0FDM0M7d0NBRUFBLFNBQVM2QixTQUFTN0IsUUFBUW1SLEtBQUszTSxHQUFHLEVBQUU5SSxJQUFJO3dDQUV4Qyw4Q0FBOEM7d0NBQzlDLGtCQUFrQjt3Q0FDbEIsSUFBSXNFLFdBQVcsS0FBSyxHQUFHOzRDQUNuQkosUUFBUUk7NENBQ1I7d0NBQ0o7b0NBQ0o7b0NBRUFKO2dDQUNKLEdBQUcsU0FBVTFFLENBQUMsRUFBRW1GLEtBQUs7b0NBQ2pCUixPQUFPUTtnQ0FDWDs0QkFDSjt3QkFDSixFQUFFLENBQUMsUUFBUSxDQUFDUjtvQkFDaEI7b0JBRUFzRSxnQkFBZ0JoRixTQUFTaUY7b0JBQ3pCLE9BQU9qRjtnQkFDWDtnQkFFQSxTQUFTa1MsU0FBUzdNLEdBQUcsRUFBRTdFLEtBQUssRUFBRXlFLFFBQVEsRUFBRWtOLFdBQVc7b0JBQy9DLElBQUl2VyxRQUFPLElBQUk7b0JBRWZ5SixNQUFNRCxhQUFhQztvQkFFbkIsSUFBSXJGLFVBQVUsSUFBSStFLFVBQVUsU0FBVXRFLE9BQU8sRUFBRUMsTUFBTTt3QkFDakQ5RSxNQUFLeVAsS0FBSyxHQUFHdkwsSUFBSSxDQUFDOzRCQUNkLDZEQUE2RDs0QkFDN0QsNkRBQTZEOzRCQUM3RCwrREFBK0Q7NEJBQy9ELElBQUlVLFVBQVV5SyxXQUFXO2dDQUNyQnpLLFFBQVE7NEJBQ1o7NEJBRUEsbURBQW1EOzRCQUNuRCxJQUFJNFIsZ0JBQWdCNVI7NEJBRXBCLElBQUk4RyxTQUFTMUwsTUFBSzhPLE9BQU87NEJBQ3pCcEQsT0FBT2tLLFVBQVUsQ0FBQzVCLFNBQVMsQ0FBQ3BQLE9BQU8sU0FBVUEsS0FBSyxFQUFFVSxLQUFLO2dDQUNyRCxJQUFJQSxPQUFPO29DQUNQUixPQUFPUTtnQ0FDWCxPQUFPO29DQUNIb0csT0FBT1ksRUFBRSxDQUFDMUIsV0FBVyxDQUFDLFNBQVV6SyxDQUFDO3dDQUM3QjBWLGNBQWMxVixHQUFHdUwsUUFBUSw0QkFBNEJBLE9BQU9tQixTQUFTLEdBQUcsTUFBTSw4QkFBOEI7NENBQUNwRDs0Q0FBSzdFO3lDQUFNLEVBQUU7NENBQ3RIQyxRQUFRMlI7d0NBQ1osR0FBRyxTQUFVclcsQ0FBQyxFQUFFbUYsS0FBSzs0Q0FDakJSLE9BQU9RO3dDQUNYO29DQUNKLEdBQUcsU0FBVW1SLFFBQVE7d0NBQ2pCLGdDQUFnQzt3Q0FDaEMsZ0NBQWdDO3dDQUNoQyxJQUFJQSxTQUFTNVYsSUFBSSxLQUFLNFYsU0FBU0MsU0FBUyxFQUFFOzRDQUN0QywrQ0FBK0M7NENBQy9DLCtDQUErQzs0Q0FDL0MsNkNBQTZDOzRDQUM3QywwQ0FBMEM7NENBQzFDLGFBQWE7NENBQ2IsRUFBRTs0Q0FDRixpQ0FBaUM7NENBQ2pDLElBQUlILGNBQWMsR0FBRztnREFDakIxUixRQUFReVIsU0FBUzdRLEtBQUssQ0FBQ3pGLE9BQU07b0RBQUN5SjtvREFBSytNO29EQUFlbk47b0RBQVVrTixjQUFjO2lEQUFFO2dEQUM1RTs0Q0FDSjs0Q0FDQXpSLE9BQU8yUjt3Q0FDWDtvQ0FDSjtnQ0FDSjs0QkFDSjt3QkFDSixFQUFFLENBQUMsUUFBUSxDQUFDM1I7b0JBQ2hCO29CQUVBc0UsZ0JBQWdCaEYsU0FBU2lGO29CQUN6QixPQUFPakY7Z0JBQ1g7Z0JBRUEsU0FBU3VTLFVBQVVsTixHQUFHLEVBQUU3RSxLQUFLLEVBQUV5RSxRQUFRO29CQUNuQyxPQUFPaU4sU0FBUzdRLEtBQUssQ0FBQyxJQUFJLEVBQUU7d0JBQUNnRTt3QkFBSzdFO3dCQUFPeUU7d0JBQVU7cUJBQUU7Z0JBQ3pEO2dCQUVBLFNBQVN1TixhQUFhbk4sR0FBRyxFQUFFSixRQUFRO29CQUMvQixJQUFJckosUUFBTyxJQUFJO29CQUVmeUosTUFBTUQsYUFBYUM7b0JBRW5CLElBQUlyRixVQUFVLElBQUkrRSxVQUFVLFNBQVV0RSxPQUFPLEVBQUVDLE1BQU07d0JBQ2pEOUUsTUFBS3lQLEtBQUssR0FBR3ZMLElBQUksQ0FBQzs0QkFDZCxJQUFJd0gsU0FBUzFMLE1BQUs4TyxPQUFPOzRCQUN6QnBELE9BQU9ZLEVBQUUsQ0FBQzFCLFdBQVcsQ0FBQyxTQUFVekssQ0FBQztnQ0FDN0IwVixjQUFjMVYsR0FBR3VMLFFBQVEsaUJBQWlCQSxPQUFPbUIsU0FBUyxHQUFHLGtCQUFrQjtvQ0FBQ3BEO2lDQUFJLEVBQUU7b0NBQ2xGNUU7Z0NBQ0osR0FBRyxTQUFVMUUsQ0FBQyxFQUFFbUYsS0FBSztvQ0FDakJSLE9BQU9RO2dDQUNYOzRCQUNKO3dCQUNKLEVBQUUsQ0FBQyxRQUFRLENBQUNSO29CQUNoQjtvQkFFQXNFLGdCQUFnQmhGLFNBQVNpRjtvQkFDekIsT0FBT2pGO2dCQUNYO2dCQUVBLG1DQUFtQztnQkFDbkMsMkRBQTJEO2dCQUMzRCxTQUFTeVMsUUFBUXhOLFFBQVE7b0JBQ3JCLElBQUlySixRQUFPLElBQUk7b0JBRWYsSUFBSW9FLFVBQVUsSUFBSStFLFVBQVUsU0FBVXRFLE9BQU8sRUFBRUMsTUFBTTt3QkFDakQ5RSxNQUFLeVAsS0FBSyxHQUFHdkwsSUFBSSxDQUFDOzRCQUNkLElBQUl3SCxTQUFTMUwsTUFBSzhPLE9BQU87NEJBQ3pCcEQsT0FBT1ksRUFBRSxDQUFDMUIsV0FBVyxDQUFDLFNBQVV6SyxDQUFDO2dDQUM3QjBWLGNBQWMxVixHQUFHdUwsUUFBUSxpQkFBaUJBLE9BQU9tQixTQUFTLEVBQUUsRUFBRSxFQUFFO29DQUM1RGhJO2dDQUNKLEdBQUcsU0FBVTFFLENBQUMsRUFBRW1GLEtBQUs7b0NBQ2pCUixPQUFPUTtnQ0FDWDs0QkFDSjt3QkFDSixFQUFFLENBQUMsUUFBUSxDQUFDUjtvQkFDaEI7b0JBRUFzRSxnQkFBZ0JoRixTQUFTaUY7b0JBQ3pCLE9BQU9qRjtnQkFDWDtnQkFFQSxrRUFBa0U7Z0JBQ2xFLGVBQWU7Z0JBQ2YsU0FBUzBTLFNBQVN6TixRQUFRO29CQUN0QixJQUFJckosUUFBTyxJQUFJO29CQUVmLElBQUlvRSxVQUFVLElBQUkrRSxVQUFVLFNBQVV0RSxPQUFPLEVBQUVDLE1BQU07d0JBQ2pEOUUsTUFBS3lQLEtBQUssR0FBR3ZMLElBQUksQ0FBQzs0QkFDZCxJQUFJd0gsU0FBUzFMLE1BQUs4TyxPQUFPOzRCQUN6QnBELE9BQU9ZLEVBQUUsQ0FBQzFCLFdBQVcsQ0FBQyxTQUFVekssQ0FBQztnQ0FDN0IseUNBQXlDO2dDQUN6QzBWLGNBQWMxVixHQUFHdUwsUUFBUSxpQ0FBaUNBLE9BQU9tQixTQUFTLEVBQUUsRUFBRSxFQUFFLFNBQVUxTSxDQUFDLEVBQUU4VixPQUFPO29DQUNoRyxJQUFJaFIsU0FBU2dSLFFBQVFDLElBQUksQ0FBQ0UsSUFBSSxDQUFDLEdBQUdXLENBQUM7b0NBQ25DbFMsUUFBUUk7Z0NBQ1osR0FBRyxTQUFVOUUsQ0FBQyxFQUFFbUYsS0FBSztvQ0FDakJSLE9BQU9RO2dDQUNYOzRCQUNKO3dCQUNKLEVBQUUsQ0FBQyxRQUFRLENBQUNSO29CQUNoQjtvQkFFQXNFLGdCQUFnQmhGLFNBQVNpRjtvQkFDekIsT0FBT2pGO2dCQUNYO2dCQUVBLHlFQUF5RTtnQkFDekUsMEVBQTBFO2dCQUMxRSx1RUFBdUU7Z0JBQ3ZFLDBFQUEwRTtnQkFDMUUsMkVBQTJFO2dCQUMzRSw4REFBOEQ7Z0JBQzlELHdDQUF3QztnQkFDeEMsU0FBUzRTLE1BQU01VyxDQUFDLEVBQUVpSixRQUFRO29CQUN0QixJQUFJckosUUFBTyxJQUFJO29CQUVmLElBQUlvRSxVQUFVLElBQUkrRSxVQUFVLFNBQVV0RSxPQUFPLEVBQUVDLE1BQU07d0JBQ2pEOUUsTUFBS3lQLEtBQUssR0FBR3ZMLElBQUksQ0FBQzs0QkFDZCxJQUFJd0gsU0FBUzFMLE1BQUs4TyxPQUFPOzRCQUN6QnBELE9BQU9ZLEVBQUUsQ0FBQzFCLFdBQVcsQ0FBQyxTQUFVekssQ0FBQztnQ0FDN0IwVixjQUFjMVYsR0FBR3VMLFFBQVEscUJBQXFCQSxPQUFPbUIsU0FBUyxHQUFHLHlCQUF5QjtvQ0FBQ3pNLElBQUk7aUNBQUUsRUFBRSxTQUFVRCxDQUFDLEVBQUU4VixPQUFPO29DQUNuSCxJQUFJaFIsU0FBU2dSLFFBQVFDLElBQUksQ0FBQ2xWLE1BQU0sR0FBR2lWLFFBQVFDLElBQUksQ0FBQ0UsSUFBSSxDQUFDLEdBQUczTSxHQUFHLEdBQUc7b0NBQzlENUUsUUFBUUk7Z0NBQ1osR0FBRyxTQUFVOUUsQ0FBQyxFQUFFbUYsS0FBSztvQ0FDakJSLE9BQU9RO2dDQUNYOzRCQUNKO3dCQUNKLEVBQUUsQ0FBQyxRQUFRLENBQUNSO29CQUNoQjtvQkFFQXNFLGdCQUFnQmhGLFNBQVNpRjtvQkFDekIsT0FBT2pGO2dCQUNYO2dCQUVBLFNBQVM2UyxPQUFPNU4sUUFBUTtvQkFDcEIsSUFBSXJKLFFBQU8sSUFBSTtvQkFFZixJQUFJb0UsVUFBVSxJQUFJK0UsVUFBVSxTQUFVdEUsT0FBTyxFQUFFQyxNQUFNO3dCQUNqRDlFLE1BQUt5UCxLQUFLLEdBQUd2TCxJQUFJLENBQUM7NEJBQ2QsSUFBSXdILFNBQVMxTCxNQUFLOE8sT0FBTzs0QkFDekJwRCxPQUFPWSxFQUFFLENBQUMxQixXQUFXLENBQUMsU0FBVXpLLENBQUM7Z0NBQzdCMFYsY0FBYzFWLEdBQUd1TCxRQUFRLHFCQUFxQkEsT0FBT21CLFNBQVMsRUFBRSxFQUFFLEVBQUUsU0FBVTFNLENBQUMsRUFBRThWLE9BQU87b0NBQ3BGLElBQUlqRixPQUFPLEVBQUU7b0NBRWIsSUFBSyxJQUFJclEsSUFBSSxHQUFHQSxJQUFJc1YsUUFBUUMsSUFBSSxDQUFDbFYsTUFBTSxFQUFFTCxJQUFLO3dDQUMxQ3FRLEtBQUs1TixJQUFJLENBQUM2UyxRQUFRQyxJQUFJLENBQUNFLElBQUksQ0FBQ3pWLEdBQUc4SSxHQUFHO29DQUN0QztvQ0FFQTVFLFFBQVFtTTtnQ0FDWixHQUFHLFNBQVU3USxDQUFDLEVBQUVtRixLQUFLO29DQUNqQlIsT0FBT1E7Z0NBQ1g7NEJBQ0o7d0JBQ0osRUFBRSxDQUFDLFFBQVEsQ0FBQ1I7b0JBQ2hCO29CQUVBc0UsZ0JBQWdCaEYsU0FBU2lGO29CQUN6QixPQUFPakY7Z0JBQ1g7Z0JBRUEsK0NBQStDO2dCQUMvQyxnR0FBZ0c7Z0JBQ2hHLFNBQVM4UyxpQkFBaUI1SyxFQUFFO29CQUN4QixPQUFPLElBQUluRCxVQUFVLFNBQVV0RSxPQUFPLEVBQUVDLE1BQU07d0JBQzFDd0gsR0FBRzFCLFdBQVcsQ0FBQyxTQUFVekssQ0FBQzs0QkFDdEJBLEVBQUVvVixVQUFVLENBQUMsb0NBQW9DLGdFQUFnRSxFQUFFLEVBQUUsU0FBVXBWLENBQUMsRUFBRThWLE9BQU87Z0NBQ3JJLElBQUlrQixhQUFhLEVBQUU7Z0NBRW5CLElBQUssSUFBSXhXLElBQUksR0FBR0EsSUFBSXNWLFFBQVFDLElBQUksQ0FBQ2xWLE1BQU0sRUFBRUwsSUFBSztvQ0FDMUN3VyxXQUFXL1QsSUFBSSxDQUFDNlMsUUFBUUMsSUFBSSxDQUFDRSxJQUFJLENBQUN6VixHQUFHOEgsSUFBSTtnQ0FDN0M7Z0NBRUE1RCxRQUFRO29DQUNKeUgsSUFBSUE7b0NBQ0o2SyxZQUFZQTtnQ0FDaEI7NEJBQ0osR0FBRyxTQUFVaFgsQ0FBQyxFQUFFbUYsS0FBSztnQ0FDakJSLE9BQU9ROzRCQUNYO3dCQUNKLEdBQUcsU0FBVW1SLFFBQVE7NEJBQ2pCM1IsT0FBTzJSO3dCQUNYO29CQUNKO2dCQUNKO2dCQUVBLFNBQVNXLGVBQWU1SCxPQUFPLEVBQUVuRyxRQUFRO29CQUNyQ0EsV0FBV1EsWUFBWXBFLEtBQUssQ0FBQyxJQUFJLEVBQUVDO29CQUVuQyxJQUFJd0wsZ0JBQWdCLElBQUksQ0FBQ0MsTUFBTTtvQkFDL0IzQixVQUFVLE9BQU9BLFlBQVksY0FBY0EsV0FBVyxDQUFDO29CQUN2RCxJQUFJLENBQUNBLFFBQVEvRyxJQUFJLEVBQUU7d0JBQ2YrRyxRQUFRL0csSUFBSSxHQUFHK0csUUFBUS9HLElBQUksSUFBSXlJLGNBQWN6SSxJQUFJO3dCQUNqRCtHLFFBQVEzQyxTQUFTLEdBQUcyQyxRQUFRM0MsU0FBUyxJQUFJcUUsY0FBY3JFLFNBQVM7b0JBQ3BFO29CQUVBLElBQUk3TSxRQUFPLElBQUk7b0JBQ2YsSUFBSW9FO29CQUNKLElBQUksQ0FBQ29MLFFBQVEvRyxJQUFJLEVBQUU7d0JBQ2ZyRSxVQUFVK0UsVUFBVXJFLE1BQU0sQ0FBQztvQkFDL0IsT0FBTzt3QkFDSFYsVUFBVSxJQUFJK0UsVUFBVSxTQUFVdEUsT0FBTzs0QkFDckMsSUFBSXlIOzRCQUNKLElBQUlrRCxRQUFRL0csSUFBSSxLQUFLeUksY0FBY3pJLElBQUksRUFBRTtnQ0FDckMsK0NBQStDO2dDQUMvQzZELEtBQUt0TSxNQUFLOE8sT0FBTyxDQUFDeEMsRUFBRTs0QkFDeEIsT0FBTztnQ0FDSEEsS0FBSzFFLGFBQWE0SCxRQUFRL0csSUFBSSxFQUFFLElBQUksSUFBSTs0QkFDNUM7NEJBRUEsSUFBSSxDQUFDK0csUUFBUTNDLFNBQVMsRUFBRTtnQ0FDcEIsMkJBQTJCO2dDQUMzQmhJLFFBQVFxUyxpQkFBaUI1Szs0QkFDN0IsT0FBTztnQ0FDSHpILFFBQVE7b0NBQ0p5SCxJQUFJQTtvQ0FDSjZLLFlBQVk7d0NBQUMzSCxRQUFRM0MsU0FBUztxQ0FBQztnQ0FDbkM7NEJBQ0o7d0JBQ0osR0FBRzNJLElBQUksQ0FBQyxTQUFVbVQsYUFBYTs0QkFDM0IsT0FBTyxJQUFJbE8sVUFBVSxTQUFVdEUsT0FBTyxFQUFFQyxNQUFNO2dDQUMxQ3VTLGNBQWMvSyxFQUFFLENBQUMxQixXQUFXLENBQUMsU0FBVXpLLENBQUM7b0NBQ3BDLFNBQVNtWCxVQUFVekssU0FBUzt3Q0FDeEIsT0FBTyxJQUFJMUQsVUFBVSxTQUFVdEUsT0FBTyxFQUFFQyxNQUFNOzRDQUMxQzNFLEVBQUVvVixVQUFVLENBQUMsMEJBQTBCMUksV0FBVyxFQUFFLEVBQUU7Z0RBQ2xEaEk7NENBQ0osR0FBRyxTQUFVMUUsQ0FBQyxFQUFFbUYsS0FBSztnREFDakJSLE9BQU9ROzRDQUNYO3dDQUNKO29DQUNKO29DQUVBLElBQUlpUyxhQUFhLEVBQUU7b0NBQ25CLElBQUssSUFBSTVXLElBQUksR0FBR3NDLE1BQU1vVSxjQUFjRixVQUFVLENBQUNuVyxNQUFNLEVBQUVMLElBQUlzQyxLQUFLdEMsSUFBSzt3Q0FDakU0VyxXQUFXblUsSUFBSSxDQUFDa1UsVUFBVUQsY0FBY0YsVUFBVSxDQUFDeFcsRUFBRTtvQ0FDekQ7b0NBRUF3SSxVQUFVbkQsR0FBRyxDQUFDdVIsWUFBWXJULElBQUksQ0FBQzt3Q0FDM0JXO29DQUNKLEVBQUUsQ0FBQyxRQUFRLENBQUMsU0FBVTNFLENBQUM7d0NBQ25CNEUsT0FBTzVFO29DQUNYO2dDQUNKLEdBQUcsU0FBVXVXLFFBQVE7b0NBQ2pCM1IsT0FBTzJSO2dDQUNYOzRCQUNKO3dCQUNKO29CQUNKO29CQUVBck4sZ0JBQWdCaEYsU0FBU2lGO29CQUN6QixPQUFPakY7Z0JBQ1g7Z0JBRUEsSUFBSW9ULGdCQUFnQjtvQkFDaEIxRixTQUFTO29CQUNUdkMsY0FBY2lHO29CQUNkekQsVUFBVUM7b0JBQ1Y1QixTQUFTaUc7b0JBQ1RyRyxTQUFTbUc7b0JBQ1QzRixTQUFTbUc7b0JBQ1RqRyxZQUFZa0c7b0JBQ1pqRyxPQUFPa0c7b0JBQ1A3VixRQUFROFY7b0JBQ1JyTixLQUFLdU47b0JBQ0xoRyxNQUFNaUc7b0JBQ05oRyxjQUFjbUc7Z0JBQ2xCO2dCQUVBLFNBQVNLO29CQUNMLElBQUk7d0JBQ0EsT0FBTyxPQUFPQyxpQkFBaUIsZUFBZSxhQUFhQSxnQkFDM0Qsa0RBQWtEO3dCQUNsRCxDQUFDLENBQUNBLGFBQWFsSCxPQUFPO29CQUMxQixFQUFFLE9BQU90USxHQUFHO3dCQUNSLE9BQU87b0JBQ1g7Z0JBQ0o7Z0JBRUEsU0FBU3lYLGNBQWNuSSxPQUFPLEVBQUVvSSxhQUFhO29CQUN6QyxJQUFJQyxZQUFZckksUUFBUS9HLElBQUksR0FBRztvQkFFL0IsSUFBSStHLFFBQVEzQyxTQUFTLEtBQUsrSyxjQUFjL0ssU0FBUyxFQUFFO3dCQUMvQ2dMLGFBQWFySSxRQUFRM0MsU0FBUyxHQUFHO29CQUNyQztvQkFDQSxPQUFPZ0w7Z0JBQ1g7Z0JBRUEsbURBQW1EO2dCQUNuRCxTQUFTQztvQkFDTCxJQUFJQyxzQkFBc0I7b0JBRTFCLElBQUk7d0JBQ0FMLGFBQWFsSCxPQUFPLENBQUN1SCxxQkFBcUI7d0JBQzFDTCxhQUFhaEgsVUFBVSxDQUFDcUg7d0JBRXhCLE9BQU87b0JBQ1gsRUFBRSxPQUFPN1gsR0FBRzt3QkFDUixPQUFPO29CQUNYO2dCQUNKO2dCQUVBLDZEQUE2RDtnQkFDN0QsMEVBQTBFO2dCQUMxRSx3RUFBd0U7Z0JBQ3hFLDZDQUE2QztnQkFDN0MsU0FBUzhYO29CQUNMLE9BQU8sQ0FBQ0YsK0JBQStCSixhQUFhMVcsTUFBTSxHQUFHO2dCQUNqRTtnQkFFQSxvRUFBb0U7Z0JBQ3BFLFNBQVNpWCxlQUFlekksT0FBTztvQkFDM0IsSUFBSXhQLFFBQU8sSUFBSTtvQkFDZixJQUFJMEwsU0FBUyxDQUFDO29CQUNkLElBQUk4RCxTQUFTO3dCQUNULElBQUssSUFBSTdPLEtBQUs2TyxRQUFTOzRCQUNuQjlELE1BQU0sQ0FBQy9LLEVBQUUsR0FBRzZPLE9BQU8sQ0FBQzdPLEVBQUU7d0JBQzFCO29CQUNKO29CQUVBK0ssT0FBT21NLFNBQVMsR0FBR0YsY0FBY25JLFNBQVN4UCxNQUFLOFAsY0FBYztvQkFFN0QsSUFBSSxDQUFDa0kseUJBQXlCO3dCQUMxQixPQUFPN08sVUFBVXJFLE1BQU07b0JBQzNCO29CQUVBOUUsTUFBSzhPLE9BQU8sR0FBR3BEO29CQUNmQSxPQUFPa0ssVUFBVSxHQUFHUDtvQkFFcEIsT0FBT2xNLFVBQVV0RSxPQUFPO2dCQUM1QjtnQkFFQSx5RUFBeUU7Z0JBQ3pFLDZCQUE2QjtnQkFDN0IsU0FBU3FULFFBQVE3TyxRQUFRO29CQUNyQixJQUFJckosUUFBTyxJQUFJO29CQUNmLElBQUlvRSxVQUFVcEUsTUFBS3lQLEtBQUssR0FBR3ZMLElBQUksQ0FBQzt3QkFDNUIsSUFBSTJULFlBQVk3WCxNQUFLOE8sT0FBTyxDQUFDK0ksU0FBUzt3QkFFdEMsSUFBSyxJQUFJbFgsSUFBSStXLGFBQWExVyxNQUFNLEdBQUcsR0FBR0wsS0FBSyxHQUFHQSxJQUFLOzRCQUMvQyxJQUFJOEksTUFBTWlPLGFBQWFqTyxHQUFHLENBQUM5STs0QkFFM0IsSUFBSThJLElBQUl0QixPQUFPLENBQUMwUCxlQUFlLEdBQUc7Z0NBQzlCSCxhQUFhaEgsVUFBVSxDQUFDakg7NEJBQzVCO3dCQUNKO29CQUNKO29CQUVBTCxnQkFBZ0JoRixTQUFTaUY7b0JBQ3pCLE9BQU9qRjtnQkFDWDtnQkFFQSxxRUFBcUU7Z0JBQ3JFLDBFQUEwRTtnQkFDMUUsK0RBQStEO2dCQUMvRCxTQUFTK1QsVUFBVTFPLEdBQUcsRUFBRUosUUFBUTtvQkFDNUIsSUFBSXJKLFFBQU8sSUFBSTtvQkFFZnlKLE1BQU1ELGFBQWFDO29CQUVuQixJQUFJckYsVUFBVXBFLE1BQUt5UCxLQUFLLEdBQUd2TCxJQUFJLENBQUM7d0JBQzVCLElBQUl3SCxTQUFTMUwsTUFBSzhPLE9BQU87d0JBQ3pCLElBQUk3SixTQUFTeVMsYUFBYTFILE9BQU8sQ0FBQ3RFLE9BQU9tTSxTQUFTLEdBQUdwTzt3QkFFckQsc0RBQXNEO3dCQUN0RCwyREFBMkQ7d0JBQzNELHdEQUF3RDt3QkFDeEQsWUFBWTt3QkFDWixJQUFJeEUsUUFBUTs0QkFDUkEsU0FBU3lHLE9BQU9rSyxVQUFVLENBQUNuQixXQUFXLENBQUN4UDt3QkFDM0M7d0JBRUEsT0FBT0E7b0JBQ1g7b0JBRUFtRSxnQkFBZ0JoRixTQUFTaUY7b0JBQ3pCLE9BQU9qRjtnQkFDWDtnQkFFQSx1Q0FBdUM7Z0JBQ3ZDLFNBQVNnVSxVQUFVdFIsUUFBUSxFQUFFdUMsUUFBUTtvQkFDakMsSUFBSXJKLFFBQU8sSUFBSTtvQkFFZixJQUFJb0UsVUFBVXBFLE1BQUt5UCxLQUFLLEdBQUd2TCxJQUFJLENBQUM7d0JBQzVCLElBQUl3SCxTQUFTMUwsTUFBSzhPLE9BQU87d0JBQ3pCLElBQUkrSSxZQUFZbk0sT0FBT21NLFNBQVM7d0JBQ2hDLElBQUlRLGtCQUFrQlIsVUFBVTdXLE1BQU07d0JBQ3RDLElBQUlBLFNBQVMwVyxhQUFhMVcsTUFBTTt3QkFFaEMsZ0VBQWdFO3dCQUNoRSwyREFBMkQ7d0JBQzNELDJEQUEyRDt3QkFDM0QsWUFBWTt3QkFDWixFQUFFO3dCQUNGLG9FQUFvRTt3QkFDcEUsSUFBSXNQLGtCQUFrQjt3QkFFdEIsSUFBSyxJQUFJM1AsSUFBSSxHQUFHQSxJQUFJSyxRQUFRTCxJQUFLOzRCQUM3QixJQUFJOEksTUFBTWlPLGFBQWFqTyxHQUFHLENBQUM5STs0QkFDM0IsSUFBSThJLElBQUl0QixPQUFPLENBQUMwUCxlQUFlLEdBQUc7Z0NBQzlCOzRCQUNKOzRCQUNBLElBQUlqVCxRQUFROFMsYUFBYTFILE9BQU8sQ0FBQ3ZHOzRCQUVqQyxzREFBc0Q7NEJBQ3RELHVEQUF1RDs0QkFDdkQscURBQXFEOzRCQUNyRCxtQkFBbUI7NEJBQ25CLElBQUk3RSxPQUFPO2dDQUNQQSxRQUFROEcsT0FBT2tLLFVBQVUsQ0FBQ25CLFdBQVcsQ0FBQzdQOzRCQUMxQzs0QkFFQUEsUUFBUWtDLFNBQVNsQyxPQUFPNkUsSUFBSXNLLFNBQVMsQ0FBQ3NFLGtCQUFrQi9IOzRCQUV4RCxJQUFJMUwsVUFBVSxLQUFLLEdBQUc7Z0NBQ2xCLE9BQU9BOzRCQUNYO3dCQUNKO29CQUNKO29CQUVBd0UsZ0JBQWdCaEYsU0FBU2lGO29CQUN6QixPQUFPakY7Z0JBQ1g7Z0JBRUEsZ0VBQWdFO2dCQUNoRSxTQUFTa1UsTUFBTWxZLENBQUMsRUFBRWlKLFFBQVE7b0JBQ3RCLElBQUlySixRQUFPLElBQUk7b0JBQ2YsSUFBSW9FLFVBQVVwRSxNQUFLeVAsS0FBSyxHQUFHdkwsSUFBSSxDQUFDO3dCQUM1QixJQUFJd0gsU0FBUzFMLE1BQUs4TyxPQUFPO3dCQUN6QixJQUFJN0o7d0JBQ0osSUFBSTs0QkFDQUEsU0FBU3lTLGFBQWFqTyxHQUFHLENBQUNySjt3QkFDOUIsRUFBRSxPQUFPa0YsT0FBTzs0QkFDWkwsU0FBUzt3QkFDYjt3QkFFQSxxREFBcUQ7d0JBQ3JELElBQUlBLFFBQVE7NEJBQ1JBLFNBQVNBLE9BQU84TyxTQUFTLENBQUNySSxPQUFPbU0sU0FBUyxDQUFDN1csTUFBTTt3QkFDckQ7d0JBRUEsT0FBT2lFO29CQUNYO29CQUVBbUUsZ0JBQWdCaEYsU0FBU2lGO29CQUN6QixPQUFPakY7Z0JBQ1g7Z0JBRUEsU0FBU21VLE9BQU9sUCxRQUFRO29CQUNwQixJQUFJckosUUFBTyxJQUFJO29CQUNmLElBQUlvRSxVQUFVcEUsTUFBS3lQLEtBQUssR0FBR3ZMLElBQUksQ0FBQzt3QkFDNUIsSUFBSXdILFNBQVMxTCxNQUFLOE8sT0FBTzt3QkFDekIsSUFBSTlOLFNBQVMwVyxhQUFhMVcsTUFBTTt3QkFDaEMsSUFBSWdRLE9BQU8sRUFBRTt3QkFFYixJQUFLLElBQUlyUSxJQUFJLEdBQUdBLElBQUlLLFFBQVFMLElBQUs7NEJBQzdCLElBQUk2WCxVQUFVZCxhQUFhak8sR0FBRyxDQUFDOUk7NEJBQy9CLElBQUk2WCxRQUFRclEsT0FBTyxDQUFDdUQsT0FBT21NLFNBQVMsTUFBTSxHQUFHO2dDQUN6QzdHLEtBQUs1TixJQUFJLENBQUNvVixRQUFRekUsU0FBUyxDQUFDckksT0FBT21NLFNBQVMsQ0FBQzdXLE1BQU07NEJBQ3ZEO3dCQUNKO3dCQUVBLE9BQU9nUTtvQkFDWDtvQkFFQTVILGdCQUFnQmhGLFNBQVNpRjtvQkFDekIsT0FBT2pGO2dCQUNYO2dCQUVBLHVFQUF1RTtnQkFDdkUsU0FBU3FVLFNBQVNwUCxRQUFRO29CQUN0QixJQUFJckosUUFBTyxJQUFJO29CQUNmLElBQUlvRSxVQUFVcEUsTUFBS2dSLElBQUksR0FBRzlNLElBQUksQ0FBQyxTQUFVOE0sSUFBSTt3QkFDekMsT0FBT0EsS0FBS2hRLE1BQU07b0JBQ3RCO29CQUVBb0ksZ0JBQWdCaEYsU0FBU2lGO29CQUN6QixPQUFPakY7Z0JBQ1g7Z0JBRUEsa0RBQWtEO2dCQUNsRCxTQUFTc1UsYUFBYWpQLEdBQUcsRUFBRUosUUFBUTtvQkFDL0IsSUFBSXJKLFFBQU8sSUFBSTtvQkFFZnlKLE1BQU1ELGFBQWFDO29CQUVuQixJQUFJckYsVUFBVXBFLE1BQUt5UCxLQUFLLEdBQUd2TCxJQUFJLENBQUM7d0JBQzVCLElBQUl3SCxTQUFTMUwsTUFBSzhPLE9BQU87d0JBQ3pCNEksYUFBYWhILFVBQVUsQ0FBQ2hGLE9BQU9tTSxTQUFTLEdBQUdwTztvQkFDL0M7b0JBRUFMLGdCQUFnQmhGLFNBQVNpRjtvQkFDekIsT0FBT2pGO2dCQUNYO2dCQUVBLHdFQUF3RTtnQkFDeEUsMkVBQTJFO2dCQUMzRSxzRUFBc0U7Z0JBQ3RFLGlDQUFpQztnQkFDakMsU0FBU3VVLFVBQVVsUCxHQUFHLEVBQUU3RSxLQUFLLEVBQUV5RSxRQUFRO29CQUNuQyxJQUFJckosUUFBTyxJQUFJO29CQUVmeUosTUFBTUQsYUFBYUM7b0JBRW5CLElBQUlyRixVQUFVcEUsTUFBS3lQLEtBQUssR0FBR3ZMLElBQUksQ0FBQzt3QkFDNUIsb0NBQW9DO3dCQUNwQyxpREFBaUQ7d0JBQ2pELElBQUlVLFVBQVV5SyxXQUFXOzRCQUNyQnpLLFFBQVE7d0JBQ1o7d0JBRUEsbURBQW1EO3dCQUNuRCxJQUFJNFIsZ0JBQWdCNVI7d0JBRXBCLE9BQU8sSUFBSXVFLFVBQVUsU0FBVXRFLE9BQU8sRUFBRUMsTUFBTTs0QkFDMUMsSUFBSTRHLFNBQVMxTCxNQUFLOE8sT0FBTzs0QkFDekJwRCxPQUFPa0ssVUFBVSxDQUFDNUIsU0FBUyxDQUFDcFAsT0FBTyxTQUFVQSxLQUFLLEVBQUVVLEtBQUs7Z0NBQ3JELElBQUlBLE9BQU87b0NBQ1BSLE9BQU9RO2dDQUNYLE9BQU87b0NBQ0gsSUFBSTt3Q0FDQW9TLGFBQWFsSCxPQUFPLENBQUM5RSxPQUFPbU0sU0FBUyxHQUFHcE8sS0FBSzdFO3dDQUM3Q0MsUUFBUTJSO29DQUNaLEVBQUUsT0FBT3RXLEdBQUc7d0NBQ1Isa0NBQWtDO3dDQUNsQywwQ0FBMEM7d0NBQzFDLElBQUlBLEVBQUV1SSxJQUFJLEtBQUssd0JBQXdCdkksRUFBRXVJLElBQUksS0FBSyw4QkFBOEI7NENBQzVFM0QsT0FBTzVFO3dDQUNYO3dDQUNBNEUsT0FBTzVFO29DQUNYO2dDQUNKOzRCQUNKO3dCQUNKO29CQUNKO29CQUVBa0osZ0JBQWdCaEYsU0FBU2lGO29CQUN6QixPQUFPakY7Z0JBQ1g7Z0JBRUEsU0FBU3dVLGVBQWVwSixPQUFPLEVBQUVuRyxRQUFRO29CQUNyQ0EsV0FBV1EsWUFBWXBFLEtBQUssQ0FBQyxJQUFJLEVBQUVDO29CQUVuQzhKLFVBQVUsT0FBT0EsWUFBWSxjQUFjQSxXQUFXLENBQUM7b0JBQ3ZELElBQUksQ0FBQ0EsUUFBUS9HLElBQUksRUFBRTt3QkFDZixJQUFJeUksZ0JBQWdCLElBQUksQ0FBQ0MsTUFBTTt3QkFDL0IzQixRQUFRL0csSUFBSSxHQUFHK0csUUFBUS9HLElBQUksSUFBSXlJLGNBQWN6SSxJQUFJO3dCQUNqRCtHLFFBQVEzQyxTQUFTLEdBQUcyQyxRQUFRM0MsU0FBUyxJQUFJcUUsY0FBY3JFLFNBQVM7b0JBQ3BFO29CQUVBLElBQUk3TSxRQUFPLElBQUk7b0JBQ2YsSUFBSW9FO29CQUNKLElBQUksQ0FBQ29MLFFBQVEvRyxJQUFJLEVBQUU7d0JBQ2ZyRSxVQUFVK0UsVUFBVXJFLE1BQU0sQ0FBQztvQkFDL0IsT0FBTzt3QkFDSFYsVUFBVSxJQUFJK0UsVUFBVSxTQUFVdEUsT0FBTzs0QkFDckMsSUFBSSxDQUFDMkssUUFBUTNDLFNBQVMsRUFBRTtnQ0FDcEJoSSxRQUFRMkssUUFBUS9HLElBQUksR0FBRzs0QkFDM0IsT0FBTztnQ0FDSDVELFFBQVE4UyxjQUFjbkksU0FBU3hQLE1BQUs4UCxjQUFjOzRCQUN0RDt3QkFDSixHQUFHNUwsSUFBSSxDQUFDLFNBQVUyVCxTQUFTOzRCQUN2QixJQUFLLElBQUlsWCxJQUFJK1csYUFBYTFXLE1BQU0sR0FBRyxHQUFHTCxLQUFLLEdBQUdBLElBQUs7Z0NBQy9DLElBQUk4SSxNQUFNaU8sYUFBYWpPLEdBQUcsQ0FBQzlJO2dDQUUzQixJQUFJOEksSUFBSXRCLE9BQU8sQ0FBQzBQLGVBQWUsR0FBRztvQ0FDOUJILGFBQWFoSCxVQUFVLENBQUNqSDtnQ0FDNUI7NEJBQ0o7d0JBQ0o7b0JBQ0o7b0JBRUFMLGdCQUFnQmhGLFNBQVNpRjtvQkFDekIsT0FBT2pGO2dCQUNYO2dCQUVBLElBQUl5VSxzQkFBc0I7b0JBQ3RCL0csU0FBUztvQkFDVHZDLGNBQWMwSTtvQkFDZGxHLFVBQVUwRjtvQkFDVnJILFNBQVNnSTtvQkFDVHBJLFNBQVNtSTtvQkFDVDNILFNBQVNtSTtvQkFDVGpJLFlBQVlnSTtvQkFDWi9ILE9BQU91SDtvQkFDUGxYLFFBQVF5WDtvQkFDUmhQLEtBQUs2TztvQkFDTHRILE1BQU11SDtvQkFDTnRILGNBQWMySDtnQkFDbEI7Z0JBRUEsSUFBSUUsWUFBWSxTQUFTQSxVQUFVQyxDQUFDLEVBQUVDLENBQUM7b0JBQ25DLE9BQU9ELE1BQU1DLEtBQUssT0FBT0QsTUFBTSxZQUFZLE9BQU9DLE1BQU0sWUFBWUMsTUFBTUYsTUFBTUUsTUFBTUQ7Z0JBQzFGO2dCQUVBLElBQUlFLFdBQVcsU0FBU0EsU0FBU0MsS0FBSyxFQUFFQyxhQUFhO29CQUNqRCxJQUFJblcsTUFBTWtXLE1BQU1uWSxNQUFNO29CQUN0QixJQUFJTCxJQUFJO29CQUNSLE1BQU9BLElBQUlzQyxJQUFLO3dCQUNaLElBQUk2VixVQUFVSyxLQUFLLENBQUN4WSxFQUFFLEVBQUV5WSxnQkFBZ0I7NEJBQ3BDLE9BQU87d0JBQ1g7d0JBQ0F6WTtvQkFDSjtvQkFFQSxPQUFPO2dCQUNYO2dCQUVBLElBQUkwWSxVQUFVaFQsTUFBTWdULE9BQU8sSUFBSSxTQUFVQyxHQUFHO29CQUN4QyxPQUFPcFQsT0FBT2xDLFNBQVMsQ0FBQ21DLFFBQVEsQ0FBQ3BGLElBQUksQ0FBQ3VZLFNBQVM7Z0JBQ25EO2dCQUVBLDJEQUEyRDtnQkFDM0QsdURBQXVEO2dCQUN2RCxJQUFJQyxpQkFBaUIsQ0FBQztnQkFFdEIsSUFBSUMsZ0JBQWdCLENBQUM7Z0JBRXJCLElBQUlDLGlCQUFpQjtvQkFDakJDLFdBQVc3SDtvQkFDWDhILFFBQVFuQztvQkFDUm9DLGNBQWNmO2dCQUNsQjtnQkFFQSxJQUFJZ0IscUJBQXFCO29CQUFDSixlQUFlQyxTQUFTLENBQUM1SCxPQUFPO29CQUFFMkgsZUFBZUUsTUFBTSxDQUFDN0gsT0FBTztvQkFBRTJILGVBQWVHLFlBQVksQ0FBQzlILE9BQU87aUJBQUM7Z0JBRS9ILElBQUlnSSx3QkFBd0I7b0JBQUM7aUJBQWU7Z0JBRTVDLElBQUlDLGlCQUFpQjtvQkFBQztvQkFBUztvQkFBVztvQkFBVztvQkFBTztvQkFBUTtvQkFBVTtvQkFBYztpQkFBVSxDQUFDQyxNQUFNLENBQUNGO2dCQUU5RyxJQUFJRyxnQkFBZ0I7b0JBQ2hCdkUsYUFBYTtvQkFDYndFLFFBQVFMLG1CQUFtQmhLLEtBQUs7b0JBQ2hDcEgsTUFBTTtvQkFDTixnRUFBZ0U7b0JBQ2hFLCtCQUErQjtvQkFDL0JrTixNQUFNO29CQUNOOUksV0FBVztvQkFDWEosU0FBUztnQkFDYjtnQkFFQSxTQUFTME4sY0FBY0MsbUJBQW1CLEVBQUVDLGFBQWE7b0JBQ3JERCxtQkFBbUIsQ0FBQ0MsY0FBYyxHQUFHO3dCQUNqQyxJQUFJQyxRQUFRNVU7d0JBQ1osT0FBTzBVLG9CQUFvQjNLLEtBQUssR0FBR3ZMLElBQUksQ0FBQzs0QkFDcEMsT0FBT2tXLG1CQUFtQixDQUFDQyxjQUFjLENBQUM1VSxLQUFLLENBQUMyVSxxQkFBcUJFO3dCQUN6RTtvQkFDSjtnQkFDSjtnQkFFQSxTQUFTQztvQkFDTCxJQUFLLElBQUk1WixJQUFJLEdBQUdBLElBQUkrRSxVQUFVMUUsTUFBTSxFQUFFTCxJQUFLO3dCQUN2QyxJQUFJMlksTUFBTTVULFNBQVMsQ0FBQy9FLEVBQUU7d0JBRXRCLElBQUkyWSxLQUFLOzRCQUNMLElBQUssSUFBSWtCLFFBQVFsQixJQUFLO2dDQUNsQixJQUFJQSxJQUFJbUIsY0FBYyxDQUFDRCxPQUFPO29DQUMxQixJQUFJbkIsUUFBUUMsR0FBRyxDQUFDa0IsS0FBSyxHQUFHO3dDQUNwQjlVLFNBQVMsQ0FBQyxFQUFFLENBQUM4VSxLQUFLLEdBQUdsQixHQUFHLENBQUNrQixLQUFLLENBQUMzSyxLQUFLO29DQUN4QyxPQUFPO3dDQUNIbkssU0FBUyxDQUFDLEVBQUUsQ0FBQzhVLEtBQUssR0FBR2xCLEdBQUcsQ0FBQ2tCLEtBQUs7b0NBQ2xDO2dDQUNKOzRCQUNKO3dCQUNKO29CQUNKO29CQUVBLE9BQU85VSxTQUFTLENBQUMsRUFBRTtnQkFDdkI7Z0JBRUEsSUFBSWdWLGNBQWM7b0JBQ2QsU0FBU0EsWUFBWWxMLE9BQU87d0JBQ3hCekksZ0JBQWdCLElBQUksRUFBRTJUO3dCQUV0QixJQUFLLElBQUlDLGlCQUFpQmxCLGVBQWdCOzRCQUN0QyxJQUFJQSxlQUFlZ0IsY0FBYyxDQUFDRSxnQkFBZ0I7Z0NBQzlDLElBQUlULFNBQVNULGNBQWMsQ0FBQ2tCLGNBQWM7Z0NBQzFDLElBQUlDLGFBQWFWLE9BQU9wSSxPQUFPO2dDQUMvQixJQUFJLENBQUM2SSxjQUFjLEdBQUdDO2dDQUV0QixJQUFJLENBQUNyQixjQUFjLENBQUNxQixXQUFXLEVBQUU7b0NBQzdCLHlDQUF5QztvQ0FDekMsMkNBQTJDO29DQUMzQyx1QkFBdUI7b0NBQ3ZCLElBQUksQ0FBQ0MsWUFBWSxDQUFDWDtnQ0FDdEI7NEJBQ0o7d0JBQ0o7d0JBRUEsSUFBSSxDQUFDcEssY0FBYyxHQUFHeUssT0FBTyxDQUFDLEdBQUdOO3dCQUNqQyxJQUFJLENBQUNhLE9BQU8sR0FBR1AsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDekssY0FBYyxFQUFFTjt3QkFDL0MsSUFBSSxDQUFDdUwsVUFBVSxHQUFHO3dCQUNsQixJQUFJLENBQUNDLFdBQVcsR0FBRzt3QkFDbkIsSUFBSSxDQUFDQyxNQUFNLEdBQUc7d0JBQ2QsSUFBSSxDQUFDbk0sT0FBTyxHQUFHO3dCQUVmLElBQUksQ0FBQ29NLDRCQUE0Qjt3QkFDakMsSUFBSSxDQUFDQyxTQUFTLENBQUMsSUFBSSxDQUFDTCxPQUFPLENBQUNaLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxZQUFhO29CQUM5RDtvQkFFQSxzRUFBc0U7b0JBQ3RFLGtEQUFrRDtvQkFDbEQsZ0VBQWdFO29CQUNoRSxVQUFVO29CQUdWUSxZQUFZMVcsU0FBUyxDQUFDbU4sTUFBTSxHQUFHLFNBQVNBLE9BQU8zQixPQUFPO3dCQUNsRCxpRUFBaUU7d0JBQ2pFLDhEQUE4RDt3QkFDOUQsaUJBQWlCO3dCQUNqQixJQUFJLENBQUMsT0FBT0EsWUFBWSxjQUFjLGNBQWM1SSxRQUFRNEksUUFBTyxNQUFPLFVBQVU7NEJBQ2hGLDhEQUE4RDs0QkFDOUQsNkRBQTZEOzRCQUM3RCxJQUFJLElBQUksQ0FBQ3lMLE1BQU0sRUFBRTtnQ0FDYixPQUFPLElBQUlyYSxNQUFNLDJDQUEyQzs0QkFDaEU7NEJBRUEsSUFBSyxJQUFJRCxLQUFLNk8sUUFBUztnQ0FDbkIsSUFBSTdPLE1BQU0sYUFBYTtvQ0FDbkI2TyxPQUFPLENBQUM3TyxFQUFFLEdBQUc2TyxPQUFPLENBQUM3TyxFQUFFLENBQUN5YSxPQUFPLENBQUMsT0FBTztnQ0FDM0M7Z0NBRUEsSUFBSXphLE1BQU0sYUFBYSxPQUFPNk8sT0FBTyxDQUFDN08sRUFBRSxLQUFLLFVBQVU7b0NBQ25ELE9BQU8sSUFBSUMsTUFBTTtnQ0FDckI7Z0NBRUEsSUFBSSxDQUFDa2EsT0FBTyxDQUFDbmEsRUFBRSxHQUFHNk8sT0FBTyxDQUFDN08sRUFBRTs0QkFDaEM7NEJBRUEsdUNBQXVDOzRCQUN2Qyw0Q0FBNEM7NEJBQzVDLElBQUksWUFBWTZPLFdBQVdBLFFBQVEwSyxNQUFNLEVBQUU7Z0NBQ3ZDLE9BQU8sSUFBSSxDQUFDaUIsU0FBUyxDQUFDLElBQUksQ0FBQ0wsT0FBTyxDQUFDWixNQUFNOzRCQUM3Qzs0QkFFQSxPQUFPO3dCQUNYLE9BQU8sSUFBSSxPQUFPMUssWUFBWSxVQUFVOzRCQUNwQyxPQUFPLElBQUksQ0FBQ3NMLE9BQU8sQ0FBQ3RMLFFBQVE7d0JBQ2hDLE9BQU87NEJBQ0gsT0FBTyxJQUFJLENBQUNzTCxPQUFPO3dCQUN2QjtvQkFDSjtvQkFFQSxpRUFBaUU7b0JBQ2pFLGVBQWU7b0JBR2ZKLFlBQVkxVyxTQUFTLENBQUM2VyxZQUFZLEdBQUcsU0FBU0EsYUFBYVEsWUFBWSxFQUFFaFMsUUFBUSxFQUFFRSxhQUFhO3dCQUM1RixJQUFJbkYsVUFBVSxJQUFJK0UsVUFBVSxTQUFVdEUsT0FBTyxFQUFFQyxNQUFNOzRCQUNqRCxJQUFJO2dDQUNBLElBQUk4VixhQUFhUyxhQUFhdkosT0FBTztnQ0FDckMsSUFBSXdKLGtCQUFrQixJQUFJMWEsTUFBTSxzQ0FBc0M7Z0NBRXRFLDJEQUEyRDtnQ0FDM0Qsb0NBQW9DO2dDQUNwQyxJQUFJLENBQUN5YSxhQUFhdkosT0FBTyxFQUFFO29DQUN2QmhOLE9BQU93VztvQ0FDUDtnQ0FDSjtnQ0FFQSxJQUFJQyxnQkFBZ0J4QixlQUFlQyxNQUFNLENBQUM7Z0NBQzFDLElBQUssSUFBSXJaLElBQUksR0FBR3NDLE1BQU1zWSxjQUFjdmEsTUFBTSxFQUFFTCxJQUFJc0MsS0FBS3RDLElBQUs7b0NBQ3RELElBQUk2YSxtQkFBbUJELGFBQWEsQ0FBQzVhLEVBQUU7b0NBRXZDLDhCQUE4QjtvQ0FDOUIsMkNBQTJDO29DQUMzQyxJQUFJOGEsYUFBYSxDQUFDdkMsU0FBU1ksdUJBQXVCMEI7b0NBQ2xELElBQUksQ0FBQ0MsY0FBY0osWUFBWSxDQUFDRyxpQkFBaUIsS0FBSyxPQUFPSCxZQUFZLENBQUNHLGlCQUFpQixLQUFLLFlBQVk7d0NBQ3hHMVcsT0FBT3dXO3dDQUNQO29DQUNKO2dDQUNKO2dDQUVBLElBQUlJLDBCQUEwQixTQUFTQTtvQ0FDbkMsSUFBSUMsOEJBQThCLFNBQVNBLDRCQUE0QkMsVUFBVTt3Q0FDN0UsT0FBTzs0Q0FDSCxJQUFJdFcsUUFBUSxJQUFJMUUsTUFBTSxZQUFZZ2IsYUFBYTs0Q0FDL0MsSUFBSXhYLFVBQVUrRSxVQUFVckUsTUFBTSxDQUFDUTs0Q0FDL0I4RCxnQkFBZ0JoRixTQUFTc0IsU0FBUyxDQUFDQSxVQUFVMUUsTUFBTSxHQUFHLEVBQUU7NENBQ3hELE9BQU9vRDt3Q0FDWDtvQ0FDSjtvQ0FFQSxJQUFLLElBQUl5WCxLQUFLLEdBQUdDLE9BQU9oQyxzQkFBc0I5WSxNQUFNLEVBQUU2YSxLQUFLQyxNQUFNRCxLQUFNO3dDQUNuRSxJQUFJRSx1QkFBdUJqQyxxQkFBcUIsQ0FBQytCLEdBQUc7d0NBQ3BELElBQUksQ0FBQ1IsWUFBWSxDQUFDVSxxQkFBcUIsRUFBRTs0Q0FDckNWLFlBQVksQ0FBQ1UscUJBQXFCLEdBQUdKLDRCQUE0Qkk7d0NBQ3JFO29DQUNKO2dDQUNKO2dDQUVBTDtnQ0FFQSxJQUFJTSxtQkFBbUIsU0FBU0EsaUJBQWlCQyxPQUFPO29DQUNwRCxJQUFJMUMsY0FBYyxDQUFDcUIsV0FBVyxFQUFFO3dDQUM1QmxSLFFBQVF3UyxJQUFJLENBQUMsb0NBQW9DdEI7b0NBQ3JEO29DQUNBckIsY0FBYyxDQUFDcUIsV0FBVyxHQUFHUztvQ0FDN0I3QixhQUFhLENBQUNvQixXQUFXLEdBQUdxQjtvQ0FDNUIsMENBQTBDO29DQUMxQyw0Q0FBNEM7b0NBQzVDLHVCQUF1QjtvQ0FDdkJwWDtnQ0FDSjtnQ0FFQSxJQUFJLGNBQWN3VyxjQUFjO29DQUM1QixJQUFJQSxhQUFhdEosUUFBUSxJQUFJLE9BQU9zSixhQUFhdEosUUFBUSxLQUFLLFlBQVk7d0NBQ3RFc0osYUFBYXRKLFFBQVEsR0FBRzdOLElBQUksQ0FBQzhYLGtCQUFrQmxYO29DQUNuRCxPQUFPO3dDQUNIa1gsaUJBQWlCLENBQUMsQ0FBQ1gsYUFBYXRKLFFBQVE7b0NBQzVDO2dDQUNKLE9BQU87b0NBQ0hpSyxpQkFBaUI7Z0NBQ3JCOzRCQUNKLEVBQUUsT0FBTzliLEdBQUc7Z0NBQ1I0RSxPQUFPNUU7NEJBQ1g7d0JBQ0o7d0JBRUFvSixvQkFBb0JsRixTQUFTaUYsVUFBVUU7d0JBQ3ZDLE9BQU9uRjtvQkFDWDtvQkFFQXNXLFlBQVkxVyxTQUFTLENBQUNrVyxNQUFNLEdBQUcsU0FBU0E7d0JBQ3BDLE9BQU8sSUFBSSxDQUFDcEksT0FBTyxJQUFJO29CQUMzQjtvQkFFQTRJLFlBQVkxVyxTQUFTLENBQUNtWSxTQUFTLEdBQUcsU0FBU0EsVUFBVXZCLFVBQVUsRUFBRXZSLFFBQVEsRUFBRUUsYUFBYTt3QkFDcEYsSUFBSTZTLG1CQUFtQjdDLGNBQWMsQ0FBQ3FCLFdBQVcsR0FBR3pSLFVBQVV0RSxPQUFPLENBQUMwVSxjQUFjLENBQUNxQixXQUFXLElBQUl6UixVQUFVckUsTUFBTSxDQUFDLElBQUlsRSxNQUFNO3dCQUUvSDBJLG9CQUFvQjhTLGtCQUFrQi9TLFVBQVVFO3dCQUNoRCxPQUFPNlM7b0JBQ1g7b0JBRUExQixZQUFZMVcsU0FBUyxDQUFDcVksYUFBYSxHQUFHLFNBQVNBLGNBQWNoVCxRQUFRO3dCQUNqRSxJQUFJaVQsb0JBQW9CblQsVUFBVXRFLE9BQU8sQ0FBQ3dRO3dCQUMxQy9MLG9CQUFvQmdULG1CQUFtQmpUO3dCQUN2QyxPQUFPaVQ7b0JBQ1g7b0JBRUE1QixZQUFZMVcsU0FBUyxDQUFDeUwsS0FBSyxHQUFHLFNBQVNBLE1BQU1wRyxRQUFRO3dCQUNqRCxJQUFJckosUUFBTyxJQUFJO3dCQUVmLElBQUlvRSxVQUFVcEUsTUFBSythLFVBQVUsQ0FBQzdXLElBQUksQ0FBQzs0QkFDL0IsSUFBSWxFLE1BQUtpYixNQUFNLEtBQUssTUFBTTtnQ0FDdEJqYixNQUFLaWIsTUFBTSxHQUFHamIsTUFBS2diLFdBQVc7NEJBQ2xDOzRCQUVBLE9BQU9oYixNQUFLaWIsTUFBTTt3QkFDdEI7d0JBRUEzUixvQkFBb0JsRixTQUFTaUYsVUFBVUE7d0JBQ3ZDLE9BQU9qRjtvQkFDWDtvQkFFQXNXLFlBQVkxVyxTQUFTLENBQUNtWCxTQUFTLEdBQUcsU0FBU0EsVUFBVW9CLE9BQU8sRUFBRWxULFFBQVEsRUFBRUUsYUFBYTt3QkFDakYsSUFBSXZKLFFBQU8sSUFBSTt3QkFFZixJQUFJLENBQUNxWixRQUFRa0QsVUFBVTs0QkFDbkJBLFVBQVU7Z0NBQUNBOzZCQUFRO3dCQUN2Qjt3QkFFQSxJQUFJQyxtQkFBbUIsSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQ0Y7d0JBRWpELFNBQVNHOzRCQUNMMWMsTUFBSzhhLE9BQU8sQ0FBQ1osTUFBTSxHQUFHbGEsTUFBS2thLE1BQU07d0JBQ3JDO3dCQUVBLFNBQVN5QyxxQkFBcUJ6QyxNQUFNOzRCQUNoQ2xhLE1BQUs0YyxPQUFPLENBQUMxQzs0QkFDYndDOzRCQUVBMWMsTUFBS2liLE1BQU0sR0FBR2piLE1BQUt1UCxZQUFZLENBQUN2UCxNQUFLOGEsT0FBTzs0QkFDNUMsT0FBTzlhLE1BQUtpYixNQUFNO3dCQUN0Qjt3QkFFQSxTQUFTNEIsV0FBV0wsZ0JBQWdCOzRCQUNoQyxPQUFPO2dDQUNILElBQUlNLHFCQUFxQjtnQ0FFekIsU0FBU0M7b0NBQ0wsTUFBT0QscUJBQXFCTixpQkFBaUJ4YixNQUFNLENBQUU7d0NBQ2pELElBQUk0WixhQUFhNEIsZ0JBQWdCLENBQUNNLG1CQUFtQjt3Q0FDckRBO3dDQUVBOWMsTUFBSzhPLE9BQU8sR0FBRzt3Q0FDZjlPLE1BQUtpYixNQUFNLEdBQUc7d0NBRWQsT0FBT2piLE1BQUttYyxTQUFTLENBQUN2QixZQUFZMVcsSUFBSSxDQUFDeVkscUJBQXFCLENBQUMsUUFBUSxDQUFDSTtvQ0FDMUU7b0NBRUFMO29DQUNBLElBQUlwWCxRQUFRLElBQUkxRSxNQUFNO29DQUN0QlosTUFBSythLFVBQVUsR0FBRzVSLFVBQVVyRSxNQUFNLENBQUNRO29DQUNuQyxPQUFPdEYsTUFBSythLFVBQVU7Z0NBQzFCO2dDQUVBLE9BQU9nQzs0QkFDWDt3QkFDSjt3QkFFQSxxREFBcUQ7d0JBQ3JELHdEQUF3RDt3QkFDeEQsZ0NBQWdDO3dCQUNoQyxJQUFJQyxtQkFBbUIsSUFBSSxDQUFDakMsVUFBVSxLQUFLLE9BQU8sSUFBSSxDQUFDQSxVQUFVLENBQUMsUUFBUSxDQUFDOzRCQUN2RSxPQUFPNVIsVUFBVXRFLE9BQU87d0JBQzVCLEtBQUtzRSxVQUFVdEUsT0FBTzt3QkFFdEIsSUFBSSxDQUFDa1csVUFBVSxHQUFHaUMsaUJBQWlCOVksSUFBSSxDQUFDOzRCQUNwQyxJQUFJMFcsYUFBYTRCLGdCQUFnQixDQUFDLEVBQUU7NEJBQ3BDeGMsTUFBSzhPLE9BQU8sR0FBRzs0QkFDZjlPLE1BQUtpYixNQUFNLEdBQUc7NEJBRWQsT0FBT2piLE1BQUttYyxTQUFTLENBQUN2QixZQUFZMVcsSUFBSSxDQUFDLFNBQVVnVyxNQUFNO2dDQUNuRGxhLE1BQUs4UixPQUFPLEdBQUdvSSxPQUFPcEksT0FBTztnQ0FDN0I0SztnQ0FDQTFjLE1BQUtrYiw0QkFBNEI7Z0NBQ2pDbGIsTUFBS2diLFdBQVcsR0FBRzZCLFdBQVdMOzRCQUNsQzt3QkFDSixFQUFFLENBQUMsUUFBUSxDQUFDOzRCQUNSRTs0QkFDQSxJQUFJcFgsUUFBUSxJQUFJMUUsTUFBTTs0QkFDdEJaLE1BQUsrYSxVQUFVLEdBQUc1UixVQUFVckUsTUFBTSxDQUFDUTs0QkFDbkMsT0FBT3RGLE1BQUsrYSxVQUFVO3dCQUMxQjt3QkFFQXpSLG9CQUFvQixJQUFJLENBQUN5UixVQUFVLEVBQUUxUixVQUFVRTt3QkFDL0MsT0FBTyxJQUFJLENBQUN3UixVQUFVO29CQUMxQjtvQkFFQUwsWUFBWTFXLFNBQVMsQ0FBQ2laLFFBQVEsR0FBRyxTQUFTQSxTQUFTckMsVUFBVTt3QkFDekQsT0FBTyxDQUFDLENBQUNwQixhQUFhLENBQUNvQixXQUFXO29CQUN0QztvQkFFQUYsWUFBWTFXLFNBQVMsQ0FBQzRZLE9BQU8sR0FBRyxTQUFTQSxRQUFRTSwyQkFBMkI7d0JBQ3hFM0MsT0FBTyxJQUFJLEVBQUUyQztvQkFDakI7b0JBRUF4QyxZQUFZMVcsU0FBUyxDQUFDeVksb0JBQW9CLEdBQUcsU0FBU0EscUJBQXFCRixPQUFPO3dCQUM5RSxJQUFJQyxtQkFBbUIsRUFBRTt3QkFDekIsSUFBSyxJQUFJN2IsSUFBSSxHQUFHc0MsTUFBTXNaLFFBQVF2YixNQUFNLEVBQUVMLElBQUlzQyxLQUFLdEMsSUFBSzs0QkFDaEQsSUFBSWlhLGFBQWEyQixPQUFPLENBQUM1YixFQUFFOzRCQUMzQixJQUFJLElBQUksQ0FBQ3NjLFFBQVEsQ0FBQ3JDLGFBQWE7Z0NBQzNCNEIsaUJBQWlCcFosSUFBSSxDQUFDd1g7NEJBQzFCO3dCQUNKO3dCQUNBLE9BQU80QjtvQkFDWDtvQkFFQTlCLFlBQVkxVyxTQUFTLENBQUNrWCw0QkFBNEIsR0FBRyxTQUFTQTt3QkFDMUQsb0VBQW9FO3dCQUNwRSxzRUFBc0U7d0JBQ3RFLGtFQUFrRTt3QkFDbEUsNkNBQTZDO3dCQUM3QyxJQUFLLElBQUl2YSxJQUFJLEdBQUdzQyxNQUFNOFcsZUFBZS9ZLE1BQU0sRUFBRUwsSUFBSXNDLEtBQUt0QyxJQUFLOzRCQUN2RHdaLGNBQWMsSUFBSSxFQUFFSixjQUFjLENBQUNwWixFQUFFO3dCQUN6QztvQkFDSjtvQkFFQStaLFlBQVkxVyxTQUFTLENBQUNtWixjQUFjLEdBQUcsU0FBU0EsZUFBZTNOLE9BQU87d0JBQ2xFLE9BQU8sSUFBSWtMLFlBQVlsTDtvQkFDM0I7b0JBRUEsT0FBT2tMO2dCQUNYO2dCQUVBLG9FQUFvRTtnQkFDcEUsa0VBQWtFO2dCQUdsRSxJQUFJMEMsaUJBQWlCLElBQUkxQztnQkFFekJoYixRQUFPRCxPQUFPLEdBQUcyZDtZQUVqQjtZQUFFO2dCQUFDLEtBQUk7WUFBQztTQUFFO0lBQUEsR0FBRSxDQUFDLEdBQUU7UUFBQztLQUFFLEVBQUU7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uaXJ2YWFuYWEtZWNvbW1lcmNlLy4vbm9kZV9tb2R1bGVzL2xvY2FsZm9yYWdlL2Rpc3QvbG9jYWxmb3JhZ2UuanM/Zjg5NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgICBsb2NhbEZvcmFnZSAtLSBPZmZsaW5lIFN0b3JhZ2UsIEltcHJvdmVkXG4gICAgVmVyc2lvbiAxLjEwLjBcbiAgICBodHRwczovL2xvY2FsZm9yYWdlLmdpdGh1Yi5pby9sb2NhbEZvcmFnZVxuICAgIChjKSAyMDEzLTIwMTcgTW96aWxsYSwgQXBhY2hlIExpY2Vuc2UgMi4wXG4qL1xuKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcubG9jYWxmb3JhZ2UgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgKGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIiwgZil9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG52YXIgTXV0YXRpb24gPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcblxudmFyIHNjaGVkdWxlRHJhaW47XG5cbntcbiAgaWYgKE11dGF0aW9uKSB7XG4gICAgdmFyIGNhbGxlZCA9IDA7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uKG5leHRUaWNrKTtcbiAgICB2YXIgZWxlbWVudCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsZW1lbnQuZGF0YSA9IChjYWxsZWQgPSArK2NhbGxlZCAlIDIpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoIWdsb2JhbC5zZXRJbW1lZGlhdGUgJiYgdHlwZW9mIGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgY2hhbm5lbCA9IG5ldyBnbG9iYWwuTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IG5leHRUaWNrO1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoJ2RvY3VtZW50JyBpbiBnbG9iYWwgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgdmFyIHNjcmlwdEVsID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0RWwub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXh0VGljaygpO1xuXG4gICAgICAgIHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIHNjcmlwdEVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0RWwpO1xuICAgICAgICBzY3JpcHRFbCA9IG51bGw7XG4gICAgICB9O1xuICAgICAgZ2xvYmFsLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHRFbCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGljaywgMCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgZHJhaW5pbmc7XG52YXIgcXVldWUgPSBbXTtcbi8vbmFtZWQgbmV4dFRpY2sgZm9yIGxlc3MgY29uZnVzaW5nIHN0YWNrIHRyYWNlc1xuZnVuY3Rpb24gbmV4dFRpY2soKSB7XG4gIGRyYWluaW5nID0gdHJ1ZTtcbiAgdmFyIGksIG9sZFF1ZXVlO1xuICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAobGVuKSB7XG4gICAgb2xkUXVldWUgPSBxdWV1ZTtcbiAgICBxdWV1ZSA9IFtdO1xuICAgIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICBvbGRRdWV1ZVtpXSgpO1xuICAgIH1cbiAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gIH1cbiAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbW1lZGlhdGU7XG5mdW5jdGlvbiBpbW1lZGlhdGUodGFzaykge1xuICBpZiAocXVldWUucHVzaCh0YXNrKSA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICBzY2hlZHVsZURyYWluKCk7XG4gIH1cbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcbnZhciBpbW1lZGlhdGUgPSBfZGVyZXFfKDEpO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gSU5URVJOQUwoKSB7fVxuXG52YXIgaGFuZGxlcnMgPSB7fTtcblxudmFyIFJFSkVDVEVEID0gWydSRUpFQ1RFRCddO1xudmFyIEZVTEZJTExFRCA9IFsnRlVMRklMTEVEJ107XG52YXIgUEVORElORyA9IFsnUEVORElORyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbmZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Jlc29sdmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHRoaXMuc3RhdGUgPSBQRU5ESU5HO1xuICB0aGlzLnF1ZXVlID0gW107XG4gIHRoaXMub3V0Y29tZSA9IHZvaWQgMDtcbiAgaWYgKHJlc29sdmVyICE9PSBJTlRFUk5BTCkge1xuICAgIHNhZmVseVJlc29sdmVUaGVuYWJsZSh0aGlzLCByZXNvbHZlcik7XG4gIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGVbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG59O1xuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICBpZiAodHlwZW9mIG9uRnVsZmlsbGVkICE9PSAnZnVuY3Rpb24nICYmIHRoaXMuc3RhdGUgPT09IEZVTEZJTExFRCB8fFxuICAgIHR5cGVvZiBvblJlamVjdGVkICE9PSAnZnVuY3Rpb24nICYmIHRoaXMuc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihJTlRFUk5BTCk7XG4gIGlmICh0aGlzLnN0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgdmFyIHJlc29sdmVyID0gdGhpcy5zdGF0ZSA9PT0gRlVMRklMTEVEID8gb25GdWxmaWxsZWQgOiBvblJlamVjdGVkO1xuICAgIHVud3JhcChwcm9taXNlLCByZXNvbHZlciwgdGhpcy5vdXRjb21lKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2gobmV3IFF1ZXVlSXRlbShwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuZnVuY3Rpb24gUXVldWVJdGVtKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gIGlmICh0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gb25GdWxmaWxsZWQ7XG4gICAgdGhpcy5jYWxsRnVsZmlsbGVkID0gdGhpcy5vdGhlckNhbGxGdWxmaWxsZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5vblJlamVjdGVkID0gb25SZWplY3RlZDtcbiAgICB0aGlzLmNhbGxSZWplY3RlZCA9IHRoaXMub3RoZXJDYWxsUmVqZWN0ZWQ7XG4gIH1cbn1cblF1ZXVlSXRlbS5wcm90b3R5cGUuY2FsbEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZXNvbHZlKHRoaXMucHJvbWlzZSwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUub3RoZXJDYWxsRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHVud3JhcCh0aGlzLnByb21pc2UsIHRoaXMub25GdWxmaWxsZWQsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLmNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZWplY3QodGhpcy5wcm9taXNlLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5vdGhlckNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB1bndyYXAodGhpcy5wcm9taXNlLCB0aGlzLm9uUmVqZWN0ZWQsIHZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIHVud3JhcChwcm9taXNlLCBmdW5jLCB2YWx1ZSkge1xuICBpbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuVmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGUpO1xuICAgIH1cbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IHByb21pc2UpIHtcbiAgICAgIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBuZXcgVHlwZUVycm9yKCdDYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHJldHVyblZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5oYW5kbGVycy5yZXNvbHZlID0gZnVuY3Rpb24gKHNlbGYsIHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0cnlDYXRjaChnZXRUaGVuLCB2YWx1ZSk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgcmV0dXJuIGhhbmRsZXJzLnJlamVjdChzZWxmLCByZXN1bHQudmFsdWUpO1xuICB9XG4gIHZhciB0aGVuYWJsZSA9IHJlc3VsdC52YWx1ZTtcblxuICBpZiAodGhlbmFibGUpIHtcbiAgICBzYWZlbHlSZXNvbHZlVGhlbmFibGUoc2VsZiwgdGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICAgc2VsZi5vdXRjb21lID0gdmFsdWU7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gc2VsZi5xdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgc2VsZi5xdWV1ZVtpXS5jYWxsRnVsZmlsbGVkKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuaGFuZGxlcnMucmVqZWN0ID0gZnVuY3Rpb24gKHNlbGYsIGVycm9yKSB7XG4gIHNlbGYuc3RhdGUgPSBSRUpFQ1RFRDtcbiAgc2VsZi5vdXRjb21lID0gZXJyb3I7XG4gIHZhciBpID0gLTE7XG4gIHZhciBsZW4gPSBzZWxmLnF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHNlbGYucXVldWVbaV0uY2FsbFJlamVjdGVkKGVycm9yKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn07XG5cbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gIC8vIE1ha2Ugc3VyZSB3ZSBvbmx5IGFjY2VzcyB0aGUgYWNjZXNzb3Igb25jZSBhcyByZXF1aXJlZCBieSB0aGUgc3BlY1xuICB2YXIgdGhlbiA9IG9iaiAmJiBvYmoudGhlbjtcbiAgaWYgKG9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYXBweVRoZW4oKSB7XG4gICAgICB0aGVuLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseVJlc29sdmVUaGVuYWJsZShzZWxmLCB0aGVuYWJsZSkge1xuICAvLyBFaXRoZXIgZnVsZmlsbCwgcmVqZWN0IG9yIHJlamVjdCB3aXRoIGVycm9yXG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25FcnJvcih2YWx1ZSkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBoYW5kbGVycy5yZWplY3Qoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25TdWNjZXNzKHZhbHVlKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGhhbmRsZXJzLnJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VG9VbndyYXAoKSB7XG4gICAgdGhlbmFibGUob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0cnlUb1Vud3JhcCk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgb25FcnJvcihyZXN1bHQudmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeUNhdGNoKGZ1bmMsIHZhbHVlKSB7XG4gIHZhciBvdXQgPSB7fTtcbiAgdHJ5IHtcbiAgICBvdXQudmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICBvdXQuc3RhdHVzID0gJ3N1Y2Nlc3MnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgb3V0LnN0YXR1cyA9ICdlcnJvcic7XG4gICAgb3V0LnZhbHVlID0gZTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5Qcm9taXNlLnJlc29sdmUgPSByZXNvbHZlO1xuZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiB0aGlzKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBoYW5kbGVycy5yZXNvbHZlKG5ldyB0aGlzKElOVEVSTkFMKSwgdmFsdWUpO1xufVxuXG5Qcm9taXNlLnJlamVjdCA9IHJlamVjdDtcbmZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcyhJTlRFUk5BTCk7XG4gIHJldHVybiBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbn1cblxuUHJvbWlzZS5hbGwgPSBhbGw7XG5mdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXJhYmxlKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJldHVybiB0aGlzLnJlamVjdChuZXcgVHlwZUVycm9yKCdtdXN0IGJlIGFuIGFycmF5JykpO1xuICB9XG5cbiAgdmFyIGxlbiA9IGl0ZXJhYmxlLmxlbmd0aDtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICBpZiAoIWxlbikge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmUoW10pO1xuICB9XG5cbiAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShsZW4pO1xuICB2YXIgcmVzb2x2ZWQgPSAwO1xuICB2YXIgaSA9IC0xO1xuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzKElOVEVSTkFMKTtcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgYWxsUmVzb2x2ZXIoaXRlcmFibGVbaV0sIGkpO1xuICB9XG4gIHJldHVybiBwcm9taXNlO1xuICBmdW5jdGlvbiBhbGxSZXNvbHZlcih2YWx1ZSwgaSkge1xuICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlRnJvbUFsbCwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHJlc29sdmVGcm9tQWxsKG91dFZhbHVlKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvdXRWYWx1ZTtcbiAgICAgIGlmICgrK3Jlc29sdmVkID09PSBsZW4gJiYgIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblByb21pc2UucmFjZSA9IHJhY2U7XG5mdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyYWJsZSkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3QobmV3IFR5cGVFcnJvcignbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBpdGVyYWJsZS5sZW5ndGg7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgaWYgKCFsZW4pIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlKFtdKTtcbiAgfVxuXG4gIHZhciBpID0gLTE7XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMoSU5URVJOQUwpO1xuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICByZXNvbHZlcihpdGVyYWJsZVtpXSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2U7XG4gIGZ1bmN0aW9uIHJlc29sdmVyKHZhbHVlKSB7XG4gICAgc2VsZi5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCByZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbn0se1wiMVwiOjF9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcbmlmICh0eXBlb2YgZ2xvYmFsLlByb21pc2UgIT09ICdmdW5jdGlvbicpIHtcbiAgZ2xvYmFsLlByb21pc2UgPSBfZGVyZXFfKDIpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiMlwiOjJ9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBnZXRJREIoKSB7XG4gICAgLyogZ2xvYmFsIGluZGV4ZWREQix3ZWJraXRJbmRleGVkREIsbW96SW5kZXhlZERCLE9JbmRleGVkREIsbXNJbmRleGVkREIgKi9cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGluZGV4ZWREQiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleGVkREI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3ZWJraXRJbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Via2l0SW5kZXhlZERCO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbW96SW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG1vekluZGV4ZWREQjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIE9JbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gT0luZGV4ZWREQjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG1zSW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG1zSW5kZXhlZERCO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuXG52YXIgaWRiID0gZ2V0SURCKCk7XG5cbmZ1bmN0aW9uIGlzSW5kZXhlZERCVmFsaWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBJbmRleGVkREI7IGZhbGwgYmFjayB0byB2ZW5kb3ItcHJlZml4ZWQgdmVyc2lvbnNcbiAgICAgICAgLy8gaWYgbmVlZGVkLlxuICAgICAgICBpZiAoIWlkYiB8fCAhaWRiLm9wZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBtaW1pYyBQb3VjaERCIGhlcmU7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIHRlc3QgZm9yIG9wZW5EYXRhYmFzZSBiZWNhdXNlIElFIE1vYmlsZSBpZGVudGlmaWVzIGl0c2VsZlxuICAgICAgICAvLyBhcyBTYWZhcmkuIE9oIHRoZSBsdWx6Li4uXG4gICAgICAgIHZhciBpc1NhZmFyaSA9IHR5cGVvZiBvcGVuRGF0YWJhc2UgIT09ICd1bmRlZmluZWQnICYmIC8oU2FmYXJpfGlQaG9uZXxpUGFkfGlQb2QpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEvQ2hyb21lLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEvQmxhY2tCZXJyeS8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuXG4gICAgICAgIHZhciBoYXNGZXRjaCA9IHR5cGVvZiBmZXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiBmZXRjaC50b1N0cmluZygpLmluZGV4T2YoJ1tuYXRpdmUgY29kZScpICE9PSAtMTtcblxuICAgICAgICAvLyBTYWZhcmkgPDEwLjEgZG9lcyBub3QgbWVldCBvdXIgcmVxdWlyZW1lbnRzIGZvciBJREIgc3VwcG9ydFxuICAgICAgICAvLyAoc2VlOiBodHRwczovL2dpdGh1Yi5jb20vcG91Y2hkYi9wb3VjaGRiL2lzc3Vlcy81NTcyKS5cbiAgICAgICAgLy8gU2FmYXJpIDEwLjEgc2hpcHBlZCB3aXRoIGZldGNoLCB3ZSBjYW4gdXNlIHRoYXQgdG8gZGV0ZWN0IGl0LlxuICAgICAgICAvLyBOb3RlOiB0aGlzIGNyZWF0ZXMgaXNzdWVzIHdpdGggYHdpbmRvdy5mZXRjaGAgcG9seWZpbGxzIGFuZFxuICAgICAgICAvLyBvdmVycmlkZXM7IHNlZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xvY2FsRm9yYWdlL2xvY2FsRm9yYWdlL2lzc3Vlcy84NTZcbiAgICAgICAgcmV0dXJuICghaXNTYWZhcmkgfHwgaGFzRmV0Y2gpICYmIHR5cGVvZiBpbmRleGVkREIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIC8vIHNvbWUgb3V0ZGF0ZWQgaW1wbGVtZW50YXRpb25zIG9mIElEQiB0aGF0IGFwcGVhciBvbiBTYW1zdW5nXG4gICAgICAgIC8vIGFuZCBIVEMgQW5kcm9pZCBkZXZpY2VzIDw0LjQgYXJlIG1pc3NpbmcgSURCS2V5UmFuZ2VcbiAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9sb2NhbEZvcmFnZS9pc3N1ZXMvMTI4XG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvbG9jYWxGb3JhZ2UvaXNzdWVzLzI3MlxuICAgICAgICB0eXBlb2YgSURCS2V5UmFuZ2UgIT09ICd1bmRlZmluZWQnO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLy8gQWJzdHJhY3RzIGNvbnN0cnVjdGluZyBhIEJsb2Igb2JqZWN0LCBzbyBpdCBhbHNvIHdvcmtzIGluIG9sZGVyXG4vLyBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlIG5hdGl2ZSBCbG9iIGNvbnN0cnVjdG9yLiAoaS5lLlxuLy8gb2xkIFF0V2ViS2l0IHZlcnNpb25zLCBhdCBsZWFzdCkuXG4vLyBBYnN0cmFjdHMgY29uc3RydWN0aW5nIGEgQmxvYiBvYmplY3QsIHNvIGl0IGFsc28gd29ya3MgaW4gb2xkZXJcbi8vIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0aGUgbmF0aXZlIEJsb2IgY29uc3RydWN0b3IuIChpLmUuXG4vLyBvbGQgUXRXZWJLaXQgdmVyc2lvbnMsIGF0IGxlYXN0KS5cbmZ1bmN0aW9uIGNyZWF0ZUJsb2IocGFydHMsIHByb3BlcnRpZXMpIHtcbiAgICAvKiBnbG9iYWwgQmxvYkJ1aWxkZXIsTVNCbG9iQnVpbGRlcixNb3pCbG9iQnVpbGRlcixXZWJLaXRCbG9iQnVpbGRlciAqL1xuICAgIHBhcnRzID0gcGFydHMgfHwgW107XG4gICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKHBhcnRzLCBwcm9wZXJ0aWVzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLm5hbWUgIT09ICdUeXBlRXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBCdWlsZGVyID0gdHlwZW9mIEJsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJyA/IEJsb2JCdWlsZGVyIDogdHlwZW9mIE1TQmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gTVNCbG9iQnVpbGRlciA6IHR5cGVvZiBNb3pCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBNb3pCbG9iQnVpbGRlciA6IFdlYktpdEJsb2JCdWlsZGVyO1xuICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGJ1aWxkZXIuYXBwZW5kKHBhcnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5nZXRCbG9iKHByb3BlcnRpZXMudHlwZSk7XG4gICAgfVxufVxuXG4vLyBUaGlzIGlzIENvbW1vbkpTIGJlY2F1c2UgbGllIGlzIGFuIGV4dGVybmFsIGRlcGVuZGVuY3ksIHNvIFJvbGx1cFxuLy8gY2FuIGp1c3QgaWdub3JlIGl0LlxuaWYgKHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEluIHRoZSBcIm5vcHJvbWlzZXNcIiBidWlsZCB0aGlzIHdpbGwganVzdCB0aHJvdyBpZiB5b3UgZG9uJ3QgaGF2ZVxuICAgIC8vIGEgZ2xvYmFsIHByb21pc2Ugb2JqZWN0LCBidXQgaXQgd291bGQgdGhyb3cgYW55d2F5IGxhdGVyLlxuICAgIF9kZXJlcV8oMyk7XG59XG52YXIgUHJvbWlzZSQxID0gUHJvbWlzZTtcblxuZnVuY3Rpb24gZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBleGVjdXRlVHdvQ2FsbGJhY2tzKHByb21pc2UsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9taXNlLnRoZW4oY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZXJyb3JDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9taXNlW1wiY2F0Y2hcIl0oZXJyb3JDYWxsYmFjayk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVLZXkoa2V5KSB7XG4gICAgLy8gQ2FzdCB0aGUga2V5IHRvIGEgc3RyaW5nLCBhcyB0aGF0J3MgYWxsIHdlIGNhbiBzZXQgYXMgYSBrZXkuXG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihrZXkgKyAnIHVzZWQgYXMgYSBrZXksIGJ1dCBpdCBpcyBub3QgYSBzdHJpbmcuJyk7XG4gICAgICAgIGtleSA9IFN0cmluZyhrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBrZXk7XG59XG5cbmZ1bmN0aW9uIGdldENhbGxiYWNrKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICYmIHR5cGVvZiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbn1cblxuLy8gU29tZSBjb2RlIG9yaWdpbmFsbHkgZnJvbSBhc3luY19zdG9yYWdlLmpzIGluXG4vLyBbR2FpYV0oaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEtYjJnL2dhaWEpLlxuXG52YXIgREVURUNUX0JMT0JfU1VQUE9SVF9TVE9SRSA9ICdsb2NhbC1mb3JhZ2UtZGV0ZWN0LWJsb2Itc3VwcG9ydCc7XG52YXIgc3VwcG9ydHNCbG9icyA9IHZvaWQgMDtcbnZhciBkYkNvbnRleHRzID0ge307XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vLyBUcmFuc2FjdGlvbiBNb2Rlc1xudmFyIFJFQURfT05MWSA9ICdyZWFkb25seSc7XG52YXIgUkVBRF9XUklURSA9ICdyZWFkd3JpdGUnO1xuXG4vLyBUcmFuc2Zvcm0gYSBiaW5hcnkgc3RyaW5nIHRvIGFuIGFycmF5IGJ1ZmZlciwgYmVjYXVzZSBvdGhlcndpc2Vcbi8vIHdlaXJkIHN0dWZmIGhhcHBlbnMgd2hlbiB5b3UgdHJ5IHRvIHdvcmsgd2l0aCB0aGUgYmluYXJ5IHN0cmluZyBkaXJlY3RseS5cbi8vIEl0IGlzIGtub3duLlxuLy8gRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE0OTY3NjQ3LyAoY29udGludWVzIG9uIG5leHQgbGluZSlcbi8vIGVuY29kZS1kZWNvZGUtaW1hZ2Utd2l0aC1iYXNlNjQtYnJlYWtzLWltYWdlICgyMDEzLTA0LTIxKVxuZnVuY3Rpb24gX2JpblN0cmluZ1RvQXJyYXlCdWZmZXIoYmluKSB7XG4gICAgdmFyIGxlbmd0aCA9IGJpbi5sZW5ndGg7XG4gICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihsZW5ndGgpO1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59XG5cbi8vXG4vLyBCbG9icyBhcmUgbm90IHN1cHBvcnRlZCBpbiBhbGwgdmVyc2lvbnMgb2YgSW5kZXhlZERCLCBub3RhYmx5XG4vLyBDaHJvbWUgPDM3IGFuZCBBbmRyb2lkIDw1LiBJbiB0aG9zZSB2ZXJzaW9ucywgc3RvcmluZyBhIGJsb2Igd2lsbCB0aHJvdy5cbi8vXG4vLyBWYXJpb3VzIG90aGVyIGJsb2IgYnVncyBleGlzdCBpbiBDaHJvbWUgdjM3LTQyIChpbmNsdXNpdmUpLlxuLy8gRGV0ZWN0aW5nIHRoZW0gaXMgZXhwZW5zaXZlIGFuZCBjb25mdXNpbmcgdG8gdXNlcnMsIGFuZCBDaHJvbWUgMzctNDJcbi8vIGlzIGF0IHZlcnkgbG93IHVzYWdlIHdvcmxkd2lkZSwgc28gd2UgZG8gYSBoYWNreSB1c2VyQWdlbnQgY2hlY2sgaW5zdGVhZC5cbi8vXG4vLyBjb250ZW50LXR5cGUgYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDA4MTIwXG4vLyA0MDQgYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ3OTE2XG4vLyBGaWxlUmVhZGVyIGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NzgzNlxuLy9cbi8vIENvZGUgYm9ycm93ZWQgZnJvbSBQb3VjaERCLiBTZWU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vcG91Y2hkYi9wb3VjaGRiL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL25vZGVfbW9kdWxlcy9wb3VjaGRiLWFkYXB0ZXItaWRiL3NyYy9ibG9iU3VwcG9ydC5qc1xuLy9cbmZ1bmN0aW9uIF9jaGVja0Jsb2JTdXBwb3J0V2l0aG91dENhY2hpbmcoaWRiKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgdmFyIHR4biA9IGlkYi50cmFuc2FjdGlvbihERVRFQ1RfQkxPQl9TVVBQT1JUX1NUT1JFLCBSRUFEX1dSSVRFKTtcbiAgICAgICAgdmFyIGJsb2IgPSBjcmVhdGVCbG9iKFsnJ10pO1xuICAgICAgICB0eG4ub2JqZWN0U3RvcmUoREVURUNUX0JMT0JfU1VQUE9SVF9TVE9SRSkucHV0KGJsb2IsICdrZXknKTtcblxuICAgICAgICB0eG4ub25hYm9ydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdHJhbnNhY3Rpb24gYWJvcnRzIG5vdyBpdHMgZHVlIHRvIG5vdCBiZWluZyBhYmxlIHRvXG4gICAgICAgICAgICAvLyB3cml0ZSB0byB0aGUgZGF0YWJhc2UsIGxpa2VseSBkdWUgdG8gdGhlIGRpc2sgYmVpbmcgZnVsbFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHR4bi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZWRDaHJvbWUgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkRWRnZSA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0VkZ2VcXC8vKTtcbiAgICAgICAgICAgIC8vIE1TIEVkZ2UgcHJldGVuZHMgdG8gYmUgQ2hyb21lIDQyOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9oaDg2OTMwMSUyOHY9dnMuODUlMjkuYXNweFxuICAgICAgICAgICAgcmVzb2x2ZShtYXRjaGVkRWRnZSB8fCAhbWF0Y2hlZENocm9tZSB8fCBwYXJzZUludChtYXRjaGVkQ2hyb21lWzFdLCAxMCkgPj0gNDMpO1xuICAgICAgICB9O1xuICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGVycm9yLCBzbyBhc3N1bWUgdW5zdXBwb3J0ZWRcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gX2NoZWNrQmxvYlN1cHBvcnQoaWRiKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBwb3J0c0Jsb2JzID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UkMS5yZXNvbHZlKHN1cHBvcnRzQmxvYnMpO1xuICAgIH1cbiAgICByZXR1cm4gX2NoZWNrQmxvYlN1cHBvcnRXaXRob3V0Q2FjaGluZyhpZGIpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHN1cHBvcnRzQmxvYnMgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRzQmxvYnM7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9kZWZlclJlYWRpbmVzcyhkYkluZm8pIHtcbiAgICB2YXIgZGJDb250ZXh0ID0gZGJDb250ZXh0c1tkYkluZm8ubmFtZV07XG5cbiAgICAvLyBDcmVhdGUgYSBkZWZlcnJlZCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IGRhdGFiYXNlIG9wZXJhdGlvbi5cbiAgICB2YXIgZGVmZXJyZWRPcGVyYXRpb24gPSB7fTtcblxuICAgIGRlZmVycmVkT3BlcmF0aW9uLnByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZGVmZXJyZWRPcGVyYXRpb24ucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIGRlZmVycmVkT3BlcmF0aW9uLnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIC8vIEVucXVldWUgdGhlIGRlZmVycmVkIG9wZXJhdGlvbi5cbiAgICBkYkNvbnRleHQuZGVmZXJyZWRPcGVyYXRpb25zLnB1c2goZGVmZXJyZWRPcGVyYXRpb24pO1xuXG4gICAgLy8gQ2hhaW4gaXRzIHByb21pc2UgdG8gdGhlIGRhdGFiYXNlIHJlYWRpbmVzcy5cbiAgICBpZiAoIWRiQ29udGV4dC5kYlJlYWR5KSB7XG4gICAgICAgIGRiQ29udGV4dC5kYlJlYWR5ID0gZGVmZXJyZWRPcGVyYXRpb24ucHJvbWlzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkYkNvbnRleHQuZGJSZWFkeSA9IGRiQ29udGV4dC5kYlJlYWR5LnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkT3BlcmF0aW9uLnByb21pc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX2FkdmFuY2VSZWFkaW5lc3MoZGJJbmZvKSB7XG4gICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbZGJJbmZvLm5hbWVdO1xuXG4gICAgLy8gRGVxdWV1ZSBhIGRlZmVycmVkIG9wZXJhdGlvbi5cbiAgICB2YXIgZGVmZXJyZWRPcGVyYXRpb24gPSBkYkNvbnRleHQuZGVmZXJyZWRPcGVyYXRpb25zLnBvcCgpO1xuXG4gICAgLy8gUmVzb2x2ZSBpdHMgcHJvbWlzZSAod2hpY2ggaXMgcGFydCBvZiB0aGUgZGF0YWJhc2UgcmVhZGluZXNzXG4gICAgLy8gY2hhaW4gb2YgcHJvbWlzZXMpLlxuICAgIGlmIChkZWZlcnJlZE9wZXJhdGlvbikge1xuICAgICAgICBkZWZlcnJlZE9wZXJhdGlvbi5yZXNvbHZlKCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZE9wZXJhdGlvbi5wcm9taXNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX3JlamVjdFJlYWRpbmVzcyhkYkluZm8sIGVycikge1xuICAgIHZhciBkYkNvbnRleHQgPSBkYkNvbnRleHRzW2RiSW5mby5uYW1lXTtcblxuICAgIC8vIERlcXVldWUgYSBkZWZlcnJlZCBvcGVyYXRpb24uXG4gICAgdmFyIGRlZmVycmVkT3BlcmF0aW9uID0gZGJDb250ZXh0LmRlZmVycmVkT3BlcmF0aW9ucy5wb3AoKTtcblxuICAgIC8vIFJlamVjdCBpdHMgcHJvbWlzZSAod2hpY2ggaXMgcGFydCBvZiB0aGUgZGF0YWJhc2UgcmVhZGluZXNzXG4gICAgLy8gY2hhaW4gb2YgcHJvbWlzZXMpLlxuICAgIGlmIChkZWZlcnJlZE9wZXJhdGlvbikge1xuICAgICAgICBkZWZlcnJlZE9wZXJhdGlvbi5yZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkT3BlcmF0aW9uLnByb21pc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0Q29ubmVjdGlvbihkYkluZm8sIHVwZ3JhZGVOZWVkZWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGRiQ29udGV4dHNbZGJJbmZvLm5hbWVdID0gZGJDb250ZXh0c1tkYkluZm8ubmFtZV0gfHwgY3JlYXRlRGJDb250ZXh0KCk7XG5cbiAgICAgICAgaWYgKGRiSW5mby5kYikge1xuICAgICAgICAgICAgaWYgKHVwZ3JhZGVOZWVkZWQpIHtcbiAgICAgICAgICAgICAgICBfZGVmZXJSZWFkaW5lc3MoZGJJbmZvKTtcbiAgICAgICAgICAgICAgICBkYkluZm8uZGIuY2xvc2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZGJJbmZvLmRiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYkFyZ3MgPSBbZGJJbmZvLm5hbWVdO1xuXG4gICAgICAgIGlmICh1cGdyYWRlTmVlZGVkKSB7XG4gICAgICAgICAgICBkYkFyZ3MucHVzaChkYkluZm8udmVyc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3BlbnJlcSA9IGlkYi5vcGVuLmFwcGx5KGlkYiwgZGJBcmdzKTtcblxuICAgICAgICBpZiAodXBncmFkZU5lZWRlZCkge1xuICAgICAgICAgICAgb3BlbnJlcS5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBkYiA9IG9wZW5yZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKGRiSW5mby5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5vbGRWZXJzaW9uIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZGVkIHdoZW4gc3VwcG9ydCBmb3IgYmxvYiBzaGltcyB3YXMgYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERFVEVDVF9CTE9CX1NVUFBPUlRfU1RPUkUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4Lm5hbWUgPT09ICdDb25zdHJhaW50RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBkYXRhYmFzZSBcIicgKyBkYkluZm8ubmFtZSArICdcIicgKyAnIGhhcyBiZWVuIHVwZ3JhZGVkIGZyb20gdmVyc2lvbiAnICsgZS5vbGRWZXJzaW9uICsgJyB0byB2ZXJzaW9uICcgKyBlLm5ld1ZlcnNpb24gKyAnLCBidXQgdGhlIHN0b3JhZ2UgXCInICsgZGJJbmZvLnN0b3JlTmFtZSArICdcIiBhbHJlYWR5IGV4aXN0cy4nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wZW5yZXEub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZWplY3Qob3BlbnJlcS5lcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgb3BlbnJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGIgPSBvcGVucmVxLnJlc3VsdDtcbiAgICAgICAgICAgIGRiLm9udmVyc2lvbmNoYW5nZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJpZ2dlcmVkIHdoZW4gdGhlIGRhdGFiYXNlIGlzIG1vZGlmaWVkIChlLmcuIGFkZGluZyBhbiBvYmplY3RTdG9yZSkgb3JcbiAgICAgICAgICAgICAgICAvLyBkZWxldGVkIChldmVuIHdoZW4gaW5pdGlhdGVkIGJ5IG90aGVyIHNlc3Npb25zIGluIGRpZmZlcmVudCB0YWJzKS5cbiAgICAgICAgICAgICAgICAvLyBDbG9zaW5nIHRoZSBjb25uZWN0aW9uIGhlcmUgcHJldmVudHMgdGhvc2Ugb3BlcmF0aW9ucyBmcm9tIGJlaW5nIGJsb2NrZWQuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRhdGFiYXNlIGlzIGFjY2Vzc2VkIGFnYWluIGxhdGVyIGJ5IHRoaXMgaW5zdGFuY2UsIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBiZSByZW9wZW5lZCBvciB0aGUgZGF0YWJhc2UgcmVjcmVhdGVkIGFzIG5lZWRlZC5cbiAgICAgICAgICAgICAgICBlLnRhcmdldC5jbG9zZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc29sdmUoZGIpO1xuICAgICAgICAgICAgX2FkdmFuY2VSZWFkaW5lc3MoZGJJbmZvKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gX2dldE9yaWdpbmFsQ29ubmVjdGlvbihkYkluZm8pIHtcbiAgICByZXR1cm4gX2dldENvbm5lY3Rpb24oZGJJbmZvLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIF9nZXRVcGdyYWRlZENvbm5lY3Rpb24oZGJJbmZvKSB7XG4gICAgcmV0dXJuIF9nZXRDb25uZWN0aW9uKGRiSW5mbywgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIF9pc1VwZ3JhZGVOZWVkZWQoZGJJbmZvLCBkZWZhdWx0VmVyc2lvbikge1xuICAgIGlmICghZGJJbmZvLmRiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpc05ld1N0b3JlID0gIWRiSW5mby5kYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKGRiSW5mby5zdG9yZU5hbWUpO1xuICAgIHZhciBpc0Rvd25ncmFkZSA9IGRiSW5mby52ZXJzaW9uIDwgZGJJbmZvLmRiLnZlcnNpb247XG4gICAgdmFyIGlzVXBncmFkZSA9IGRiSW5mby52ZXJzaW9uID4gZGJJbmZvLmRiLnZlcnNpb247XG5cbiAgICBpZiAoaXNEb3duZ3JhZGUpIHtcbiAgICAgICAgLy8gSWYgdGhlIHZlcnNpb24gaXMgbm90IHRoZSBkZWZhdWx0IG9uZVxuICAgICAgICAvLyB0aGVuIHdhcm4gZm9yIGltcG9zc2libGUgZG93bmdyYWRlLlxuICAgICAgICBpZiAoZGJJbmZvLnZlcnNpb24gIT09IGRlZmF1bHRWZXJzaW9uKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBkYXRhYmFzZSBcIicgKyBkYkluZm8ubmFtZSArICdcIicgKyBcIiBjYW4ndCBiZSBkb3duZ3JhZGVkIGZyb20gdmVyc2lvbiBcIiArIGRiSW5mby5kYi52ZXJzaW9uICsgJyB0byB2ZXJzaW9uICcgKyBkYkluZm8udmVyc2lvbiArICcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxpZ24gdGhlIHZlcnNpb25zIHRvIHByZXZlbnQgZXJyb3JzLlxuICAgICAgICBkYkluZm8udmVyc2lvbiA9IGRiSW5mby5kYi52ZXJzaW9uO1xuICAgIH1cblxuICAgIGlmIChpc1VwZ3JhZGUgfHwgaXNOZXdTdG9yZSkge1xuICAgICAgICAvLyBJZiB0aGUgc3RvcmUgaXMgbmV3IHRoZW4gaW5jcmVtZW50IHRoZSB2ZXJzaW9uIChpZiBuZWVkZWQpLlxuICAgICAgICAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhbiBcInVwZ3JhZGVuZWVkZWRcIiBldmVudCB3aGljaCBpcyByZXF1aXJlZFxuICAgICAgICAvLyBmb3IgY3JlYXRpbmcgYSBzdG9yZS5cbiAgICAgICAgaWYgKGlzTmV3U3RvcmUpIHtcbiAgICAgICAgICAgIHZhciBpbmNWZXJzaW9uID0gZGJJbmZvLmRiLnZlcnNpb24gKyAxO1xuICAgICAgICAgICAgaWYgKGluY1ZlcnNpb24gPiBkYkluZm8udmVyc2lvbikge1xuICAgICAgICAgICAgICAgIGRiSW5mby52ZXJzaW9uID0gaW5jVmVyc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gZW5jb2RlIGEgYmxvYiBmb3IgaW5kZXhlZGRiIGVuZ2luZXMgdGhhdCBkb24ndCBzdXBwb3J0IGJsb2JzXG5mdW5jdGlvbiBfZW5jb2RlQmxvYihibG9iKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGJhc2U2NCA9IGJ0b2EoZS50YXJnZXQucmVzdWx0IHx8ICcnKTtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgIF9fbG9jYWxfZm9yYWdlX2VuY29kZWRfYmxvYjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBiYXNlNjQsXG4gICAgICAgICAgICAgICAgdHlwZTogYmxvYi50eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0JpbmFyeVN0cmluZyhibG9iKTtcbiAgICB9KTtcbn1cblxuLy8gZGVjb2RlIGFuIGVuY29kZWQgYmxvYlxuZnVuY3Rpb24gX2RlY29kZUJsb2IoZW5jb2RlZEJsb2IpIHtcbiAgICB2YXIgYXJyYXlCdWZmID0gX2JpblN0cmluZ1RvQXJyYXlCdWZmZXIoYXRvYihlbmNvZGVkQmxvYi5kYXRhKSk7XG4gICAgcmV0dXJuIGNyZWF0ZUJsb2IoW2FycmF5QnVmZl0sIHsgdHlwZTogZW5jb2RlZEJsb2IudHlwZSB9KTtcbn1cblxuLy8gaXMgdGhpcyBvbmUgb2Ygb3VyIGZhbmN5IGVuY29kZWQgYmxvYnM/XG5mdW5jdGlvbiBfaXNFbmNvZGVkQmxvYih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5fX2xvY2FsX2ZvcmFnZV9lbmNvZGVkX2Jsb2I7XG59XG5cbi8vIFNwZWNpYWxpemUgdGhlIGRlZmF1bHQgYHJlYWR5KClgIGZ1bmN0aW9uIGJ5IG1ha2luZyBpdCBkZXBlbmRlbnRcbi8vIG9uIHRoZSBjdXJyZW50IGRhdGFiYXNlIG9wZXJhdGlvbnMuIFRodXMsIHRoZSBkcml2ZXIgd2lsbCBiZSBhY3R1YWxseVxuLy8gcmVhZHkgd2hlbiBpdCdzIGJlZW4gaW5pdGlhbGl6ZWQgKGRlZmF1bHQpICphbmQqIHRoZXJlIGFyZSBubyBwZW5kaW5nXG4vLyBvcGVyYXRpb25zIG9uIHRoZSBkYXRhYmFzZSAoaW5pdGlhdGVkIGJ5IHNvbWUgb3RoZXIgaW5zdGFuY2VzKS5cbmZ1bmN0aW9uIF9mdWxseVJlYWR5KGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBzZWxmLl9pbml0UmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbc2VsZi5fZGJJbmZvLm5hbWVdO1xuXG4gICAgICAgIGlmIChkYkNvbnRleHQgJiYgZGJDb250ZXh0LmRiUmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYkNvbnRleHQuZGJSZWFkeTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZXhlY3V0ZVR3b0NhbGxiYWNrcyhwcm9taXNlLCBjYWxsYmFjaywgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBUcnkgdG8gZXN0YWJsaXNoIGEgbmV3IGRiIGNvbm5lY3Rpb24gdG8gcmVwbGFjZSB0aGVcbi8vIGN1cnJlbnQgb25lIHdoaWNoIGlzIGJyb2tlbiAoaS5lLiBleHBlcmllbmNpbmdcbi8vIEludmFsaWRTdGF0ZUVycm9yIHdoaWxlIGNyZWF0aW5nIGEgdHJhbnNhY3Rpb24pLlxuZnVuY3Rpb24gX3RyeVJlY29ubmVjdChkYkluZm8pIHtcbiAgICBfZGVmZXJSZWFkaW5lc3MoZGJJbmZvKTtcblxuICAgIHZhciBkYkNvbnRleHQgPSBkYkNvbnRleHRzW2RiSW5mby5uYW1lXTtcbiAgICB2YXIgZm9yYWdlcyA9IGRiQ29udGV4dC5mb3JhZ2VzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmb3JhZ2UgPSBmb3JhZ2VzW2ldO1xuICAgICAgICBpZiAoZm9yYWdlLl9kYkluZm8uZGIpIHtcbiAgICAgICAgICAgIGZvcmFnZS5fZGJJbmZvLmRiLmNsb3NlKCk7XG4gICAgICAgICAgICBmb3JhZ2UuX2RiSW5mby5kYiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGJJbmZvLmRiID0gbnVsbDtcblxuICAgIHJldHVybiBfZ2V0T3JpZ2luYWxDb25uZWN0aW9uKGRiSW5mbykudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgZGJJbmZvLmRiID0gZGI7XG4gICAgICAgIGlmIChfaXNVcGdyYWRlTmVlZGVkKGRiSW5mbykpIHtcbiAgICAgICAgICAgIC8vIFJlb3BlbiB0aGUgZGF0YWJhc2UgZm9yIHVwZ3JhZGluZy5cbiAgICAgICAgICAgIHJldHVybiBfZ2V0VXBncmFkZWRDb25uZWN0aW9uKGRiSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRiO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgIC8vIHN0b3JlIHRoZSBsYXRlc3QgZGIgcmVmZXJlbmNlXG4gICAgICAgIC8vIGluIGNhc2UgdGhlIGRiIHdhcyB1cGdyYWRlZFxuICAgICAgICBkYkluZm8uZGIgPSBkYkNvbnRleHQuZGIgPSBkYjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3JhZ2VzW2ldLl9kYkluZm8uZGIgPSBkYjtcbiAgICAgICAgfVxuICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBfcmVqZWN0UmVhZGluZXNzKGRiSW5mbywgZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xufVxuXG4vLyBGRiBkb2Vzbid0IGxpa2UgUHJvbWlzZXMgKG1pY3JvLXRhc2tzKSBhbmQgSUREQiBzdG9yZSBvcGVyYXRpb25zLFxuLy8gc28gd2UgaGF2ZSB0byBkbyBpdCB3aXRoIGNhbGxiYWNrc1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb24oZGJJbmZvLCBtb2RlLCBjYWxsYmFjaywgcmV0cmllcykge1xuICAgIGlmIChyZXRyaWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0cmllcyA9IDE7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHR4ID0gZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGRiSW5mby5zdG9yZU5hbWUsIG1vZGUpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCB0eCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChyZXRyaWVzID4gMCAmJiAoIWRiSW5mby5kYiB8fCBlcnIubmFtZSA9PT0gJ0ludmFsaWRTdGF0ZUVycm9yJyB8fCBlcnIubmFtZSA9PT0gJ05vdEZvdW5kRXJyb3InKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UkMS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkYkluZm8uZGIgfHwgZXJyLm5hbWUgPT09ICdOb3RGb3VuZEVycm9yJyAmJiAhZGJJbmZvLmRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoZGJJbmZvLnN0b3JlTmFtZSkgJiYgZGJJbmZvLnZlcnNpb24gPD0gZGJJbmZvLmRiLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGRiIHZlcnNpb24sIHRvIGNyZWF0ZSB0aGUgbmV3IE9iamVjdFN0b3JlXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYkluZm8uZGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiSW5mby52ZXJzaW9uID0gZGJJbmZvLmRiLnZlcnNpb24gKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlb3BlbiB0aGUgZGF0YWJhc2UgZm9yIHVwZ3JhZGluZy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRVcGdyYWRlZENvbm5lY3Rpb24oZGJJbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RyeVJlY29ubmVjdChkYkluZm8pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVUcmFuc2FjdGlvbihkYkluZm8sIG1vZGUsIGNhbGxiYWNrLCByZXRyaWVzIC0gMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVtcImNhdGNoXCJdKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEYkNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gUnVubmluZyBsb2NhbEZvcmFnZXMgc2hhcmluZyBhIGRhdGFiYXNlLlxuICAgICAgICBmb3JhZ2VzOiBbXSxcbiAgICAgICAgLy8gU2hhcmVkIGRhdGFiYXNlLlxuICAgICAgICBkYjogbnVsbCxcbiAgICAgICAgLy8gRGF0YWJhc2UgcmVhZGluZXNzIChwcm9taXNlKS5cbiAgICAgICAgZGJSZWFkeTogbnVsbCxcbiAgICAgICAgLy8gRGVmZXJyZWQgb3BlcmF0aW9ucyBvbiB0aGUgZGF0YWJhc2UuXG4gICAgICAgIGRlZmVycmVkT3BlcmF0aW9uczogW11cbiAgICB9O1xufVxuXG4vLyBPcGVuIHRoZSBJbmRleGVkREIgZGF0YWJhc2UgKGF1dG9tYXRpY2FsbHkgY3JlYXRlcyBvbmUgaWYgb25lIGRpZG4ndFxuLy8gcHJldmlvdXNseSBleGlzdCksIHVzaW5nIGFueSBvcHRpb25zIHNldCBpbiB0aGUgY29uZmlnLlxuZnVuY3Rpb24gX2luaXRTdG9yYWdlKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRiSW5mbyA9IHtcbiAgICAgICAgZGI6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBkYkluZm9baV0gPSBvcHRpb25zW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IGNvbnRleHQgb2YgdGhlIGRhdGFiYXNlO1xuICAgIHZhciBkYkNvbnRleHQgPSBkYkNvbnRleHRzW2RiSW5mby5uYW1lXTtcblxuICAgIC8vIC4uLm9yIGNyZWF0ZSBhIG5ldyBjb250ZXh0LlxuICAgIGlmICghZGJDb250ZXh0KSB7XG4gICAgICAgIGRiQ29udGV4dCA9IGNyZWF0ZURiQ29udGV4dCgpO1xuICAgICAgICAvLyBSZWdpc3RlciB0aGUgbmV3IGNvbnRleHQgaW4gdGhlIGdsb2JhbCBjb250YWluZXIuXG4gICAgICAgIGRiQ29udGV4dHNbZGJJbmZvLm5hbWVdID0gZGJDb250ZXh0O1xuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyIGl0c2VsZiBhcyBhIHJ1bm5pbmcgbG9jYWxGb3JhZ2UgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICBkYkNvbnRleHQuZm9yYWdlcy5wdXNoKHNlbGYpO1xuXG4gICAgLy8gUmVwbGFjZSB0aGUgZGVmYXVsdCBgcmVhZHkoKWAgZnVuY3Rpb24gd2l0aCB0aGUgc3BlY2lhbGl6ZWQgb25lLlxuICAgIGlmICghc2VsZi5faW5pdFJlYWR5KSB7XG4gICAgICAgIHNlbGYuX2luaXRSZWFkeSA9IHNlbGYucmVhZHk7XG4gICAgICAgIHNlbGYucmVhZHkgPSBfZnVsbHlSZWFkeTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYW4gYXJyYXkgb2YgaW5pdGlhbGl6YXRpb24gc3RhdGVzIG9mIHRoZSByZWxhdGVkIGxvY2FsRm9yYWdlcy5cbiAgICB2YXIgaW5pdFByb21pc2VzID0gW107XG5cbiAgICBmdW5jdGlvbiBpZ25vcmVFcnJvcnMoKSB7XG4gICAgICAgIC8vIERvbid0IGhhbmRsZSBlcnJvcnMgaGVyZSxcbiAgICAgICAgLy8ganVzdCBtYWtlcyBzdXJlIHJlbGF0ZWQgbG9jYWxGb3JhZ2VzIGFyZW4ndCBwZW5kaW5nLlxuICAgICAgICByZXR1cm4gUHJvbWlzZSQxLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRiQ29udGV4dC5mb3JhZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBmb3JhZ2UgPSBkYkNvbnRleHQuZm9yYWdlc1tqXTtcbiAgICAgICAgaWYgKGZvcmFnZSAhPT0gc2VsZikge1xuICAgICAgICAgICAgLy8gRG9uJ3Qgd2FpdCBmb3IgaXRzZWxmLi4uXG4gICAgICAgICAgICBpbml0UHJvbWlzZXMucHVzaChmb3JhZ2UuX2luaXRSZWFkeSgpW1wiY2F0Y2hcIl0oaWdub3JlRXJyb3JzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUYWtlIGEgc25hcHNob3Qgb2YgdGhlIHJlbGF0ZWQgbG9jYWxGb3JhZ2VzLlxuICAgIHZhciBmb3JhZ2VzID0gZGJDb250ZXh0LmZvcmFnZXMuc2xpY2UoMCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBjb25uZWN0aW9uIHByb2Nlc3Mgb25seSB3aGVuXG4gICAgLy8gYWxsIHRoZSByZWxhdGVkIGxvY2FsRm9yYWdlcyBhcmVuJ3QgcGVuZGluZy5cbiAgICByZXR1cm4gUHJvbWlzZSQxLmFsbChpbml0UHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBkYkluZm8uZGIgPSBkYkNvbnRleHQuZGI7XG4gICAgICAgIC8vIEdldCB0aGUgY29ubmVjdGlvbiBvciBvcGVuIGEgbmV3IG9uZSB3aXRob3V0IHVwZ3JhZGUuXG4gICAgICAgIHJldHVybiBfZ2V0T3JpZ2luYWxDb25uZWN0aW9uKGRiSW5mbyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgZGJJbmZvLmRiID0gZGI7XG4gICAgICAgIGlmIChfaXNVcGdyYWRlTmVlZGVkKGRiSW5mbywgc2VsZi5fZGVmYXVsdENvbmZpZy52ZXJzaW9uKSkge1xuICAgICAgICAgICAgLy8gUmVvcGVuIHRoZSBkYXRhYmFzZSBmb3IgdXBncmFkaW5nLlxuICAgICAgICAgICAgcmV0dXJuIF9nZXRVcGdyYWRlZENvbm5lY3Rpb24oZGJJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGI7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgZGJJbmZvLmRiID0gZGJDb250ZXh0LmRiID0gZGI7XG4gICAgICAgIHNlbGYuX2RiSW5mbyA9IGRiSW5mbztcbiAgICAgICAgLy8gU2hhcmUgdGhlIGZpbmFsIGNvbm5lY3Rpb24gYW1vbmdzdCByZWxhdGVkIGxvY2FsRm9yYWdlcy5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBmb3JhZ2VzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB2YXIgZm9yYWdlID0gZm9yYWdlc1trXTtcbiAgICAgICAgICAgIGlmIChmb3JhZ2UgIT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICAvLyBTZWxmIGlzIGFscmVhZHkgdXAtdG8tZGF0ZS5cbiAgICAgICAgICAgICAgICBmb3JhZ2UuX2RiSW5mby5kYiA9IGRiSW5mby5kYjtcbiAgICAgICAgICAgICAgICBmb3JhZ2UuX2RiSW5mby52ZXJzaW9uID0gZGJJbmZvLnZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SXRlbShrZXksIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjcmVhdGVUcmFuc2FjdGlvbihzZWxmLl9kYkluZm8sIFJFQURfT05MWSwgZnVuY3Rpb24gKGVyciwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzZWxmLl9kYkluZm8uc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlLmdldChrZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzRW5jb2RlZEJsb2IodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfZGVjb2RlQmxvYih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXEuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBJdGVyYXRlIG92ZXIgYWxsIGl0ZW1zIHN0b3JlZCBpbiBkYXRhYmFzZS5cbmZ1bmN0aW9uIGl0ZXJhdGUoaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX09OTFksIGZ1bmN0aW9uIChlcnIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc2VsZi5fZGJJbmZvLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBzdG9yZS5vcGVuQ3Vyc29yKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVyYXRpb25OdW1iZXIgPSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gcmVxLnJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzRW5jb2RlZEJsb2IodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2RlY29kZUJsb2IodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IodmFsdWUsIGN1cnNvci5rZXksIGl0ZXJhdGlvbk51bWJlcisrKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGl0ZXJhdG9yIGNhbGxiYWNrIHJldHVybnMgYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKG5vbi1gdW5kZWZpbmVkYCkgdmFsdWUsIHRoZW4gd2Ugc3RvcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBpdGVyYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcltcImNvbnRpbnVlXCJdKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocmVxLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBzZXRJdGVtKGtleSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgZGJJbmZvO1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgICAgICBpZiAodG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEJsb2JdJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2hlY2tCbG9iU3VwcG9ydChkYkluZm8uZGIpLnRoZW4oZnVuY3Rpb24gKGJsb2JTdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9iU3VwcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZW5jb2RlQmxvYih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBjcmVhdGVUcmFuc2FjdGlvbihzZWxmLl9kYkluZm8sIFJFQURfV1JJVEUsIGZ1bmN0aW9uIChlcnIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc2VsZi5fZGJJbmZvLnN0b3JlTmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlYXNvbiB3ZSBkb24ndCBfc2F2ZV8gbnVsbCBpcyBiZWNhdXNlIElFIDEwIGRvZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IHN1cHBvcnQgc2F2aW5nIHRoZSBgbnVsbGAgdHlwZSBpbiBJbmRleGVkREIuIEhvd1xuICAgICAgICAgICAgICAgICAgICAvLyBpcm9uaWMsIGdpdmVuIHRoZSBidWcgYmVsb3chXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvbG9jYWxGb3JhZ2UvaXNzdWVzLzE2MVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlLnB1dCh2YWx1ZSwga2V5KTtcblxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FzdCB0byB1bmRlZmluZWQgc28gdGhlIHZhbHVlIHBhc3NlZCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGJhY2svcHJvbWlzZSBpcyB0aGUgc2FtZSBhcyB3aGF0IG9uZSB3b3VsZCBnZXQgb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiBgZ2V0SXRlbSgpYCBsYXRlci4gVGhpcyBsZWFkcyB0byBzb21lIHdlaXJkbmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKHNldEl0ZW0oJ2ZvbycsIHVuZGVmaW5lZCkgd2lsbCByZXR1cm4gYG51bGxgKSwgYnV0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBteSBmYXVsdCBsb2NhbFN0b3JhZ2UgaXMgb3VyIGJhc2VsaW5lIGFuZCB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIHdlaXJkLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmFib3J0ID0gdHJhbnNhY3Rpb24ub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSByZXEuZXJyb3IgPyByZXEuZXJyb3IgOiByZXEudHJhbnNhY3Rpb24uZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSXRlbShrZXksIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjcmVhdGVUcmFuc2FjdGlvbihzZWxmLl9kYkluZm8sIFJFQURfV1JJVEUsIGZ1bmN0aW9uIChlcnIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc2VsZi5fZGJJbmZvLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHVzZSBhIEdydW50IHRhc2sgdG8gbWFrZSB0aGlzIHNhZmUgZm9yIElFIGFuZCBzb21lXG4gICAgICAgICAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEFuZHJvaWQgKGluY2x1ZGluZyB0aG9zZSB1c2VkIGJ5IENvcmRvdmEpLlxuICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWxseSBJRSB3b24ndCBsaWtlIGAuZGVsZXRlKClgIGFuZCB3aWxsIGluc2lzdCBvblxuICAgICAgICAgICAgICAgICAgICAvLyB1c2luZyBgWydkZWxldGUnXSgpYCwgYnV0IHdlIGhhdmUgYSBidWlsZCBzdGVwIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZml4ZXMgdGhpcyBmb3IgdXMgbm93LlxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gc3RvcmVbXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3Qgd2lsbCBiZSBhbHNvIGJlIGFib3J0ZWQgaWYgd2UndmUgZXhjZWVkZWQgb3VyIHN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BhY2UuXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9uYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gcmVxLmVycm9yID8gcmVxLmVycm9yIDogcmVxLnRyYW5zYWN0aW9uLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGNsZWFyKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX1dSSVRFLCBmdW5jdGlvbiAoZXJyLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHNlbGYuX2RiSW5mby5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gc3RvcmUuY2xlYXIoKTtcblxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9uYWJvcnQgPSB0cmFuc2FjdGlvbi5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IHJlcS5lcnJvciA/IHJlcS5lcnJvciA6IHJlcS50cmFuc2FjdGlvbi5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBsZW5ndGgoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjcmVhdGVUcmFuc2FjdGlvbihzZWxmLl9kYkluZm8sIFJFQURfT05MWSwgZnVuY3Rpb24gKGVyciwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzZWxmLl9kYkluZm8uc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlLmNvdW50KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVxLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocmVxLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24ga2V5KG4sIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjcmVhdGVUcmFuc2FjdGlvbihzZWxmLl9kYkluZm8sIFJFQURfT05MWSwgZnVuY3Rpb24gKGVyciwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzZWxmLl9kYkluZm8uc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkdmFuY2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBzdG9yZS5vcGVuS2V5Q3Vyc29yKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3IgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIG1lYW5zIHRoZXJlIHdlcmVuJ3QgZW5vdWdoIGtleXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdGhlIGZpcnN0IGtleSwgcmV0dXJuIGl0IGlmIHRoYXQncyB3aGF0IHRoZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YW50ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjdXJzb3Iua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhZHZhbmNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGFzayB0aGUgY3Vyc29yIHRvIHNraXAgYWhlYWQgblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWNvcmRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5hZHZhbmNlKG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gd2UgZ2V0IGhlcmUsIHdlJ3ZlIGdvdCB0aGUgbnRoIGtleS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjdXJzb3Iua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocmVxLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24ga2V5cyhjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNyZWF0ZVRyYW5zYWN0aW9uKHNlbGYuX2RiSW5mbywgUkVBRF9PTkxZLCBmdW5jdGlvbiAoZXJyLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHNlbGYuX2RiSW5mby5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gc3RvcmUub3BlbktleUN1cnNvcigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gcmVxLnJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGN1cnNvci5rZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yW1wiY29udGludWVcIl0oKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXEuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBkcm9wSW5zdGFuY2Uob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGdldENhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB2YXIgY3VycmVudENvbmZpZyA9IHRoaXMuY29uZmlnKCk7XG4gICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zICE9PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMgfHwge307XG4gICAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IGN1cnJlbnRDb25maWcubmFtZTtcbiAgICAgICAgb3B0aW9ucy5zdG9yZU5hbWUgPSBvcHRpb25zLnN0b3JlTmFtZSB8fCBjdXJyZW50Q29uZmlnLnN0b3JlTmFtZTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByb21pc2U7XG4gICAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UkMS5yZWplY3QoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlzQ3VycmVudERiID0gb3B0aW9ucy5uYW1lID09PSBjdXJyZW50Q29uZmlnLm5hbWUgJiYgc2VsZi5fZGJJbmZvLmRiO1xuXG4gICAgICAgIHZhciBkYlByb21pc2UgPSBpc0N1cnJlbnREYiA/IFByb21pc2UkMS5yZXNvbHZlKHNlbGYuX2RiSW5mby5kYikgOiBfZ2V0T3JpZ2luYWxDb25uZWN0aW9uKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgICB2YXIgZGJDb250ZXh0ID0gZGJDb250ZXh0c1tvcHRpb25zLm5hbWVdO1xuICAgICAgICAgICAgdmFyIGZvcmFnZXMgPSBkYkNvbnRleHQuZm9yYWdlcztcbiAgICAgICAgICAgIGRiQ29udGV4dC5kYiA9IGRiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yYWdlc1tpXS5fZGJJbmZvLmRiID0gZGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5zdG9yZU5hbWUpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBkYlByb21pc2UudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgICAgICAgICBfZGVmZXJSZWFkaW5lc3Mob3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGJDb250ZXh0ID0gZGJDb250ZXh0c1tvcHRpb25zLm5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciBmb3JhZ2VzID0gZGJDb250ZXh0LmZvcmFnZXM7XG5cbiAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9yYWdlID0gZm9yYWdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yYWdlLl9kYkluZm8uZGIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBkcm9wREJQcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBpZGIuZGVsZXRlRGF0YWJhc2Uob3B0aW9ucy5uYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uYmxvY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsb3NpbmcgYWxsIG9wZW4gY29ubmVjdGlvbnMgaW4gb252ZXJzaW9uY2hhbmdlIGhhbmRsZXIgc2hvdWxkIHByZXZlbnQgdGhpcyBzaXR1YXRpb24sIGJ1dCBpZlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG8gZ2V0IGhlcmUsIGl0IGp1c3QgbWVhbnMgdGhlIHJlcXVlc3QgcmVtYWlucyBwZW5kaW5nIC0gZXZlbnR1YWxseSBpdCB3aWxsIHN1Y2NlZWQgb3IgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignZHJvcEluc3RhbmNlIGJsb2NrZWQgZm9yIGRhdGFiYXNlIFwiJyArIG9wdGlvbnMubmFtZSArICdcIiB1bnRpbCBhbGwgb3BlbiBjb25uZWN0aW9ucyBhcmUgY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZHJvcERCUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICAgICAgICAgICAgICBkYkNvbnRleHQuZGIgPSBkYjtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2ZvcmFnZSA9IGZvcmFnZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBfYWR2YW5jZVJlYWRpbmVzcyhfZm9yYWdlLl9kYkluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIChfcmVqZWN0UmVhZGluZXNzKG9wdGlvbnMsIGVycikgfHwgUHJvbWlzZSQxLnJlc29sdmUoKSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvbWlzZSA9IGRiUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICAgICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhvcHRpb25zLnN0b3JlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBuZXdWZXJzaW9uID0gZGIudmVyc2lvbiArIDE7XG5cbiAgICAgICAgICAgICAgICBfZGVmZXJSZWFkaW5lc3Mob3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGJDb250ZXh0ID0gZGJDb250ZXh0c1tvcHRpb25zLm5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciBmb3JhZ2VzID0gZGJDb250ZXh0LmZvcmFnZXM7XG5cbiAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9yYWdlID0gZm9yYWdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yYWdlLl9kYkluZm8uZGIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBmb3JhZ2UuX2RiSW5mby52ZXJzaW9uID0gbmV3VmVyc2lvbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZHJvcE9iamVjdFByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IGlkYi5vcGVuKG9wdGlvbnMubmFtZSwgbmV3VmVyc2lvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGIgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGIgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGIuZGVsZXRlT2JqZWN0U3RvcmUob3B0aW9ucy5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGIgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRyb3BPYmplY3RQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRiQ29udGV4dC5kYiA9IGRiO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZvcmFnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZm9yYWdlMiA9IGZvcmFnZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBfZm9yYWdlMi5fZGJJbmZvLmRiID0gZGI7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYWR2YW5jZVJlYWRpbmVzcyhfZm9yYWdlMi5fZGJJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAoX3JlamVjdFJlYWRpbmVzcyhvcHRpb25zLCBlcnIpIHx8IFByb21pc2UkMS5yZXNvbHZlKCkpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbnZhciBhc3luY1N0b3JhZ2UgPSB7XG4gICAgX2RyaXZlcjogJ2FzeW5jU3RvcmFnZScsXG4gICAgX2luaXRTdG9yYWdlOiBfaW5pdFN0b3JhZ2UsXG4gICAgX3N1cHBvcnQ6IGlzSW5kZXhlZERCVmFsaWQoKSxcbiAgICBpdGVyYXRlOiBpdGVyYXRlLFxuICAgIGdldEl0ZW06IGdldEl0ZW0sXG4gICAgc2V0SXRlbTogc2V0SXRlbSxcbiAgICByZW1vdmVJdGVtOiByZW1vdmVJdGVtLFxuICAgIGNsZWFyOiBjbGVhcixcbiAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICBrZXk6IGtleSxcbiAgICBrZXlzOiBrZXlzLFxuICAgIGRyb3BJbnN0YW5jZTogZHJvcEluc3RhbmNlXG59O1xuXG5mdW5jdGlvbiBpc1dlYlNRTFZhbGlkKCkge1xuICAgIHJldHVybiB0eXBlb2Ygb3BlbkRhdGFiYXNlID09PSAnZnVuY3Rpb24nO1xufVxuXG4vLyBTYWRseSwgdGhlIGJlc3Qgd2F5IHRvIHNhdmUgYmluYXJ5IGRhdGEgaW4gV2ViU1FML2xvY2FsU3RvcmFnZSBpcyBzZXJpYWxpemluZ1xuLy8gaXQgdG8gQmFzZTY0LCBzbyB0aGlzIGlzIGhvdyB3ZSBzdG9yZSBpdCB0byBwcmV2ZW50IHZlcnkgc3RyYW5nZSBlcnJvcnMgd2l0aCBsZXNzXG4vLyB2ZXJib3NlIHdheXMgb2YgYmluYXJ5IDwtPiBzdHJpbmcgZGF0YSBzdG9yYWdlLlxudmFyIEJBU0VfQ0hBUlMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbnZhciBCTE9CX1RZUEVfUFJFRklYID0gJ35+bG9jYWxfZm9yYWdlX3R5cGV+JztcbnZhciBCTE9CX1RZUEVfUFJFRklYX1JFR0VYID0gL15+fmxvY2FsX2ZvcmFnZV90eXBlfihbXn5dKyl+LztcblxudmFyIFNFUklBTElaRURfTUFSS0VSID0gJ19fbGZzY19fOic7XG52YXIgU0VSSUFMSVpFRF9NQVJLRVJfTEVOR1RIID0gU0VSSUFMSVpFRF9NQVJLRVIubGVuZ3RoO1xuXG4vLyBPTUcgdGhlIHNlcmlhbGl6YXRpb25zIVxudmFyIFRZUEVfQVJSQVlCVUZGRVIgPSAnYXJiZic7XG52YXIgVFlQRV9CTE9CID0gJ2Jsb2InO1xudmFyIFRZUEVfSU5UOEFSUkFZID0gJ3NpMDgnO1xudmFyIFRZUEVfVUlOVDhBUlJBWSA9ICd1aTA4JztcbnZhciBUWVBFX1VJTlQ4Q0xBTVBFREFSUkFZID0gJ3VpYzgnO1xudmFyIFRZUEVfSU5UMTZBUlJBWSA9ICdzaTE2JztcbnZhciBUWVBFX0lOVDMyQVJSQVkgPSAnc2kzMic7XG52YXIgVFlQRV9VSU5UMTZBUlJBWSA9ICd1cjE2JztcbnZhciBUWVBFX1VJTlQzMkFSUkFZID0gJ3VpMzInO1xudmFyIFRZUEVfRkxPQVQzMkFSUkFZID0gJ2ZsMzInO1xudmFyIFRZUEVfRkxPQVQ2NEFSUkFZID0gJ2ZsNjQnO1xudmFyIFRZUEVfU0VSSUFMSVpFRF9NQVJLRVJfTEVOR1RIID0gU0VSSUFMSVpFRF9NQVJLRVJfTEVOR1RIICsgVFlQRV9BUlJBWUJVRkZFUi5sZW5ndGg7XG5cbnZhciB0b1N0cmluZyQxID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gc3RyaW5nVG9CdWZmZXIoc2VyaWFsaXplZFN0cmluZykge1xuICAgIC8vIEZpbGwgdGhlIHN0cmluZyBpbnRvIGEgQXJyYXlCdWZmZXIuXG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IHNlcmlhbGl6ZWRTdHJpbmcubGVuZ3RoICogMC43NTtcbiAgICB2YXIgbGVuID0gc2VyaWFsaXplZFN0cmluZy5sZW5ndGg7XG4gICAgdmFyIGk7XG4gICAgdmFyIHAgPSAwO1xuICAgIHZhciBlbmNvZGVkMSwgZW5jb2RlZDIsIGVuY29kZWQzLCBlbmNvZGVkNDtcblxuICAgIGlmIChzZXJpYWxpemVkU3RyaW5nW3NlcmlhbGl6ZWRTdHJpbmcubGVuZ3RoIC0gMV0gPT09ICc9Jykge1xuICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgICAgaWYgKHNlcmlhbGl6ZWRTdHJpbmdbc2VyaWFsaXplZFN0cmluZy5sZW5ndGggLSAyXSA9PT0gJz0nKSB7XG4gICAgICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKTtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGVuY29kZWQxID0gQkFTRV9DSEFSUy5pbmRleE9mKHNlcmlhbGl6ZWRTdHJpbmdbaV0pO1xuICAgICAgICBlbmNvZGVkMiA9IEJBU0VfQ0hBUlMuaW5kZXhPZihzZXJpYWxpemVkU3RyaW5nW2kgKyAxXSk7XG4gICAgICAgIGVuY29kZWQzID0gQkFTRV9DSEFSUy5pbmRleE9mKHNlcmlhbGl6ZWRTdHJpbmdbaSArIDJdKTtcbiAgICAgICAgZW5jb2RlZDQgPSBCQVNFX0NIQVJTLmluZGV4T2Yoc2VyaWFsaXplZFN0cmluZ1tpICsgM10pO1xuXG4gICAgICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cbiAgICAgICAgYnl0ZXNbcCsrXSA9IGVuY29kZWQxIDw8IDIgfCBlbmNvZGVkMiA+PiA0O1xuICAgICAgICBieXRlc1twKytdID0gKGVuY29kZWQyICYgMTUpIDw8IDQgfCBlbmNvZGVkMyA+PiAyO1xuICAgICAgICBieXRlc1twKytdID0gKGVuY29kZWQzICYgMykgPDwgNiB8IGVuY29kZWQ0ICYgNjM7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG5cbi8vIENvbnZlcnRzIGEgYnVmZmVyIHRvIGEgc3RyaW5nIHRvIHN0b3JlLCBzZXJpYWxpemVkLCBpbiB0aGUgYmFja2VuZFxuLy8gc3RvcmFnZSBsaWJyYXJ5LlxuZnVuY3Rpb24gYnVmZmVyVG9TdHJpbmcoYnVmZmVyKSB7XG4gICAgLy8gYmFzZTY0LWFycmF5YnVmZmVyXG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICB2YXIgYmFzZTY0U3RyaW5nID0gJyc7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuICAgICAgICBiYXNlNjRTdHJpbmcgKz0gQkFTRV9DSEFSU1tieXRlc1tpXSA+PiAyXTtcbiAgICAgICAgYmFzZTY0U3RyaW5nICs9IEJBU0VfQ0hBUlNbKGJ5dGVzW2ldICYgMykgPDwgNCB8IGJ5dGVzW2kgKyAxXSA+PiA0XTtcbiAgICAgICAgYmFzZTY0U3RyaW5nICs9IEJBU0VfQ0hBUlNbKGJ5dGVzW2kgKyAxXSAmIDE1KSA8PCAyIHwgYnl0ZXNbaSArIDJdID4+IDZdO1xuICAgICAgICBiYXNlNjRTdHJpbmcgKz0gQkFTRV9DSEFSU1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuXG4gICAgaWYgKGJ5dGVzLmxlbmd0aCAlIDMgPT09IDIpIHtcbiAgICAgICAgYmFzZTY0U3RyaW5nID0gYmFzZTY0U3RyaW5nLnN1YnN0cmluZygwLCBiYXNlNjRTdHJpbmcubGVuZ3RoIC0gMSkgKyAnPSc7XG4gICAgfSBlbHNlIGlmIChieXRlcy5sZW5ndGggJSAzID09PSAxKSB7XG4gICAgICAgIGJhc2U2NFN0cmluZyA9IGJhc2U2NFN0cmluZy5zdWJzdHJpbmcoMCwgYmFzZTY0U3RyaW5nLmxlbmd0aCAtIDIpICsgJz09JztcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTY0U3RyaW5nO1xufVxuXG4vLyBTZXJpYWxpemUgYSB2YWx1ZSwgYWZ0ZXJ3YXJkcyBleGVjdXRpbmcgYSBjYWxsYmFjayAod2hpY2ggdXN1YWxseVxuLy8gaW5zdHJ1Y3RzIHRoZSBgc2V0SXRlbSgpYCBjYWxsYmFjay9wcm9taXNlIHRvIGJlIGV4ZWN1dGVkKS4gVGhpcyBpcyBob3dcbi8vIHdlIHN0b3JlIGJpbmFyeSBkYXRhIHdpdGggbG9jYWxTdG9yYWdlLlxuZnVuY3Rpb24gc2VyaWFsaXplKHZhbHVlLCBjYWxsYmFjaykge1xuICAgIHZhciB2YWx1ZVR5cGUgPSAnJztcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFsdWVUeXBlID0gdG9TdHJpbmckMS5jYWxsKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBDYW5ub3QgdXNlIGB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyYCBvciBzdWNoIGhlcmUsIGFzIHRoZXNlXG4gICAgLy8gY2hlY2tzIGZhaWwgd2hlbiBydW5uaW5nIHRoZSB0ZXN0cyB1c2luZyBjYXNwZXIuanMuLi5cbiAgICAvL1xuICAgIC8vIFRPRE86IFNlZSB3aHkgdGhvc2UgdGVzdHMgZmFpbCBhbmQgdXNlIGEgYmV0dGVyIHNvbHV0aW9uLlxuICAgIGlmICh2YWx1ZSAmJiAodmFsdWVUeXBlID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nIHx8IHZhbHVlLmJ1ZmZlciAmJiB0b1N0cmluZyQxLmNhbGwodmFsdWUuYnVmZmVyKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykpIHtcbiAgICAgICAgLy8gQ29udmVydCBiaW5hcnkgYXJyYXlzIHRvIGEgc3RyaW5nIGFuZCBwcmVmaXggdGhlIHN0cmluZyB3aXRoXG4gICAgICAgIC8vIGEgc3BlY2lhbCBtYXJrZXIuXG4gICAgICAgIHZhciBidWZmZXI7XG4gICAgICAgIHZhciBtYXJrZXIgPSBTRVJJQUxJWkVEX01BUktFUjtcblxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgYnVmZmVyID0gdmFsdWU7XG4gICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9BUlJBWUJVRkZFUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IHZhbHVlLmJ1ZmZlcjtcblxuICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgSW50OEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9JTlQ4QVJSQVk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgVWludDhBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfVUlOVDhBUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfVUlOVDhDTEFNUEVEQVJSQVk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgSW50MTZBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfSU5UMTZBUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBVaW50MTZBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfVUlOVDE2QVJSQVk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgSW50MzJBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfSU5UMzJBUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBVaW50MzJBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfVUlOVDMyQVJSQVk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9GTE9BVDMyQVJSQVk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9GTE9BVDY0QVJSQVk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCB0eXBlIGZvciBCaW5hcnlBcnJheScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG1hcmtlciArIGJ1ZmZlclRvU3RyaW5nKGJ1ZmZlcikpO1xuICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBCbG9iXScpIHtcbiAgICAgICAgLy8gQ29udmVyIHRoZSBibG9iIHRvIGEgYmluYXJ5QXJyYXkgYW5kIHRoZW4gdG8gYSBzdHJpbmcuXG4gICAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIEJhY2t3YXJkcy1jb21wYXRpYmxlIHByZWZpeCBmb3IgdGhlIGJsb2IgdHlwZS5cbiAgICAgICAgICAgIHZhciBzdHIgPSBCTE9CX1RZUEVfUFJFRklYICsgdmFsdWUudHlwZSArICd+JyArIGJ1ZmZlclRvU3RyaW5nKHRoaXMucmVzdWx0KTtcblxuICAgICAgICAgICAgY2FsbGJhY2soU0VSSUFMSVpFRF9NQVJLRVIgKyBUWVBFX0JMT0IgKyBzdHIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYWxsYmFjayhKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ291bGRuJ3QgY29udmVydCB2YWx1ZSBpbnRvIGEgSlNPTiBzdHJpbmc6IFwiLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBEZXNlcmlhbGl6ZSBkYXRhIHdlJ3ZlIGluc2VydGVkIGludG8gYSB2YWx1ZSBjb2x1bW4vZmllbGQuIFdlIHBsYWNlXG4vLyBzcGVjaWFsIG1hcmtlcnMgaW50byBvdXIgc3RyaW5ncyB0byBtYXJrIHRoZW0gYXMgZW5jb2RlZDsgdGhpcyBpc24ndFxuLy8gYXMgbmljZSBhcyBhIG1ldGEgZmllbGQsIGJ1dCBpdCdzIHRoZSBvbmx5IHNhbmUgdGhpbmcgd2UgY2FuIGRvIHdoaWxzdFxuLy8ga2VlcGluZyBsb2NhbFN0b3JhZ2Ugc3VwcG9ydCBpbnRhY3QuXG4vL1xuLy8gT2Z0ZW50aW1lcyB0aGlzIHdpbGwganVzdCBkZXNlcmlhbGl6ZSBKU09OIGNvbnRlbnQsIGJ1dCBpZiB3ZSBoYXZlIGFcbi8vIHNwZWNpYWwgbWFya2VyIChTRVJJQUxJWkVEX01BUktFUiwgZGVmaW5lZCBhYm92ZSksIHdlIHdpbGwgZXh0cmFjdFxuLy8gc29tZSBraW5kIG9mIGFycmF5YnVmZmVyL2JpbmFyeSBkYXRhL3R5cGVkIGFycmF5IG91dCBvZiB0aGUgc3RyaW5nLlxuZnVuY3Rpb24gZGVzZXJpYWxpemUodmFsdWUpIHtcbiAgICAvLyBJZiB3ZSBoYXZlbid0IG1hcmtlZCB0aGlzIHN0cmluZyBhcyBiZWluZyBzcGVjaWFsbHkgc2VyaWFsaXplZCAoaS5lLlxuICAgIC8vIHNvbWV0aGluZyBvdGhlciB0aGFuIHNlcmlhbGl6ZWQgSlNPTiksIHdlIGNhbiBqdXN0IHJldHVybiBpdCBhbmQgYmVcbiAgICAvLyBkb25lIHdpdGggaXQuXG4gICAgaWYgKHZhbHVlLnN1YnN0cmluZygwLCBTRVJJQUxJWkVEX01BUktFUl9MRU5HVEgpICE9PSBTRVJJQUxJWkVEX01BUktFUikge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGRlYWxzIHdpdGggZGVzZXJpYWxpemluZyBzb21lIGtpbmQgb2YgQmxvYiBvclxuICAgIC8vIFR5cGVkQXJyYXkuIEZpcnN0IHdlIHNlcGFyYXRlIG91dCB0aGUgdHlwZSBvZiBkYXRhIHdlJ3JlIGRlYWxpbmdcbiAgICAvLyB3aXRoIGZyb20gdGhlIGRhdGEgaXRzZWxmLlxuICAgIHZhciBzZXJpYWxpemVkU3RyaW5nID0gdmFsdWUuc3Vic3RyaW5nKFRZUEVfU0VSSUFMSVpFRF9NQVJLRVJfTEVOR1RIKTtcbiAgICB2YXIgdHlwZSA9IHZhbHVlLnN1YnN0cmluZyhTRVJJQUxJWkVEX01BUktFUl9MRU5HVEgsIFRZUEVfU0VSSUFMSVpFRF9NQVJLRVJfTEVOR1RIKTtcblxuICAgIHZhciBibG9iVHlwZTtcbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0aWJsZSBibG9iIHR5cGUgc2VyaWFsaXphdGlvbiBzdHJhdGVneS5cbiAgICAvLyBEQnMgY3JlYXRlZCB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIGxvY2FsRm9yYWdlIHdpbGwgc2ltcGx5IG5vdCBoYXZlIHRoZSBibG9iIHR5cGUuXG4gICAgaWYgKHR5cGUgPT09IFRZUEVfQkxPQiAmJiBCTE9CX1RZUEVfUFJFRklYX1JFR0VYLnRlc3Qoc2VyaWFsaXplZFN0cmluZykpIHtcbiAgICAgICAgdmFyIG1hdGNoZXIgPSBzZXJpYWxpemVkU3RyaW5nLm1hdGNoKEJMT0JfVFlQRV9QUkVGSVhfUkVHRVgpO1xuICAgICAgICBibG9iVHlwZSA9IG1hdGNoZXJbMV07XG4gICAgICAgIHNlcmlhbGl6ZWRTdHJpbmcgPSBzZXJpYWxpemVkU3RyaW5nLnN1YnN0cmluZyhtYXRjaGVyWzBdLmxlbmd0aCk7XG4gICAgfVxuICAgIHZhciBidWZmZXIgPSBzdHJpbmdUb0J1ZmZlcihzZXJpYWxpemVkU3RyaW5nKTtcblxuICAgIC8vIFJldHVybiB0aGUgcmlnaHQgdHlwZSBiYXNlZCBvbiB0aGUgY29kZS90eXBlIHNldCBkdXJpbmdcbiAgICAvLyBzZXJpYWxpemF0aW9uLlxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFRZUEVfQVJSQVlCVUZGRVI6XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgICBjYXNlIFRZUEVfQkxPQjpcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVCbG9iKFtidWZmZXJdLCB7IHR5cGU6IGJsb2JUeXBlIH0pO1xuICAgICAgICBjYXNlIFRZUEVfSU5UOEFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSBUWVBFX1VJTlQ4QVJSQVk6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSBUWVBFX1VJTlQ4Q0xBTVBFREFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheShidWZmZXIpO1xuICAgICAgICBjYXNlIFRZUEVfSU5UMTZBUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShidWZmZXIpO1xuICAgICAgICBjYXNlIFRZUEVfVUlOVDE2QVJSQVk6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgVFlQRV9JTlQzMkFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgVFlQRV9VSU5UMzJBUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSBUWVBFX0ZMT0FUMzJBUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgVFlQRV9GTE9BVDY0QVJSQVk6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShidWZmZXIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtvd24gdHlwZTogJyArIHR5cGUpO1xuICAgIH1cbn1cblxudmFyIGxvY2FsZm9yYWdlU2VyaWFsaXplciA9IHtcbiAgICBzZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICBkZXNlcmlhbGl6ZTogZGVzZXJpYWxpemUsXG4gICAgc3RyaW5nVG9CdWZmZXI6IHN0cmluZ1RvQnVmZmVyLFxuICAgIGJ1ZmZlclRvU3RyaW5nOiBidWZmZXJUb1N0cmluZ1xufTtcblxuLypcbiAqIEluY2x1ZGVzIGNvZGUgZnJvbTpcbiAqXG4gKiBiYXNlNjQtYXJyYXlidWZmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGJUYWJsZSh0LCBkYkluZm8sIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdC5leGVjdXRlU3FsKCdDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyAnICsgZGJJbmZvLnN0b3JlTmFtZSArICcgJyArICcoaWQgSU5URUdFUiBQUklNQVJZIEtFWSwga2V5IHVuaXF1ZSwgdmFsdWUpJywgW10sIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbn1cblxuLy8gT3BlbiB0aGUgV2ViU1FMIGRhdGFiYXNlIChhdXRvbWF0aWNhbGx5IGNyZWF0ZXMgb25lIGlmIG9uZSBkaWRuJ3Rcbi8vIHByZXZpb3VzbHkgZXhpc3QpLCB1c2luZyBhbnkgb3B0aW9ucyBzZXQgaW4gdGhlIGNvbmZpZy5cbmZ1bmN0aW9uIF9pbml0U3RvcmFnZSQxKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRiSW5mbyA9IHtcbiAgICAgICAgZGI6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBkYkluZm9baV0gPSB0eXBlb2Ygb3B0aW9uc1tpXSAhPT0gJ3N0cmluZycgPyBvcHRpb25zW2ldLnRvU3RyaW5nKCkgOiBvcHRpb25zW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRiSW5mb1Byb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gT3BlbiB0aGUgZGF0YWJhc2U7IHRoZSBvcGVuRGF0YWJhc2UgQVBJIHdpbGwgYXV0b21hdGljYWxseVxuICAgICAgICAvLyBjcmVhdGUgaXQgZm9yIHVzIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYkluZm8uZGIgPSBvcGVuRGF0YWJhc2UoZGJJbmZvLm5hbWUsIFN0cmluZyhkYkluZm8udmVyc2lvbiksIGRiSW5mby5kZXNjcmlwdGlvbiwgZGJJbmZvLnNpemUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIG91ciBrZXkvdmFsdWUgdGFibGUgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgICAgZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBjcmVhdGVEYlRhYmxlKHQsIGRiSW5mbywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX2RiSW5mbyA9IGRiSW5mbztcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBkYkluZm8uc2VyaWFsaXplciA9IGxvY2FsZm9yYWdlU2VyaWFsaXplcjtcbiAgICByZXR1cm4gZGJJbmZvUHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gdHJ5RXhlY3V0ZVNxbCh0LCBkYkluZm8sIHNxbFN0YXRlbWVudCwgYXJncywgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICB0LmV4ZWN1dGVTcWwoc3FsU3RhdGVtZW50LCBhcmdzLCBjYWxsYmFjaywgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSBlcnJvci5TWU5UQVhfRVJSKSB7XG4gICAgICAgICAgICB0LmV4ZWN1dGVTcWwoJ1NFTEVDVCBuYW1lIEZST00gc3FsaXRlX21hc3RlciAnICsgXCJXSEVSRSB0eXBlPSd0YWJsZScgQU5EIG5hbWUgPSA/XCIsIFtkYkluZm8uc3RvcmVOYW1lXSwgZnVuY3Rpb24gKHQsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdHMucm93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHRhYmxlIGlzIG1pc3NpbmcgKHdhcyBkZWxldGVkKVxuICAgICAgICAgICAgICAgICAgICAvLyByZS1jcmVhdGUgaXQgdGFibGUgYW5kIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZURiVGFibGUodCwgZGJJbmZvLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LmV4ZWN1dGVTcWwoc3FsU3RhdGVtZW50LCBhcmdzLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGVycm9yQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2sodCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGVycm9yQ2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JDYWxsYmFjayh0LCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9LCBlcnJvckNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZ2V0SXRlbSQxKGtleSwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgICAgICBkYkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB0cnlFeGVjdXRlU3FsKHQsIGRiSW5mbywgJ1NFTEVDVCAqIEZST00gJyArIGRiSW5mby5zdG9yZU5hbWUgKyAnIFdIRVJFIGtleSA9ID8gTElNSVQgMScsIFtrZXldLCBmdW5jdGlvbiAodCwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0cy5yb3dzLmxlbmd0aCA/IHJlc3VsdHMucm93cy5pdGVtKDApLnZhbHVlIDogbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhpcyBpcyBzZXJpYWxpemVkIGNvbnRlbnQgd2UgbmVlZCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyB1bnBhY2suXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRiSW5mby5zZXJpYWxpemVyLmRlc2VyaWFsaXplKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gaXRlcmF0ZSQxKGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG5cbiAgICAgICAgICAgIGRiSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHRyeUV4ZWN1dGVTcWwodCwgZGJJbmZvLCAnU0VMRUNUICogRlJPTSAnICsgZGJJbmZvLnN0b3JlTmFtZSwgW10sIGZ1bmN0aW9uICh0LCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3dzID0gcmVzdWx0cy5yb3dzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gcm93cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSByb3dzLml0ZW0oaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlbS52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoaXMgaXMgc2VyaWFsaXplZCBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHVucGFjay5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkYkluZm8uc2VyaWFsaXplci5kZXNlcmlhbGl6ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBpdGVyYXRvcihyZXN1bHQsIGl0ZW0ua2V5LCBpICsgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZvaWQoMCkgcHJldmVudHMgcHJvYmxlbXMgd2l0aCByZWRlZmluaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIGB1bmRlZmluZWRgLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBfc2V0SXRlbShrZXksIHZhbHVlLCBjYWxsYmFjaywgcmV0cmllc0xlZnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBsb2NhbFN0b3JhZ2UgQVBJIGRvZXNuJ3QgcmV0dXJuIHVuZGVmaW5lZCB2YWx1ZXMgaW4gYW5cbiAgICAgICAgICAgIC8vIFwiZXhwZWN0ZWRcIiB3YXksIHNvIHVuZGVmaW5lZCBpcyBhbHdheXMgY2FzdCB0byBudWxsIGluIGFsbFxuICAgICAgICAgICAgLy8gZHJpdmVycy4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9sb2NhbEZvcmFnZS9wdWxsLzQyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgb3JpZ2luYWwgdmFsdWUgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2suXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgZGJJbmZvLnNlcmlhbGl6ZXIuc2VyaWFsaXplKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnlFeGVjdXRlU3FsKHQsIGRiSW5mbywgJ0lOU0VSVCBPUiBSRVBMQUNFIElOVE8gJyArIGRiSW5mby5zdG9yZU5hbWUgKyAnICcgKyAnKGtleSwgdmFsdWUpIFZBTFVFUyAoPywgPyknLCBba2V5LCB2YWx1ZV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG9yaWdpbmFsVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoc3FsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0cmFuc2FjdGlvbiBmYWlsZWQ7IGNoZWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBzZWUgaWYgaXQncyBhIHF1b3RhIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNxbEVycm9yLmNvZGUgPT09IHNxbEVycm9yLlFVT1RBX0VSUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHJlamVjdCB0aGUgY2FsbGJhY2sgb3V0cmlnaHQgZm9yIG5vdywgYnV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyB3b3J0aCB0cnlpbmcgdG8gcmUtcnVuIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFdmVuIGlmIHRoZSB1c2VyIGFjY2VwdHMgdGhlIHByb21wdCB0byB1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3JlIHN0b3JhZ2Ugb24gU2FmYXJpLCB0aGlzIGVycm9yIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiZSBjYWxsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gcmUtcnVuIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0cmllc0xlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoX3NldEl0ZW0uYXBwbHkoc2VsZiwgW2tleSwgb3JpZ2luYWxWYWx1ZSwgY2FsbGJhY2ssIHJldHJpZXNMZWZ0IC0gMV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoc3FsRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gc2V0SXRlbSQxKGtleSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9zZXRJdGVtLmFwcGx5KHRoaXMsIFtrZXksIHZhbHVlLCBjYWxsYmFjaywgMV0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVJdGVtJDEoa2V5LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgICAgIGRiSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHRyeUV4ZWN1dGVTcWwodCwgZGJJbmZvLCAnREVMRVRFIEZST00gJyArIGRiSW5mby5zdG9yZU5hbWUgKyAnIFdIRVJFIGtleSA9ID8nLCBba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gRGVsZXRlcyBldmVyeSBpdGVtIGluIHRoZSB0YWJsZS5cbi8vIFRPRE86IEZpbmQgb3V0IGlmIHRoaXMgcmVzZXRzIHRoZSBBVVRPX0lOQ1JFTUVOVCBudW1iZXIuXG5mdW5jdGlvbiBjbGVhciQxKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgICAgIGRiSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHRyeUV4ZWN1dGVTcWwodCwgZGJJbmZvLCAnREVMRVRFIEZST00gJyArIGRiSW5mby5zdG9yZU5hbWUsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBEb2VzIGEgc2ltcGxlIGBDT1VOVChrZXkpYCB0byBnZXQgdGhlIG51bWJlciBvZiBpdGVtcyBzdG9yZWQgaW5cbi8vIGxvY2FsRm9yYWdlLlxuZnVuY3Rpb24gbGVuZ3RoJDEoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgLy8gQWhoaCwgU1FMIG1ha2VzIHRoaXMgb25lIHNvb29vb28gZWFzeS5cbiAgICAgICAgICAgICAgICB0cnlFeGVjdXRlU3FsKHQsIGRiSW5mbywgJ1NFTEVDVCBDT1VOVChrZXkpIGFzIGMgRlJPTSAnICsgZGJJbmZvLnN0b3JlTmFtZSwgW10sIGZ1bmN0aW9uICh0LCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzLnJvd3MuaXRlbSgwKS5jO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gUmV0dXJuIHRoZSBrZXkgbG9jYXRlZCBhdCBrZXkgaW5kZXggWDsgZXNzZW50aWFsbHkgZ2V0cyB0aGUga2V5IGZyb20gYVxuLy8gYFdIRVJFIGlkID0gP2AuIFRoaXMgaXMgdGhlIG1vc3QgZWZmaWNpZW50IHdheSBJIGNhbiB0aGluayB0byBpbXBsZW1lbnRcbi8vIHRoaXMgcmFyZWx5LXVzZWQgKGluIG15IGV4cGVyaWVuY2UpIHBhcnQgb2YgdGhlIEFQSSwgYnV0IGl0IGNhbiBzZWVtXG4vLyBpbmNvbnNpc3RlbnQsIGJlY2F1c2Ugd2UgZG8gYElOU0VSVCBPUiBSRVBMQUNFIElOVE9gIG9uIGBzZXRJdGVtKClgLCBzb1xuLy8gdGhlIElEIG9mIGVhY2gga2V5IHdpbGwgY2hhbmdlIGV2ZXJ5IHRpbWUgaXQncyB1cGRhdGVkLiBQZXJoYXBzIGEgc3RvcmVkXG4vLyBwcm9jZWR1cmUgZm9yIHRoZSBgc2V0SXRlbSgpYCBTUUwgd291bGQgc29sdmUgdGhpcyBwcm9ibGVtP1xuLy8gVE9ETzogRG9uJ3QgY2hhbmdlIElEIG9uIGBzZXRJdGVtKClgLlxuZnVuY3Rpb24ga2V5JDEobiwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdHJ5RXhlY3V0ZVNxbCh0LCBkYkluZm8sICdTRUxFQ1Qga2V5IEZST00gJyArIGRiSW5mby5zdG9yZU5hbWUgKyAnIFdIRVJFIGlkID0gPyBMSU1JVCAxJywgW24gKyAxXSwgZnVuY3Rpb24gKHQsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdHMucm93cy5sZW5ndGggPyByZXN1bHRzLnJvd3MuaXRlbSgwKS5rZXkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24ga2V5cyQxKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgICAgIGRiSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHRyeUV4ZWN1dGVTcWwodCwgZGJJbmZvLCAnU0VMRUNUIGtleSBGUk9NICcgKyBkYkluZm8uc3RvcmVOYW1lLCBbXSwgZnVuY3Rpb24gKHQsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMucm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKHJlc3VsdHMucm93cy5pdGVtKGkpLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGtleXMpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJkYXRhYmFzZS8jZGF0YWJhc2VzXG4vLyA+IFRoZXJlIGlzIG5vIHdheSB0byBlbnVtZXJhdGUgb3IgZGVsZXRlIHRoZSBkYXRhYmFzZXMgYXZhaWxhYmxlIGZvciBhbiBvcmlnaW4gZnJvbSB0aGlzIEFQSS5cbmZ1bmN0aW9uIGdldEFsbFN0b3JlTmFtZXMoZGIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB0LmV4ZWN1dGVTcWwoJ1NFTEVDVCBuYW1lIEZST00gc3FsaXRlX21hc3RlciAnICsgXCJXSEVSRSB0eXBlPSd0YWJsZScgQU5EIG5hbWUgPD4gJ19fV2ViS2l0RGF0YWJhc2VJbmZvVGFibGVfXydcIiwgW10sIGZ1bmN0aW9uICh0LCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3JlTmFtZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlTmFtZXMucHVzaChyZXN1bHRzLnJvd3MuaXRlbShpKS5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgZGI6IGRiLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZU5hbWVzOiBzdG9yZU5hbWVzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChzcWxFcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KHNxbEVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGRyb3BJbnN0YW5jZSQxKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBnZXRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdmFyIGN1cnJlbnRDb25maWcgPSB0aGlzLmNvbmZpZygpO1xuICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyAhPT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBjdXJyZW50Q29uZmlnLm5hbWU7XG4gICAgICAgIG9wdGlvbnMuc3RvcmVOYW1lID0gb3B0aW9ucy5zdG9yZU5hbWUgfHwgY3VycmVudENvbmZpZy5zdG9yZU5hbWU7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9taXNlO1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlJDEucmVqZWN0KCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICB2YXIgZGI7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5uYW1lID09PSBjdXJyZW50Q29uZmlnLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIGRiIHJlZmVyZW5jZSBvZiB0aGUgY3VycmVudCBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIGRiID0gc2VsZi5fZGJJbmZvLmRiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYiA9IG9wZW5EYXRhYmFzZShvcHRpb25zLm5hbWUsICcnLCAnJywgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5zdG9yZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBkcm9wIGFsbCBkYXRhYmFzZSB0YWJsZXNcbiAgICAgICAgICAgICAgICByZXNvbHZlKGdldEFsbFN0b3JlTmFtZXMoZGIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRiOiBkYixcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVOYW1lczogW29wdGlvbnMuc3RvcmVOYW1lXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChvcGVyYXRpb25JbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkcm9wVGFibGUoc3RvcmVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5leGVjdXRlU3FsKCdEUk9QIFRBQkxFIElGIEVYSVNUUyAnICsgc3RvcmVOYW1lLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRpb25zID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvcGVyYXRpb25JbmZvLnN0b3JlTmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnMucHVzaChkcm9wVGFibGUob3BlcmF0aW9uSW5mby5zdG9yZU5hbWVzW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlJDEuYWxsKG9wZXJhdGlvbnMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChzcWxFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3Qoc3FsRXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbnZhciB3ZWJTUUxTdG9yYWdlID0ge1xuICAgIF9kcml2ZXI6ICd3ZWJTUUxTdG9yYWdlJyxcbiAgICBfaW5pdFN0b3JhZ2U6IF9pbml0U3RvcmFnZSQxLFxuICAgIF9zdXBwb3J0OiBpc1dlYlNRTFZhbGlkKCksXG4gICAgaXRlcmF0ZTogaXRlcmF0ZSQxLFxuICAgIGdldEl0ZW06IGdldEl0ZW0kMSxcbiAgICBzZXRJdGVtOiBzZXRJdGVtJDEsXG4gICAgcmVtb3ZlSXRlbTogcmVtb3ZlSXRlbSQxLFxuICAgIGNsZWFyOiBjbGVhciQxLFxuICAgIGxlbmd0aDogbGVuZ3RoJDEsXG4gICAga2V5OiBrZXkkMSxcbiAgICBrZXlzOiBrZXlzJDEsXG4gICAgZHJvcEluc3RhbmNlOiBkcm9wSW5zdGFuY2UkMVxufTtcblxuZnVuY3Rpb24gaXNMb2NhbFN0b3JhZ2VWYWxpZCgpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3NldEl0ZW0nIGluIGxvY2FsU3RvcmFnZSAmJlxuICAgICAgICAvLyBpbiBJRTggdHlwZW9mIGxvY2FsU3RvcmFnZS5zZXRJdGVtID09PSAnb2JqZWN0J1xuICAgICAgICAhIWxvY2FsU3RvcmFnZS5zZXRJdGVtO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX2dldEtleVByZWZpeChvcHRpb25zLCBkZWZhdWx0Q29uZmlnKSB7XG4gICAgdmFyIGtleVByZWZpeCA9IG9wdGlvbnMubmFtZSArICcvJztcblxuICAgIGlmIChvcHRpb25zLnN0b3JlTmFtZSAhPT0gZGVmYXVsdENvbmZpZy5zdG9yZU5hbWUpIHtcbiAgICAgICAga2V5UHJlZml4ICs9IG9wdGlvbnMuc3RvcmVOYW1lICsgJy8nO1xuICAgIH1cbiAgICByZXR1cm4ga2V5UHJlZml4O1xufVxuXG4vLyBDaGVjayBpZiBsb2NhbFN0b3JhZ2UgdGhyb3dzIHdoZW4gc2F2aW5nIGFuIGl0ZW1cbmZ1bmN0aW9uIGNoZWNrSWZMb2NhbFN0b3JhZ2VUaHJvd3MoKSB7XG4gICAgdmFyIGxvY2FsU3RvcmFnZVRlc3RLZXkgPSAnX2xvY2FsZm9yYWdlX3N1cHBvcnRfdGVzdCc7XG5cbiAgICB0cnkge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShsb2NhbFN0b3JhZ2VUZXN0S2V5LCB0cnVlKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0obG9jYWxTdG9yYWdlVGVzdEtleSk7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG4vLyBDaGVjayBpZiBsb2NhbFN0b3JhZ2UgaXMgdXNhYmxlIGFuZCBhbGxvd3MgdG8gc2F2ZSBhbiBpdGVtXG4vLyBUaGlzIG1ldGhvZCBjaGVja3MgaWYgbG9jYWxTdG9yYWdlIGlzIHVzYWJsZSBpbiBTYWZhcmkgUHJpdmF0ZSBCcm93c2luZ1xuLy8gbW9kZSwgb3IgaW4gYW55IG90aGVyIGNhc2Ugd2hlcmUgdGhlIGF2YWlsYWJsZSBxdW90YSBmb3IgbG9jYWxTdG9yYWdlXG4vLyBpcyAwIGFuZCB0aGVyZSB3YXNuJ3QgYW55IHNhdmVkIGl0ZW1zIHlldC5cbmZ1bmN0aW9uIF9pc0xvY2FsU3RvcmFnZVVzYWJsZSgpIHtcbiAgICByZXR1cm4gIWNoZWNrSWZMb2NhbFN0b3JhZ2VUaHJvd3MoKSB8fCBsb2NhbFN0b3JhZ2UubGVuZ3RoID4gMDtcbn1cblxuLy8gQ29uZmlnIHRoZSBsb2NhbFN0b3JhZ2UgYmFja2VuZCwgdXNpbmcgb3B0aW9ucyBzZXQgaW4gdGhlIGNvbmZpZy5cbmZ1bmN0aW9uIF9pbml0U3RvcmFnZSQyKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRiSW5mbyA9IHt9O1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgZGJJbmZvW2ldID0gb3B0aW9uc1tpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRiSW5mby5rZXlQcmVmaXggPSBfZ2V0S2V5UHJlZml4KG9wdGlvbnMsIHNlbGYuX2RlZmF1bHRDb25maWcpO1xuXG4gICAgaWYgKCFfaXNMb2NhbFN0b3JhZ2VVc2FibGUoKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZSQxLnJlamVjdCgpO1xuICAgIH1cblxuICAgIHNlbGYuX2RiSW5mbyA9IGRiSW5mbztcbiAgICBkYkluZm8uc2VyaWFsaXplciA9IGxvY2FsZm9yYWdlU2VyaWFsaXplcjtcblxuICAgIHJldHVybiBQcm9taXNlJDEucmVzb2x2ZSgpO1xufVxuXG4vLyBSZW1vdmUgYWxsIGtleXMgZnJvbSB0aGUgZGF0YXN0b3JlLCBlZmZlY3RpdmVseSBkZXN0cm95aW5nIGFsbCBkYXRhIGluXG4vLyB0aGUgYXBwJ3Mga2V5L3ZhbHVlIHN0b3JlIVxuZnVuY3Rpb24gY2xlYXIkMihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcHJvbWlzZSA9IHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtleVByZWZpeCA9IHNlbGYuX2RiSW5mby5rZXlQcmVmaXg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGxvY2FsU3RvcmFnZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG5cbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZihrZXlQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gUmV0cmlldmUgYW4gaXRlbSBmcm9tIHRoZSBzdG9yZS4gVW5saWtlIHRoZSBvcmlnaW5hbCBhc3luY19zdG9yYWdlXG4vLyBsaWJyYXJ5IGluIEdhaWEsIHdlIGRvbid0IG1vZGlmeSByZXR1cm4gdmFsdWVzIGF0IGFsbC4gSWYgYSBrZXkncyB2YWx1ZVxuLy8gaXMgYHVuZGVmaW5lZGAsIHdlIHBhc3MgdGhhdCB2YWx1ZSB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5mdW5jdGlvbiBnZXRJdGVtJDIoa2V5LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgIHZhciByZXN1bHQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShkYkluZm8ua2V5UHJlZml4ICsga2V5KTtcblxuICAgICAgICAvLyBJZiBhIHJlc3VsdCB3YXMgZm91bmQsIHBhcnNlIGl0IGZyb20gdGhlIHNlcmlhbGl6ZWRcbiAgICAgICAgLy8gc3RyaW5nIGludG8gYSBKUyBvYmplY3QuIElmIHJlc3VsdCBpc24ndCB0cnV0aHksIHRoZSBrZXlcbiAgICAgICAgLy8gaXMgbGlrZWx5IHVuZGVmaW5lZCBhbmQgd2UnbGwgcGFzcyBpdCBzdHJhaWdodCB0byB0aGVcbiAgICAgICAgLy8gY2FsbGJhY2suXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGRiSW5mby5zZXJpYWxpemVyLmRlc2VyaWFsaXplKHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gSXRlcmF0ZSBvdmVyIGFsbCBpdGVtcyBpbiB0aGUgc3RvcmUuXG5mdW5jdGlvbiBpdGVyYXRlJDIoaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgIHZhciBrZXlQcmVmaXggPSBkYkluZm8ua2V5UHJlZml4O1xuICAgICAgICB2YXIga2V5UHJlZml4TGVuZ3RoID0ga2V5UHJlZml4Lmxlbmd0aDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGxvY2FsU3RvcmFnZS5sZW5ndGg7XG5cbiAgICAgICAgLy8gV2UgdXNlIGEgZGVkaWNhdGVkIGl0ZXJhdG9yIGluc3RlYWQgb2YgdGhlIGBpYCB2YXJpYWJsZSBiZWxvd1xuICAgICAgICAvLyBzbyBvdGhlciBrZXlzIHdlIGZldGNoIGluIGxvY2FsU3RvcmFnZSBhcmVuJ3QgY291bnRlZCBpblxuICAgICAgICAvLyB0aGUgYGl0ZXJhdGlvbk51bWJlcmAgYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBgaXRlcmF0ZSgpYFxuICAgICAgICAvLyBjYWxsYmFjay5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2VlOiBnaXRodWIuY29tL21vemlsbGEvbG9jYWxGb3JhZ2UvcHVsbC80MzUjZGlzY3Vzc2lvbl9yMzgwNjE1MzBcbiAgICAgICAgdmFyIGl0ZXJhdGlvbk51bWJlciA9IDE7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG4gICAgICAgICAgICBpZiAoa2V5LmluZGV4T2Yoa2V5UHJlZml4KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcblxuICAgICAgICAgICAgLy8gSWYgYSByZXN1bHQgd2FzIGZvdW5kLCBwYXJzZSBpdCBmcm9tIHRoZSBzZXJpYWxpemVkXG4gICAgICAgICAgICAvLyBzdHJpbmcgaW50byBhIEpTIG9iamVjdC4gSWYgcmVzdWx0IGlzbid0IHRydXRoeSwgdGhlXG4gICAgICAgICAgICAvLyBrZXkgaXMgbGlrZWx5IHVuZGVmaW5lZCBhbmQgd2UnbGwgcGFzcyBpdCBzdHJhaWdodFxuICAgICAgICAgICAgLy8gdG8gdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkYkluZm8uc2VyaWFsaXplci5kZXNlcmlhbGl6ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gaXRlcmF0b3IodmFsdWUsIGtleS5zdWJzdHJpbmcoa2V5UHJlZml4TGVuZ3RoKSwgaXRlcmF0aW9uTnVtYmVyKyspO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gU2FtZSBhcyBsb2NhbFN0b3JhZ2UncyBrZXkoKSBtZXRob2QsIGV4Y2VwdCB0YWtlcyBhIGNhbGxiYWNrLlxuZnVuY3Rpb24ga2V5JDIobiwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByb21pc2UgPSBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBsb2NhbFN0b3JhZ2Uua2V5KG4pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcHJlZml4IGZyb20gdGhlIGtleSwgaWYgYSBrZXkgaXMgZm91bmQuXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHJpbmcoZGJJbmZvLmtleVByZWZpeC5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGtleXMkMihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcHJvbWlzZSA9IHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgdmFyIGxlbmd0aCA9IGxvY2FsU3RvcmFnZS5sZW5ndGg7XG4gICAgICAgIHZhciBrZXlzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW1LZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KGkpO1xuICAgICAgICAgICAgaWYgKGl0ZW1LZXkuaW5kZXhPZihkYkluZm8ua2V5UHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChpdGVtS2V5LnN1YnN0cmluZyhkYkluZm8ua2V5UHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBTdXBwbHkgdGhlIG51bWJlciBvZiBrZXlzIGluIHRoZSBkYXRhc3RvcmUgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuZnVuY3Rpb24gbGVuZ3RoJDIoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByb21pc2UgPSBzZWxmLmtleXMoKS50aGVuKGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIHJldHVybiBrZXlzLmxlbmd0aDtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIFJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIHN0b3JlLCBuaWNlIGFuZCBzaW1wbGUuXG5mdW5jdGlvbiByZW1vdmVJdGVtJDIoa2V5LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGRiSW5mby5rZXlQcmVmaXggKyBrZXkpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gU2V0IGEga2V5J3MgdmFsdWUgYW5kIHJ1biBhbiBvcHRpb25hbCBjYWxsYmFjayBvbmNlIHRoZSB2YWx1ZSBpcyBzZXQuXG4vLyBVbmxpa2UgR2FpYSdzIGltcGxlbWVudGF0aW9uLCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSB2YWx1ZSxcbi8vIGluIGNhc2UgeW91IHdhbnQgdG8gb3BlcmF0ZSBvbiB0aGF0IHZhbHVlIG9ubHkgYWZ0ZXIgeW91J3JlIHN1cmUgaXRcbi8vIHNhdmVkLCBvciBzb21ldGhpbmcgbGlrZSB0aGF0LlxuZnVuY3Rpb24gc2V0SXRlbSQyKGtleSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQ29udmVydCB1bmRlZmluZWQgdmFsdWVzIHRvIG51bGwuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2xvY2FsRm9yYWdlL3B1bGwvNDJcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNhdmUgdGhlIG9yaWdpbmFsIHZhbHVlIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrLlxuICAgICAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgICAgICBkYkluZm8uc2VyaWFsaXplci5zZXJpYWxpemUodmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZGJJbmZvLmtleVByZWZpeCArIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvcmlnaW5hbFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9jYWxTdG9yYWdlIGNhcGFjaXR5IGV4Y2VlZGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogTWFrZSB0aGlzIGEgc3BlY2lmaWMgZXJyb3IvZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5uYW1lID09PSAnUXVvdGFFeGNlZWRlZEVycm9yJyB8fCBlLm5hbWUgPT09ICdOU19FUlJPUl9ET01fUVVPVEFfUkVBQ0hFRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBkcm9wSW5zdGFuY2UkMihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gZ2V0Q2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyAhPT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIHZhciBjdXJyZW50Q29uZmlnID0gdGhpcy5jb25maWcoKTtcbiAgICAgICAgb3B0aW9ucy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IGN1cnJlbnRDb25maWcubmFtZTtcbiAgICAgICAgb3B0aW9ucy5zdG9yZU5hbWUgPSBvcHRpb25zLnN0b3JlTmFtZSB8fCBjdXJyZW50Q29uZmlnLnN0b3JlTmFtZTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByb21pc2U7XG4gICAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UkMS5yZWplY3QoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5zdG9yZU5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG9wdGlvbnMubmFtZSArICcvJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoX2dldEtleVByZWZpeChvcHRpb25zLCBzZWxmLl9kZWZhdWx0Q29uZmlnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGtleVByZWZpeCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxvY2FsU3RvcmFnZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KGkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKGtleVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbnZhciBsb2NhbFN0b3JhZ2VXcmFwcGVyID0ge1xuICAgIF9kcml2ZXI6ICdsb2NhbFN0b3JhZ2VXcmFwcGVyJyxcbiAgICBfaW5pdFN0b3JhZ2U6IF9pbml0U3RvcmFnZSQyLFxuICAgIF9zdXBwb3J0OiBpc0xvY2FsU3RvcmFnZVZhbGlkKCksXG4gICAgaXRlcmF0ZTogaXRlcmF0ZSQyLFxuICAgIGdldEl0ZW06IGdldEl0ZW0kMixcbiAgICBzZXRJdGVtOiBzZXRJdGVtJDIsXG4gICAgcmVtb3ZlSXRlbTogcmVtb3ZlSXRlbSQyLFxuICAgIGNsZWFyOiBjbGVhciQyLFxuICAgIGxlbmd0aDogbGVuZ3RoJDIsXG4gICAga2V5OiBrZXkkMixcbiAgICBrZXlzOiBrZXlzJDIsXG4gICAgZHJvcEluc3RhbmNlOiBkcm9wSW5zdGFuY2UkMlxufTtcblxudmFyIHNhbWVWYWx1ZSA9IGZ1bmN0aW9uIHNhbWVWYWx1ZSh4LCB5KSB7XG4gICAgcmV0dXJuIHggPT09IHkgfHwgdHlwZW9mIHggPT09ICdudW1iZXInICYmIHR5cGVvZiB5ID09PSAnbnVtYmVyJyAmJiBpc05hTih4KSAmJiBpc05hTih5KTtcbn07XG5cbnZhciBpbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzKGFycmF5LCBzZWFyY2hFbGVtZW50KSB7XG4gICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgaWYgKHNhbWVWYWx1ZShhcnJheVtpXSwgc2VhcmNoRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8vIERyaXZlcnMgYXJlIHN0b3JlZCBoZXJlIHdoZW4gYGRlZmluZURyaXZlcigpYCBpcyBjYWxsZWQuXG4vLyBUaGV5IGFyZSBzaGFyZWQgYWNyb3NzIGFsbCBpbnN0YW5jZXMgb2YgbG9jYWxGb3JhZ2UuXG52YXIgRGVmaW5lZERyaXZlcnMgPSB7fTtcblxudmFyIERyaXZlclN1cHBvcnQgPSB7fTtcblxudmFyIERlZmF1bHREcml2ZXJzID0ge1xuICAgIElOREVYRUREQjogYXN5bmNTdG9yYWdlLFxuICAgIFdFQlNRTDogd2ViU1FMU3RvcmFnZSxcbiAgICBMT0NBTFNUT1JBR0U6IGxvY2FsU3RvcmFnZVdyYXBwZXJcbn07XG5cbnZhciBEZWZhdWx0RHJpdmVyT3JkZXIgPSBbRGVmYXVsdERyaXZlcnMuSU5ERVhFRERCLl9kcml2ZXIsIERlZmF1bHREcml2ZXJzLldFQlNRTC5fZHJpdmVyLCBEZWZhdWx0RHJpdmVycy5MT0NBTFNUT1JBR0UuX2RyaXZlcl07XG5cbnZhciBPcHRpb25hbERyaXZlck1ldGhvZHMgPSBbJ2Ryb3BJbnN0YW5jZSddO1xuXG52YXIgTGlicmFyeU1ldGhvZHMgPSBbJ2NsZWFyJywgJ2dldEl0ZW0nLCAnaXRlcmF0ZScsICdrZXknLCAna2V5cycsICdsZW5ndGgnLCAncmVtb3ZlSXRlbScsICdzZXRJdGVtJ10uY29uY2F0KE9wdGlvbmFsRHJpdmVyTWV0aG9kcyk7XG5cbnZhciBEZWZhdWx0Q29uZmlnID0ge1xuICAgIGRlc2NyaXB0aW9uOiAnJyxcbiAgICBkcml2ZXI6IERlZmF1bHREcml2ZXJPcmRlci5zbGljZSgpLFxuICAgIG5hbWU6ICdsb2NhbGZvcmFnZScsXG4gICAgLy8gRGVmYXVsdCBEQiBzaXplIGlzIF9KVVNUIFVOREVSXyA1TUIsIGFzIGl0J3MgdGhlIGhpZ2hlc3Qgc2l6ZVxuICAgIC8vIHdlIGNhbiB1c2Ugd2l0aG91dCBhIHByb21wdC5cbiAgICBzaXplOiA0OTgwNzM2LFxuICAgIHN0b3JlTmFtZTogJ2tleXZhbHVlcGFpcnMnLFxuICAgIHZlcnNpb246IDEuMFxufTtcblxuZnVuY3Rpb24gY2FsbFdoZW5SZWFkeShsb2NhbEZvcmFnZUluc3RhbmNlLCBsaWJyYXJ5TWV0aG9kKSB7XG4gICAgbG9jYWxGb3JhZ2VJbnN0YW5jZVtsaWJyYXJ5TWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hcmdzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gbG9jYWxGb3JhZ2VJbnN0YW5jZS5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsRm9yYWdlSW5zdGFuY2VbbGlicmFyeU1ldGhvZF0uYXBwbHkobG9jYWxGb3JhZ2VJbnN0YW5jZSwgX2FyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfa2V5IGluIGFyZykge1xuICAgICAgICAgICAgICAgIGlmIChhcmcuaGFzT3duUHJvcGVydHkoX2tleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoYXJnW19rZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzWzBdW19rZXldID0gYXJnW19rZXldLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNbMF1bX2tleV0gPSBhcmdbX2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xufVxuXG52YXIgTG9jYWxGb3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG9jYWxGb3JhZ2Uob3B0aW9ucykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9jYWxGb3JhZ2UpO1xuXG4gICAgICAgIGZvciAodmFyIGRyaXZlclR5cGVLZXkgaW4gRGVmYXVsdERyaXZlcnMpIHtcbiAgICAgICAgICAgIGlmIChEZWZhdWx0RHJpdmVycy5oYXNPd25Qcm9wZXJ0eShkcml2ZXJUeXBlS2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciBkcml2ZXIgPSBEZWZhdWx0RHJpdmVyc1tkcml2ZXJUeXBlS2V5XTtcbiAgICAgICAgICAgICAgICB2YXIgZHJpdmVyTmFtZSA9IGRyaXZlci5fZHJpdmVyO1xuICAgICAgICAgICAgICAgIHRoaXNbZHJpdmVyVHlwZUtleV0gPSBkcml2ZXJOYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFEZWZpbmVkRHJpdmVyc1tkcml2ZXJOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHdhaXQgZm9yIHRoZSBwcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCBkcml2ZXJzIGNhbiBiZSBkZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGEgYmxvY2tpbmcgbWFubmVyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lRHJpdmVyKGRyaXZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGVmYXVsdENvbmZpZyA9IGV4dGVuZCh7fSwgRGVmYXVsdENvbmZpZyk7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGV4dGVuZCh7fSwgdGhpcy5fZGVmYXVsdENvbmZpZywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2RyaXZlclNldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2luaXREcml2ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZWFkeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kYkluZm8gPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3dyYXBMaWJyYXJ5TWV0aG9kc1dpdGhSZWFkeSgpO1xuICAgICAgICB0aGlzLnNldERyaXZlcih0aGlzLl9jb25maWcuZHJpdmVyKVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHt9KTtcbiAgICB9XG5cbiAgICAvLyBTZXQgYW55IGNvbmZpZyB2YWx1ZXMgZm9yIGxvY2FsRm9yYWdlOyBjYW4gYmUgY2FsbGVkIGFueXRpbWUgYmVmb3JlXG4gICAgLy8gdGhlIGZpcnN0IEFQSSBjYWxsIChlLmcuIGBnZXRJdGVtYCwgYHNldEl0ZW1gKS5cbiAgICAvLyBXZSBsb29wIHRocm91Z2ggb3B0aW9ucyBzbyB3ZSBkb24ndCBvdmVyd3JpdGUgZXhpc3RpbmcgY29uZmlnXG4gICAgLy8gdmFsdWVzLlxuXG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuY29uZmlnID0gZnVuY3Rpb24gY29uZmlnKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gSWYgdGhlIG9wdGlvbnMgYXJndW1lbnQgaXMgYW4gb2JqZWN0LCB3ZSB1c2UgaXQgdG8gc2V0IHZhbHVlcy5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSByZXR1cm4gZWl0aGVyIGEgc3BlY2lmaWVkIGNvbmZpZyB2YWx1ZSBvciBhbGxcbiAgICAgICAgLy8gY29uZmlnIHZhbHVlcy5cbiAgICAgICAgaWYgKCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob3B0aW9ucykpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gSWYgbG9jYWxmb3JhZ2UgaXMgcmVhZHkgYW5kIGZ1bGx5IGluaXRpYWxpemVkLCB3ZSBjYW4ndCBzZXRcbiAgICAgICAgICAgIC8vIGFueSBuZXcgY29uZmlndXJhdGlvbiB2YWx1ZXMuIEluc3RlYWQsIHdlIHJldHVybiBhbiBlcnJvci5cbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJDYW4ndCBjYWxsIGNvbmZpZygpIGFmdGVyIGxvY2FsZm9yYWdlIFwiICsgJ2hhcyBiZWVuIHVzZWQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAnc3RvcmVOYW1lJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2ldID0gb3B0aW9uc1tpXS5yZXBsYWNlKC9cXFcvZywgJ18nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gJ3ZlcnNpb24nICYmIHR5cGVvZiBvcHRpb25zW2ldICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdEYXRhYmFzZSB2ZXJzaW9uIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fY29uZmlnW2ldID0gb3B0aW9uc1tpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWZ0ZXIgYWxsIGNvbmZpZyBvcHRpb25zIGFyZSBzZXQgYW5kXG4gICAgICAgICAgICAvLyB0aGUgZHJpdmVyIG9wdGlvbiBpcyB1c2VkLCB0cnkgc2V0dGluZyBpdFxuICAgICAgICAgICAgaWYgKCdkcml2ZXInIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5kcml2ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXREcml2ZXIodGhpcy5fY29uZmlnLmRyaXZlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZ1tvcHRpb25zXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb25maWc7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gVXNlZCB0byBkZWZpbmUgYSBjdXN0b20gZHJpdmVyLCBzaGFyZWQgYWNyb3NzIGFsbCBpbnN0YW5jZXMgb2ZcbiAgICAvLyBsb2NhbEZvcmFnZS5cblxuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLmRlZmluZURyaXZlciA9IGZ1bmN0aW9uIGRlZmluZURyaXZlcihkcml2ZXJPYmplY3QsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBkcml2ZXJOYW1lID0gZHJpdmVyT2JqZWN0Ll9kcml2ZXI7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBsaWFuY2VFcnJvciA9IG5ldyBFcnJvcignQ3VzdG9tIGRyaXZlciBub3QgY29tcGxpYW50OyBzZWUgJyArICdodHRwczovL21vemlsbGEuZ2l0aHViLmlvL2xvY2FsRm9yYWdlLyNkZWZpbmVkcml2ZXInKTtcblxuICAgICAgICAgICAgICAgIC8vIEEgZHJpdmVyIG5hbWUgc2hvdWxkIGJlIGRlZmluZWQgYW5kIG5vdCBvdmVybGFwIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gbGlicmFyeS1kZWZpbmVkLCBkZWZhdWx0IGRyaXZlcnMuXG4gICAgICAgICAgICAgICAgaWYgKCFkcml2ZXJPYmplY3QuX2RyaXZlcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoY29tcGxpYW5jZUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBkcml2ZXJNZXRob2RzID0gTGlicmFyeU1ldGhvZHMuY29uY2F0KCdfaW5pdFN0b3JhZ2UnKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZHJpdmVyTWV0aG9kcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHJpdmVyTWV0aG9kTmFtZSA9IGRyaXZlck1ldGhvZHNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgcHJvcGVydHkgaXMgdGhlcmUsXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IHNob3VsZCBiZSBhIG1ldGhvZCBldmVuIHdoZW4gb3B0aW9uYWxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzUmVxdWlyZWQgPSAhaW5jbHVkZXMoT3B0aW9uYWxEcml2ZXJNZXRob2RzLCBkcml2ZXJNZXRob2ROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChpc1JlcXVpcmVkIHx8IGRyaXZlck9iamVjdFtkcml2ZXJNZXRob2ROYW1lXSkgJiYgdHlwZW9mIGRyaXZlck9iamVjdFtkcml2ZXJNZXRob2ROYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGNvbXBsaWFuY2VFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29uZmlndXJlTWlzc2luZ01ldGhvZHMgPSBmdW5jdGlvbiBjb25maWd1cmVNaXNzaW5nTWV0aG9kcygpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZE5vdEltcGxlbWVudGVkRmFjdG9yeSA9IGZ1bmN0aW9uIG1ldGhvZE5vdEltcGxlbWVudGVkRmFjdG9yeShtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignTWV0aG9kICcgKyBtZXRob2ROYW1lICsgJyBpcyBub3QgaW1wbGVtZW50ZWQgYnkgdGhlIGN1cnJlbnQgZHJpdmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBQcm9taXNlJDEucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2xlbiA9IE9wdGlvbmFsRHJpdmVyTWV0aG9kcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbmFsRHJpdmVyTWV0aG9kID0gT3B0aW9uYWxEcml2ZXJNZXRob2RzW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZHJpdmVyT2JqZWN0W29wdGlvbmFsRHJpdmVyTWV0aG9kXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyaXZlck9iamVjdFtvcHRpb25hbERyaXZlck1ldGhvZF0gPSBtZXRob2ROb3RJbXBsZW1lbnRlZEZhY3Rvcnkob3B0aW9uYWxEcml2ZXJNZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZU1pc3NpbmdNZXRob2RzKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2V0RHJpdmVyU3VwcG9ydCA9IGZ1bmN0aW9uIHNldERyaXZlclN1cHBvcnQoc3VwcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoRGVmaW5lZERyaXZlcnNbZHJpdmVyTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnUmVkZWZpbmluZyBMb2NhbEZvcmFnZSBkcml2ZXI6ICcgKyBkcml2ZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBEZWZpbmVkRHJpdmVyc1tkcml2ZXJOYW1lXSA9IGRyaXZlck9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgRHJpdmVyU3VwcG9ydFtkcml2ZXJOYW1lXSA9IHN1cHBvcnQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IHVzZSBhIHRoZW4sIHNvIHRoYXQgd2UgY2FuIGRlZmluZVxuICAgICAgICAgICAgICAgICAgICAvLyBkcml2ZXJzIHRoYXQgaGF2ZSBzaW1wbGUgX3N1cHBvcnQgbWV0aG9kc1xuICAgICAgICAgICAgICAgICAgICAvLyBpbiBhIGJsb2NraW5nIG1hbm5lclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmICgnX3N1cHBvcnQnIGluIGRyaXZlck9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJpdmVyT2JqZWN0Ll9zdXBwb3J0ICYmIHR5cGVvZiBkcml2ZXJPYmplY3QuX3N1cHBvcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyaXZlck9iamVjdC5fc3VwcG9ydCgpLnRoZW4oc2V0RHJpdmVyU3VwcG9ydCwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldERyaXZlclN1cHBvcnQoISFkcml2ZXJPYmplY3QuX3N1cHBvcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RHJpdmVyU3VwcG9ydCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBleGVjdXRlVHdvQ2FsbGJhY2tzKHByb21pc2UsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5kcml2ZXIgPSBmdW5jdGlvbiBkcml2ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcml2ZXIgfHwgbnVsbDtcbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLmdldERyaXZlciA9IGZ1bmN0aW9uIGdldERyaXZlcihkcml2ZXJOYW1lLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICB2YXIgZ2V0RHJpdmVyUHJvbWlzZSA9IERlZmluZWREcml2ZXJzW2RyaXZlck5hbWVdID8gUHJvbWlzZSQxLnJlc29sdmUoRGVmaW5lZERyaXZlcnNbZHJpdmVyTmFtZV0pIDogUHJvbWlzZSQxLnJlamVjdChuZXcgRXJyb3IoJ0RyaXZlciBub3QgZm91bmQuJykpO1xuXG4gICAgICAgIGV4ZWN1dGVUd29DYWxsYmFja3MoZ2V0RHJpdmVyUHJvbWlzZSwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gZ2V0RHJpdmVyUHJvbWlzZTtcbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLmdldFNlcmlhbGl6ZXIgPSBmdW5jdGlvbiBnZXRTZXJpYWxpemVyKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVyUHJvbWlzZSA9IFByb21pc2UkMS5yZXNvbHZlKGxvY2FsZm9yYWdlU2VyaWFsaXplcik7XG4gICAgICAgIGV4ZWN1dGVUd29DYWxsYmFja3Moc2VyaWFsaXplclByb21pc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXJQcm9taXNlO1xuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiByZWFkeShjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHByb21pc2UgPSBzZWxmLl9kcml2ZXJTZXQudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fcmVhZHkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9yZWFkeSA9IHNlbGYuX2luaXREcml2ZXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3JlYWR5O1xuICAgICAgICB9KTtcblxuICAgICAgICBleGVjdXRlVHdvQ2FsbGJhY2tzKHByb21pc2UsIGNhbGxiYWNrLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuc2V0RHJpdmVyID0gZnVuY3Rpb24gc2V0RHJpdmVyKGRyaXZlcnMsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBpZiAoIWlzQXJyYXkoZHJpdmVycykpIHtcbiAgICAgICAgICAgIGRyaXZlcnMgPSBbZHJpdmVyc107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3VwcG9ydGVkRHJpdmVycyA9IHRoaXMuX2dldFN1cHBvcnRlZERyaXZlcnMoZHJpdmVycyk7XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0RHJpdmVyVG9Db25maWcoKSB7XG4gICAgICAgICAgICBzZWxmLl9jb25maWcuZHJpdmVyID0gc2VsZi5kcml2ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGV4dGVuZFNlbGZXaXRoRHJpdmVyKGRyaXZlcikge1xuICAgICAgICAgICAgc2VsZi5fZXh0ZW5kKGRyaXZlcik7XG4gICAgICAgICAgICBzZXREcml2ZXJUb0NvbmZpZygpO1xuXG4gICAgICAgICAgICBzZWxmLl9yZWFkeSA9IHNlbGYuX2luaXRTdG9yYWdlKHNlbGYuX2NvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fcmVhZHk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbml0RHJpdmVyKHN1cHBvcnRlZERyaXZlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnREcml2ZXJJbmRleCA9IDA7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkcml2ZXJQcm9taXNlTG9vcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnREcml2ZXJJbmRleCA8IHN1cHBvcnRlZERyaXZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHJpdmVyTmFtZSA9IHN1cHBvcnRlZERyaXZlcnNbY3VycmVudERyaXZlckluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREcml2ZXJJbmRleCsrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9kYkluZm8gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcmVhZHkgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXREcml2ZXIoZHJpdmVyTmFtZSkudGhlbihleHRlbmRTZWxmV2l0aERyaXZlcilbXCJjYXRjaFwiXShkcml2ZXJQcm9taXNlTG9vcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZXREcml2ZXJUb0NvbmZpZygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ05vIGF2YWlsYWJsZSBzdG9yYWdlIG1ldGhvZCBmb3VuZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZHJpdmVyU2V0ID0gUHJvbWlzZSQxLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9kcml2ZXJTZXQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRyaXZlclByb21pc2VMb29wKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgYSBkcml2ZXIgaW5pdGlhbGl6YXRpb24gaW4gcHJvZ3Jlc3NcbiAgICAgICAgLy8gc28gd2FpdCBmb3IgaXQgdG8gZmluaXNoIGluIG9yZGVyIHRvIGF2b2lkIGEgcG9zc2libGVcbiAgICAgICAgLy8gcmFjZSBjb25kaXRpb24gdG8gc2V0IF9kYkluZm9cbiAgICAgICAgdmFyIG9sZERyaXZlclNldERvbmUgPSB0aGlzLl9kcml2ZXJTZXQgIT09IG51bGwgPyB0aGlzLl9kcml2ZXJTZXRbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZSQxLnJlc29sdmUoKTtcbiAgICAgICAgfSkgOiBQcm9taXNlJDEucmVzb2x2ZSgpO1xuXG4gICAgICAgIHRoaXMuX2RyaXZlclNldCA9IG9sZERyaXZlclNldERvbmUudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZHJpdmVyTmFtZSA9IHN1cHBvcnRlZERyaXZlcnNbMF07XG4gICAgICAgICAgICBzZWxmLl9kYkluZm8gPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5fcmVhZHkgPSBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5nZXREcml2ZXIoZHJpdmVyTmFtZSkudGhlbihmdW5jdGlvbiAoZHJpdmVyKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fZHJpdmVyID0gZHJpdmVyLl9kcml2ZXI7XG4gICAgICAgICAgICAgICAgc2V0RHJpdmVyVG9Db25maWcoKTtcbiAgICAgICAgICAgICAgICBzZWxmLl93cmFwTGlicmFyeU1ldGhvZHNXaXRoUmVhZHkoKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbml0RHJpdmVyID0gaW5pdERyaXZlcihzdXBwb3J0ZWREcml2ZXJzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldERyaXZlclRvQ29uZmlnKCk7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ05vIGF2YWlsYWJsZSBzdG9yYWdlIG1ldGhvZCBmb3VuZC4nKTtcbiAgICAgICAgICAgIHNlbGYuX2RyaXZlclNldCA9IFByb21pc2UkMS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2RyaXZlclNldDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhlY3V0ZVR3b0NhbGxiYWNrcyh0aGlzLl9kcml2ZXJTZXQsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RyaXZlclNldDtcbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24gc3VwcG9ydHMoZHJpdmVyTmFtZSkge1xuICAgICAgICByZXR1cm4gISFEcml2ZXJTdXBwb3J0W2RyaXZlck5hbWVdO1xuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuX2V4dGVuZCA9IGZ1bmN0aW9uIF9leHRlbmQobGlicmFyeU1ldGhvZHNBbmRQcm9wZXJ0aWVzKSB7XG4gICAgICAgIGV4dGVuZCh0aGlzLCBsaWJyYXJ5TWV0aG9kc0FuZFByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuX2dldFN1cHBvcnRlZERyaXZlcnMgPSBmdW5jdGlvbiBfZ2V0U3VwcG9ydGVkRHJpdmVycyhkcml2ZXJzKSB7XG4gICAgICAgIHZhciBzdXBwb3J0ZWREcml2ZXJzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkcml2ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZHJpdmVyTmFtZSA9IGRyaXZlcnNbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5zdXBwb3J0cyhkcml2ZXJOYW1lKSkge1xuICAgICAgICAgICAgICAgIHN1cHBvcnRlZERyaXZlcnMucHVzaChkcml2ZXJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwcG9ydGVkRHJpdmVycztcbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLl93cmFwTGlicmFyeU1ldGhvZHNXaXRoUmVhZHkgPSBmdW5jdGlvbiBfd3JhcExpYnJhcnlNZXRob2RzV2l0aFJlYWR5KCkge1xuICAgICAgICAvLyBBZGQgYSBzdHViIGZvciBlYWNoIGRyaXZlciBBUEkgbWV0aG9kIHRoYXQgZGVsYXlzIHRoZSBjYWxsIHRvIHRoZVxuICAgICAgICAvLyBjb3JyZXNwb25kaW5nIGRyaXZlciBtZXRob2QgdW50aWwgbG9jYWxGb3JhZ2UgaXMgcmVhZHkuIFRoZXNlIHN0dWJzXG4gICAgICAgIC8vIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGRyaXZlciBtZXRob2RzIGFzIHNvb24gYXMgdGhlIGRyaXZlciBpc1xuICAgICAgICAvLyBsb2FkZWQsIHNvIHRoZXJlIGlzIG5vIHBlcmZvcm1hbmNlIGltcGFjdC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IExpYnJhcnlNZXRob2RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjYWxsV2hlblJlYWR5KHRoaXMsIExpYnJhcnlNZXRob2RzW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuY3JlYXRlSW5zdGFuY2UgPSBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9jYWxGb3JhZ2Uob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHJldHVybiBMb2NhbEZvcmFnZTtcbn0oKTtcblxuLy8gVGhlIGFjdHVhbCBsb2NhbEZvcmFnZSBvYmplY3QgdGhhdCB3ZSBleHBvc2UgYXMgYSBtb2R1bGUgb3IgdmlhIGFcbi8vIGdsb2JhbC4gSXQncyBleHRlbmRlZCBieSBwdWxsaW5nIGluIG9uZSBvZiBvdXIgb3RoZXIgbGlicmFyaWVzLlxuXG5cbnZhciBsb2NhbGZvcmFnZV9qcyA9IG5ldyBMb2NhbEZvcmFnZSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvY2FsZm9yYWdlX2pzO1xuXG59LHtcIjNcIjozfV19LHt9LFs0XSkoNClcbn0pO1xuIl0sIm5hbWVzIjpbImYiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwiZyIsIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJsb2NhbGZvcmFnZSIsImUiLCJ0IiwibiIsInIiLCJzIiwibyIsInUiLCJhIiwicmVxdWlyZSIsImkiLCJFcnJvciIsImNvZGUiLCJsIiwiY2FsbCIsImxlbmd0aCIsIl9kZXJlcV8iLCJNdXRhdGlvbiIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJXZWJLaXRNdXRhdGlvbk9ic2VydmVyIiwic2NoZWR1bGVEcmFpbiIsImNhbGxlZCIsIm9ic2VydmVyIiwibmV4dFRpY2siLCJlbGVtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVUZXh0Tm9kZSIsIm9ic2VydmUiLCJjaGFyYWN0ZXJEYXRhIiwiZGF0YSIsInNldEltbWVkaWF0ZSIsIk1lc3NhZ2VDaGFubmVsIiwiY2hhbm5lbCIsInBvcnQxIiwib25tZXNzYWdlIiwicG9ydDIiLCJwb3N0TWVzc2FnZSIsImNyZWF0ZUVsZW1lbnQiLCJzY3JpcHRFbCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImRvY3VtZW50RWxlbWVudCIsImFwcGVuZENoaWxkIiwic2V0VGltZW91dCIsImRyYWluaW5nIiwicXVldWUiLCJvbGRRdWV1ZSIsImxlbiIsImltbWVkaWF0ZSIsInRhc2siLCJwdXNoIiwiSU5URVJOQUwiLCJoYW5kbGVycyIsIlJFSkVDVEVEIiwiRlVMRklMTEVEIiwiUEVORElORyIsIlByb21pc2UiLCJyZXNvbHZlciIsIlR5cGVFcnJvciIsInN0YXRlIiwib3V0Y29tZSIsInNhZmVseVJlc29sdmVUaGVuYWJsZSIsInByb3RvdHlwZSIsIm9uUmVqZWN0ZWQiLCJ0aGVuIiwib25GdWxmaWxsZWQiLCJwcm9taXNlIiwiY29uc3RydWN0b3IiLCJ1bndyYXAiLCJRdWV1ZUl0ZW0iLCJjYWxsRnVsZmlsbGVkIiwib3RoZXJDYWxsRnVsZmlsbGVkIiwiY2FsbFJlamVjdGVkIiwib3RoZXJDYWxsUmVqZWN0ZWQiLCJ2YWx1ZSIsInJlc29sdmUiLCJyZWplY3QiLCJmdW5jIiwicmV0dXJuVmFsdWUiLCJyZXN1bHQiLCJ0cnlDYXRjaCIsImdldFRoZW4iLCJzdGF0dXMiLCJ0aGVuYWJsZSIsImVycm9yIiwib2JqIiwiYXBweVRoZW4iLCJhcHBseSIsImFyZ3VtZW50cyIsIm9uRXJyb3IiLCJvblN1Y2Nlc3MiLCJ0cnlUb1Vud3JhcCIsIm91dCIsInJlYXNvbiIsImFsbCIsIml0ZXJhYmxlIiwiT2JqZWN0IiwidG9TdHJpbmciLCJ2YWx1ZXMiLCJBcnJheSIsInJlc29sdmVkIiwiYWxsUmVzb2x2ZXIiLCJyZXNvbHZlRnJvbUFsbCIsIm91dFZhbHVlIiwicmFjZSIsInJlc3BvbnNlIiwiX3R5cGVvZiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsImdldElEQiIsImluZGV4ZWREQiIsIndlYmtpdEluZGV4ZWREQiIsIm1vekluZGV4ZWREQiIsIk9JbmRleGVkREIiLCJtc0luZGV4ZWREQiIsImlkYiIsImlzSW5kZXhlZERCVmFsaWQiLCJvcGVuIiwiaXNTYWZhcmkiLCJvcGVuRGF0YWJhc2UiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwicGxhdGZvcm0iLCJoYXNGZXRjaCIsImZldGNoIiwiaW5kZXhPZiIsIklEQktleVJhbmdlIiwiY3JlYXRlQmxvYiIsInBhcnRzIiwicHJvcGVydGllcyIsIkJsb2IiLCJuYW1lIiwiQnVpbGRlciIsIkJsb2JCdWlsZGVyIiwiTVNCbG9iQnVpbGRlciIsIk1vekJsb2JCdWlsZGVyIiwiV2ViS2l0QmxvYkJ1aWxkZXIiLCJidWlsZGVyIiwiYXBwZW5kIiwiZ2V0QmxvYiIsInR5cGUiLCJQcm9taXNlJDEiLCJleGVjdXRlQ2FsbGJhY2siLCJjYWxsYmFjayIsImV4ZWN1dGVUd29DYWxsYmFja3MiLCJlcnJvckNhbGxiYWNrIiwibm9ybWFsaXplS2V5Iiwia2V5IiwiY29uc29sZSIsIndhcm4iLCJTdHJpbmciLCJnZXRDYWxsYmFjayIsIkRFVEVDVF9CTE9CX1NVUFBPUlRfU1RPUkUiLCJzdXBwb3J0c0Jsb2JzIiwiZGJDb250ZXh0cyIsIlJFQURfT05MWSIsIlJFQURfV1JJVEUiLCJfYmluU3RyaW5nVG9BcnJheUJ1ZmZlciIsImJpbiIsImJ1ZiIsIkFycmF5QnVmZmVyIiwiYXJyIiwiVWludDhBcnJheSIsImNoYXJDb2RlQXQiLCJfY2hlY2tCbG9iU3VwcG9ydFdpdGhvdXRDYWNoaW5nIiwidHhuIiwidHJhbnNhY3Rpb24iLCJibG9iIiwib2JqZWN0U3RvcmUiLCJwdXQiLCJvbmFib3J0IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJvbmNvbXBsZXRlIiwibWF0Y2hlZENocm9tZSIsIm1hdGNoIiwibWF0Y2hlZEVkZ2UiLCJwYXJzZUludCIsIl9jaGVja0Jsb2JTdXBwb3J0IiwiX2RlZmVyUmVhZGluZXNzIiwiZGJJbmZvIiwiZGJDb250ZXh0IiwiZGVmZXJyZWRPcGVyYXRpb24iLCJkZWZlcnJlZE9wZXJhdGlvbnMiLCJkYlJlYWR5IiwiX2FkdmFuY2VSZWFkaW5lc3MiLCJwb3AiLCJfcmVqZWN0UmVhZGluZXNzIiwiZXJyIiwiX2dldENvbm5lY3Rpb24iLCJ1cGdyYWRlTmVlZGVkIiwiY3JlYXRlRGJDb250ZXh0IiwiZGIiLCJjbG9zZSIsImRiQXJncyIsInZlcnNpb24iLCJvcGVucmVxIiwib251cGdyYWRlbmVlZGVkIiwiY3JlYXRlT2JqZWN0U3RvcmUiLCJzdG9yZU5hbWUiLCJvbGRWZXJzaW9uIiwiZXgiLCJuZXdWZXJzaW9uIiwib25lcnJvciIsIm9uc3VjY2VzcyIsIm9udmVyc2lvbmNoYW5nZSIsInRhcmdldCIsIl9nZXRPcmlnaW5hbENvbm5lY3Rpb24iLCJfZ2V0VXBncmFkZWRDb25uZWN0aW9uIiwiX2lzVXBncmFkZU5lZWRlZCIsImRlZmF1bHRWZXJzaW9uIiwiaXNOZXdTdG9yZSIsIm9iamVjdFN0b3JlTmFtZXMiLCJjb250YWlucyIsImlzRG93bmdyYWRlIiwiaXNVcGdyYWRlIiwiaW5jVmVyc2lvbiIsIl9lbmNvZGVCbG9iIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZGVuZCIsImJhc2U2NCIsImJ0b2EiLCJfX2xvY2FsX2ZvcmFnZV9lbmNvZGVkX2Jsb2IiLCJyZWFkQXNCaW5hcnlTdHJpbmciLCJfZGVjb2RlQmxvYiIsImVuY29kZWRCbG9iIiwiYXJyYXlCdWZmIiwiYXRvYiIsIl9pc0VuY29kZWRCbG9iIiwiX2Z1bGx5UmVhZHkiLCJfaW5pdFJlYWR5IiwiX2RiSW5mbyIsIl90cnlSZWNvbm5lY3QiLCJmb3JhZ2VzIiwiZm9yYWdlIiwiY3JlYXRlVHJhbnNhY3Rpb24iLCJtb2RlIiwicmV0cmllcyIsInVuZGVmaW5lZCIsInR4IiwiX2luaXRTdG9yYWdlIiwib3B0aW9ucyIsInJlYWR5IiwiaW5pdFByb21pc2VzIiwiaWdub3JlRXJyb3JzIiwiaiIsInNsaWNlIiwiX2RlZmF1bHRDb25maWciLCJrIiwiZ2V0SXRlbSIsInN0b3JlIiwicmVxIiwiZ2V0IiwiaXRlcmF0ZSIsIm9wZW5DdXJzb3IiLCJpdGVyYXRpb25OdW1iZXIiLCJjdXJzb3IiLCJzZXRJdGVtIiwiYmxvYlN1cHBvcnQiLCJyZW1vdmVJdGVtIiwiY2xlYXIiLCJjb3VudCIsImFkdmFuY2VkIiwib3BlbktleUN1cnNvciIsImFkdmFuY2UiLCJrZXlzIiwiZHJvcEluc3RhbmNlIiwiY3VycmVudENvbmZpZyIsImNvbmZpZyIsImlzQ3VycmVudERiIiwiZGJQcm9taXNlIiwiZHJvcERCUHJvbWlzZSIsImRlbGV0ZURhdGFiYXNlIiwib25ibG9ja2VkIiwiX2ZvcmFnZSIsImRyb3BPYmplY3RQcm9taXNlIiwiZGVsZXRlT2JqZWN0U3RvcmUiLCJfZm9yYWdlMiIsImFzeW5jU3RvcmFnZSIsIl9kcml2ZXIiLCJfc3VwcG9ydCIsImlzV2ViU1FMVmFsaWQiLCJCQVNFX0NIQVJTIiwiQkxPQl9UWVBFX1BSRUZJWCIsIkJMT0JfVFlQRV9QUkVGSVhfUkVHRVgiLCJTRVJJQUxJWkVEX01BUktFUiIsIlNFUklBTElaRURfTUFSS0VSX0xFTkdUSCIsIlRZUEVfQVJSQVlCVUZGRVIiLCJUWVBFX0JMT0IiLCJUWVBFX0lOVDhBUlJBWSIsIlRZUEVfVUlOVDhBUlJBWSIsIlRZUEVfVUlOVDhDTEFNUEVEQVJSQVkiLCJUWVBFX0lOVDE2QVJSQVkiLCJUWVBFX0lOVDMyQVJSQVkiLCJUWVBFX1VJTlQxNkFSUkFZIiwiVFlQRV9VSU5UMzJBUlJBWSIsIlRZUEVfRkxPQVQzMkFSUkFZIiwiVFlQRV9GTE9BVDY0QVJSQVkiLCJUWVBFX1NFUklBTElaRURfTUFSS0VSX0xFTkdUSCIsInRvU3RyaW5nJDEiLCJzdHJpbmdUb0J1ZmZlciIsInNlcmlhbGl6ZWRTdHJpbmciLCJidWZmZXJMZW5ndGgiLCJwIiwiZW5jb2RlZDEiLCJlbmNvZGVkMiIsImVuY29kZWQzIiwiZW5jb2RlZDQiLCJidWZmZXIiLCJieXRlcyIsImJ1ZmZlclRvU3RyaW5nIiwiYmFzZTY0U3RyaW5nIiwic3Vic3RyaW5nIiwic2VyaWFsaXplIiwidmFsdWVUeXBlIiwibWFya2VyIiwiZmlsZVJlYWRlciIsIm9ubG9hZCIsInN0ciIsInJlYWRBc0FycmF5QnVmZmVyIiwiSlNPTiIsInN0cmluZ2lmeSIsImRlc2VyaWFsaXplIiwicGFyc2UiLCJibG9iVHlwZSIsIm1hdGNoZXIiLCJJbnQ4QXJyYXkiLCJVaW50OENsYW1wZWRBcnJheSIsIkludDE2QXJyYXkiLCJVaW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJVaW50MzJBcnJheSIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsImxvY2FsZm9yYWdlU2VyaWFsaXplciIsImNyZWF0ZURiVGFibGUiLCJleGVjdXRlU3FsIiwiX2luaXRTdG9yYWdlJDEiLCJkYkluZm9Qcm9taXNlIiwiZGVzY3JpcHRpb24iLCJzaXplIiwic2VyaWFsaXplciIsInRyeUV4ZWN1dGVTcWwiLCJzcWxTdGF0ZW1lbnQiLCJhcmdzIiwiU1lOVEFYX0VSUiIsInJlc3VsdHMiLCJyb3dzIiwiZ2V0SXRlbSQxIiwiaXRlbSIsIml0ZXJhdGUkMSIsIl9zZXRJdGVtIiwicmV0cmllc0xlZnQiLCJvcmlnaW5hbFZhbHVlIiwic3FsRXJyb3IiLCJRVU9UQV9FUlIiLCJzZXRJdGVtJDEiLCJyZW1vdmVJdGVtJDEiLCJjbGVhciQxIiwibGVuZ3RoJDEiLCJjIiwia2V5JDEiLCJrZXlzJDEiLCJnZXRBbGxTdG9yZU5hbWVzIiwic3RvcmVOYW1lcyIsImRyb3BJbnN0YW5jZSQxIiwib3BlcmF0aW9uSW5mbyIsImRyb3BUYWJsZSIsIm9wZXJhdGlvbnMiLCJ3ZWJTUUxTdG9yYWdlIiwiaXNMb2NhbFN0b3JhZ2VWYWxpZCIsImxvY2FsU3RvcmFnZSIsIl9nZXRLZXlQcmVmaXgiLCJkZWZhdWx0Q29uZmlnIiwia2V5UHJlZml4IiwiY2hlY2tJZkxvY2FsU3RvcmFnZVRocm93cyIsImxvY2FsU3RvcmFnZVRlc3RLZXkiLCJfaXNMb2NhbFN0b3JhZ2VVc2FibGUiLCJfaW5pdFN0b3JhZ2UkMiIsImNsZWFyJDIiLCJnZXRJdGVtJDIiLCJpdGVyYXRlJDIiLCJrZXlQcmVmaXhMZW5ndGgiLCJrZXkkMiIsImtleXMkMiIsIml0ZW1LZXkiLCJsZW5ndGgkMiIsInJlbW92ZUl0ZW0kMiIsInNldEl0ZW0kMiIsImRyb3BJbnN0YW5jZSQyIiwibG9jYWxTdG9yYWdlV3JhcHBlciIsInNhbWVWYWx1ZSIsIngiLCJ5IiwiaXNOYU4iLCJpbmNsdWRlcyIsImFycmF5Iiwic2VhcmNoRWxlbWVudCIsImlzQXJyYXkiLCJhcmciLCJEZWZpbmVkRHJpdmVycyIsIkRyaXZlclN1cHBvcnQiLCJEZWZhdWx0RHJpdmVycyIsIklOREVYRUREQiIsIldFQlNRTCIsIkxPQ0FMU1RPUkFHRSIsIkRlZmF1bHREcml2ZXJPcmRlciIsIk9wdGlvbmFsRHJpdmVyTWV0aG9kcyIsIkxpYnJhcnlNZXRob2RzIiwiY29uY2F0IiwiRGVmYXVsdENvbmZpZyIsImRyaXZlciIsImNhbGxXaGVuUmVhZHkiLCJsb2NhbEZvcmFnZUluc3RhbmNlIiwibGlicmFyeU1ldGhvZCIsIl9hcmdzIiwiZXh0ZW5kIiwiX2tleSIsImhhc093blByb3BlcnR5IiwiTG9jYWxGb3JhZ2UiLCJkcml2ZXJUeXBlS2V5IiwiZHJpdmVyTmFtZSIsImRlZmluZURyaXZlciIsIl9jb25maWciLCJfZHJpdmVyU2V0IiwiX2luaXREcml2ZXIiLCJfcmVhZHkiLCJfd3JhcExpYnJhcnlNZXRob2RzV2l0aFJlYWR5Iiwic2V0RHJpdmVyIiwicmVwbGFjZSIsImRyaXZlck9iamVjdCIsImNvbXBsaWFuY2VFcnJvciIsImRyaXZlck1ldGhvZHMiLCJkcml2ZXJNZXRob2ROYW1lIiwiaXNSZXF1aXJlZCIsImNvbmZpZ3VyZU1pc3NpbmdNZXRob2RzIiwibWV0aG9kTm90SW1wbGVtZW50ZWRGYWN0b3J5IiwibWV0aG9kTmFtZSIsIl9pIiwiX2xlbiIsIm9wdGlvbmFsRHJpdmVyTWV0aG9kIiwic2V0RHJpdmVyU3VwcG9ydCIsInN1cHBvcnQiLCJpbmZvIiwiZ2V0RHJpdmVyIiwiZ2V0RHJpdmVyUHJvbWlzZSIsImdldFNlcmlhbGl6ZXIiLCJzZXJpYWxpemVyUHJvbWlzZSIsImRyaXZlcnMiLCJzdXBwb3J0ZWREcml2ZXJzIiwiX2dldFN1cHBvcnRlZERyaXZlcnMiLCJzZXREcml2ZXJUb0NvbmZpZyIsImV4dGVuZFNlbGZXaXRoRHJpdmVyIiwiX2V4dGVuZCIsImluaXREcml2ZXIiLCJjdXJyZW50RHJpdmVySW5kZXgiLCJkcml2ZXJQcm9taXNlTG9vcCIsIm9sZERyaXZlclNldERvbmUiLCJzdXBwb3J0cyIsImxpYnJhcnlNZXRob2RzQW5kUHJvcGVydGllcyIsImNyZWF0ZUluc3RhbmNlIiwibG9jYWxmb3JhZ2VfanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/localforage/dist/localforage.js\n");

/***/ })

};
;